create type "public"."regrade_status" as enum ('draft', 'opened', 'resolved', 'escalated', 'closed');

CREATE OR REPLACE FUNCTION public.assignments_grader_config_auto_populate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
    declare 
    rubric_id int;
    self_rubric_id int;
    begin
  
  INSERT INTO autograder (id, class_id) VALUES (NEW.id, NEW.class_id);
  INSERT INTO autograder_regression_test (autograder_id,repository) VALUES (NEW.id, NEW.template_repo);
  INSERT INTO rubrics (name, class_id, assignment_id, review_round) VALUES ('Grading Rubric', NEW.class_id, NEW.id, 'grading-review') RETURNING id into rubric_id;
  INSERT INTO rubrics (name, class_id, assignment_id, review_round) VALUES ('Self-Review Rubric', NEW.class_id, NEW.id, 'self-review') RETURNING id into self_rubric_id;
  UPDATE assignments set grading_rubric_id=rubric_id WHERE id=NEW.id;
  UPDATE assignments set self_review_rubric_id=self_rubric_id WHERE id=NEW.id;
  RETURN NULL;
end;$function$
;

create table "public"."submission_regrade_requests" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "submission_id" bigint not null,
    "class_id" bigint not null,
    "assignment_id" bigint not null,
    "opened_at" timestamp with time zone,
    "created_by" uuid not null,
    "assignee" uuid not null,
    "closed_by" uuid,
    "closed_at" timestamp with time zone,
    "status" regrade_status not null,
    "resolved_by" uuid,
    "resolved_at" timestamp with time zone,
    "escalated_by" uuid,
    "escalated_at" timestamp with time zone,
    "submission_file_comment_id" bigint,
    "submission_comment_id" bigint,
    "submission_artifact_comment_id" bigint,
    "last_commented_at" timestamp with time zone,
    "last_commented_by" uuid,
    "initial_points" integer,
    "resolved_points" integer,
    "closed_points" integer,
    "last_updated_at" timestamp with time zone not null default now()
);


alter table "public"."submission_regrade_requests" enable row level security;

alter table "public"."submission_comments" add column "regrade_request_id" bigint;

alter table "public"."submission_file_comments" add column "regrade_request_id" bigint;

alter table "public"."submission_artifact_comments" add column "regrade_request_id" bigint;

CREATE UNIQUE INDEX submission_regrade_requests_pkey ON public.submission_regrade_requests USING btree (id);

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_pkey" PRIMARY KEY using index "submission_regrade_requests_pkey";

alter table "public"."submission_artifact_comments" add constraint "submission_artifact_comments_regrade_request_id_fkey" FOREIGN KEY (regrade_request_id) REFERENCES submission_regrade_requests(id) not valid;

alter table "public"."submission_artifact_comments" validate constraint "submission_artifact_comments_regrade_request_id_fkey";

alter table "public"."submission_comments" add constraint "submission_comments_regrade_request_id_fkey" FOREIGN KEY (regrade_request_id) REFERENCES submission_regrade_requests(id) not valid;

alter table "public"."submission_comments" validate constraint "submission_comments_regrade_request_id_fkey";

alter table "public"."submission_file_comments" add constraint "submission_file_comments_regrade_request_id_fkey" FOREIGN KEY (regrade_request_id) REFERENCES submission_regrade_requests(id) not valid;

alter table "public"."submission_file_comments" validate constraint "submission_file_comments_regrade_request_id_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) not valid;

alter table "public"."submission_regrade_requests" validate constraint "submission_regrade_requests_class_id_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES assignments(id) not valid;

alter table "public"."submission_regrade_requests" validate constraint "submission_regrade_requests_assignment_id_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_closed_by_fkey" FOREIGN KEY (closed_by) REFERENCES profiles(id) not valid;

alter table "public"."submission_regrade_requests" validate constraint "submission_regrade_requests_closed_by_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_submission_id_fkey" FOREIGN KEY (submission_id) REFERENCES submissions(id) not valid;

alter table "public"."submission_regrade_requests" validate constraint "submission_regrade_requests_submission_id_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_submitted_by_fkey" FOREIGN KEY (created_by) REFERENCES profiles(id) not valid;

alter table "public"."submission_regrade_requests" validate constraint "submission_regrade_requests_submitted_by_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_assignee_fkey" FOREIGN KEY (assignee) REFERENCES profiles(id) not valid;

alter table "public"."submission_regrade_requests" validate constraint "submission_regrade_requests_assignee_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_last_commented_by_fkey" FOREIGN KEY (last_commented_by) REFERENCES profiles(id) not valid;

alter table "public"."submission_regrade_requests" validate constraint "submission_regrade_requests_last_commented_by_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_submission_file_comment_id_fkey" FOREIGN KEY (submission_file_comment_id) REFERENCES submission_file_comments(id) not valid;

alter table "public"."submission_regrade_requests" validate constraint "submission_regrade_requests_submission_file_comment_id_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_submission_comment_id_fkey" FOREIGN KEY (submission_comment_id) REFERENCES submission_comments(id) not valid;

alter table "public"."submission_regrade_requests" validate constraint "submission_regrade_requests_submission_comment_id_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_submission_artifact_comment_id_fkey" FOREIGN KEY (submission_artifact_comment_id) REFERENCES submission_artifact_comments(id) not valid;

alter table "public"."submission_regrade_requests" validate constraint "submission_regrade_requests_submission_artifact_comment_id_fkey";

alter table "public"."submission_regrade_requests" add constraint "submission_regrade_requests_exactly_one_comment_check" CHECK (
    (submission_file_comment_id IS NOT NULL)::int + 
    (submission_comment_id IS NOT NULL)::int + 
    (submission_artifact_comment_id IS NOT NULL)::int = 1
);

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_regrade_request(
    private_profile_id uuid,
    submission_file_comment_id bigint DEFAULT NULL,
    submission_comment_id bigint DEFAULT NULL,
    submission_artifact_comment_id bigint DEFAULT NULL
)
RETURNS bigint
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
declare
    comment_submission_id bigint;
    comment_submission_review_id bigint;
    comment_class_id bigint;
    comment_assignment_id bigint;
    comment_author_id uuid;
    comment_points integer;
    param_count int;
    new_regrade_request_id bigint;
    grading_rubric_id bigint;
begin
    -- Count how many non-null parameters were provided
    param_count := 0;
    if submission_file_comment_id is not null then
        param_count := param_count + 1;
    end if;
    if submission_comment_id is not null then
        param_count := param_count + 1;
    end if;
    if submission_artifact_comment_id is not null then
        param_count := param_count + 1;
    end if;
    
    -- Exactly one parameter must be provided
    if param_count != 1 then
        raise exception 'Exactly one comment ID must be provided';
    end if;
    
    -- Get submission info based on which comment type was provided
    if submission_file_comment_id is not null then
        select sfc.submission_id, sfc.submission_review_id, sfc.class_id, sfc.author, s.assignment_id, sfc.points
        into comment_submission_id, comment_submission_review_id, comment_class_id, comment_author_id, comment_assignment_id, comment_points
        from public.submission_file_comments sfc
        inner join public.submissions s on s.id = sfc.submission_id
        where sfc.id = submission_file_comment_id;
        
        if not found then
            raise exception 'Submission file comment not found';
        end if;
    elsif submission_comment_id is not null then
        select sc.submission_id, sc.submission_review_id, sc.class_id, sc.author, s.assignment_id, sc.points
        into comment_submission_id, comment_submission_review_id, comment_class_id, comment_author_id, comment_assignment_id, comment_points
        from public.submission_comments sc
        inner join public.submissions s on s.id = sc.submission_id
        where sc.id = submission_comment_id;
        
        if not found then
            raise exception 'Submission comment not found';
        end if;
    elsif submission_artifact_comment_id is not null then
        select sac.submission_id, sac.submission_review_id, sac.class_id, sac.author, s.assignment_id, sac.points
        into comment_submission_id, comment_submission_review_id, comment_class_id, comment_author_id, comment_assignment_id, comment_points
        from public.submission_artifact_comments sac
        inner join public.submissions s on s.id = sac.submission_id
        where sac.id = submission_artifact_comment_id;
        
        if not found then
            raise exception 'Submission artifact comment not found';
        end if;
    end if;
    
    -- Check authorization for the submission
    if not public.authorize_for_submission(comment_submission_id) then
        raise exception 'Unauthorized access to submission';
    end if;

    if not public.authorizeforprofile(private_profile_id) then
        raise exception 'Unauthorized access to profile';
    end if;
    
    -- Create the regrade request
    insert into public.submission_regrade_requests (
        submission_id,
        class_id,
        assignment_id,
        created_by,
        assignee,
        status,
        submission_file_comment_id,
        submission_comment_id,
        submission_artifact_comment_id,
        initial_points
    ) values (
        comment_submission_id,
        comment_class_id,
        comment_assignment_id,
        private_profile_id,
        comment_author_id,
        'draft',
        submission_file_comment_id,
        submission_comment_id,
        submission_artifact_comment_id,
        comment_points
    ) returning id into new_regrade_request_id;
    
    -- Update the comment with the regrade request ID
    if submission_file_comment_id is not null then
        update public.submission_file_comments
        set regrade_request_id = new_regrade_request_id
        where id = submission_file_comment_id;
    elsif submission_comment_id is not null then
        update public.submission_comments
        set regrade_request_id = new_regrade_request_id
        where id = submission_comment_id;
    elsif submission_artifact_comment_id is not null then
        update public.submission_artifact_comments
        set regrade_request_id = new_regrade_request_id
        where id = submission_artifact_comment_id;
    end if;
    
    return new_regrade_request_id;
end;
$function$;

CREATE OR REPLACE FUNCTION public.update_regrade_request_status(
    regrade_request_id bigint,
    new_status regrade_status,
    profile_id uuid,
    resolved_points integer DEFAULT NULL,
    closed_points integer DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
declare
    current_request record;
    param_resolved_points integer;
    param_closed_points integer;
begin
    param_resolved_points := resolved_points;
    param_closed_points := closed_points;
    
    -- Get the current regrade request
    select *
    into current_request
    from public.submission_regrade_requests
    where id = regrade_request_id;
    
    if not found then
        raise exception 'Regrade request not found';
    end if;
    
    -- Validate resolved_points parameter for resolved status
    if new_status = 'resolved' and resolved_points is null then
        raise exception 'resolved_points parameter is required when status is resolved';
    end if;
    
    -- Validate closed_points parameter for closed status
    if new_status = 'closed' and closed_points is null then
        raise exception 'closed_points parameter is required when status is closed';
    end if;
    
    -- Validate state transitions and permissions
    case new_status
        when 'opened' then
            -- Can only open from draft, and only by submission owner
            if current_request.status != 'draft' then
                raise exception 'Can only open regrade requests that are in draft status';
            end if;
            if not authorizeforprofile(profile_id) then
                raise exception 'Only submission owners can open regrade requests';
            end if;
            
            -- Update with opened timestamp
            update public.submission_regrade_requests
            set status = new_status,
                opened_at = now(),
                last_updated_at = now()
            where id = regrade_request_id;
            
            -- Notify the author of the comment that triggered this regrade request
            insert into public.notifications (class_id, subject, body, style, user_id)
            select 
                current_request.class_id,
                '{}'::jsonb as subject,
                jsonb_build_object(
                    'type', 'regrade_request',
                    'action', 'comment_challenged',
                    'regrade_request_id', regrade_request_id,
                    'submission_id', current_request.submission_id,
                    'opened_by', profile_id
                ) as body,
                'info' as style,
                ur.user_id
            from public.user_roles ur
            where ur.class_id = current_request.class_id
              and ur.private_profile_id = (
                -- Get comment author based on which type of comment this regrade request refers to
                case 
                    when current_request.submission_file_comment_id is not null then
                        (select author from public.submission_file_comments where id = current_request.submission_file_comment_id)
                    when current_request.submission_comment_id is not null then
                        (select author from public.submission_comments where id = current_request.submission_comment_id)
                    when current_request.submission_artifact_comment_id is not null then
                        (select author from public.submission_artifact_comments where id = current_request.submission_artifact_comment_id)
                end
              );
            
        when 'resolved' then
            -- Can only resolve from opened, and only by class graders
            if current_request.status != 'opened' then
                raise exception 'Can only resolve regrade requests that are opened';
            end if;
            if not authorizeforprofile(profile_id) then
                raise exception 'Unauthorized to act as this profile';
            end if;
            if not authorizeforclassgrader(current_request.class_id) then
                raise exception 'Only graders can resolve regrade requests';
            end if;
            
            -- Update with resolved info
            update public.submission_regrade_requests
            set status = new_status,
                resolved_by = profile_id,
                resolved_at = now(),
                resolved_points = param_resolved_points,
                last_updated_at = now()
            where id = regrade_request_id;
            
            -- Update the original comment's points
            if current_request.submission_file_comment_id is not null then
                update public.submission_file_comments
                set points = param_resolved_points
                where id = current_request.submission_file_comment_id;
            elsif current_request.submission_comment_id is not null then
                update public.submission_comments
                set points = param_resolved_points
                where id = current_request.submission_comment_id;
            elsif current_request.submission_artifact_comment_id is not null then
                update public.submission_artifact_comments
                set points = param_resolved_points
                where id = current_request.submission_artifact_comment_id;
            end if;
            
        when 'escalated' then
            -- Can only escalate from resolved, and only by submission owner
            if current_request.status != 'resolved' then
                raise exception 'Can only escalate regrade requests that are resolved';
            end if;
            if not authorizeforprofile(profile_id) then
                raise exception 'Only submission owners can escalate regrade requests';
            end if;
            
            -- Update with escalated info
            update public.submission_regrade_requests
            set status = new_status,
                escalated_by = profile_id,
                escalated_at = now(),
                last_updated_at = now()
            where id = regrade_request_id;
            
        when 'closed' then
            -- Can close from resolved, escalated, or opened, but only by class instructors
            if current_request.status not in ('resolved', 'escalated', 'opened') then
                raise exception 'Can only close regrade requests that are resolved, escalated, or opened';
            end if;
            if not public.authorizeforprofile(profile_id) then
                raise exception 'Unauthorized to act as this profile';
            end if;
            if not public.authorizeforclassinstructor(current_request.class_id) then
                raise exception 'Only instructors can close regrade requests';
            end if;
            
            -- Update with closed info
            update public.submission_regrade_requests
            set status = new_status,
                closed_by = profile_id,
                closed_at = now(),
                closed_points = param_closed_points,
                last_updated_at = now()
            where id = regrade_request_id;
            
            -- Update the original comment's points
            if current_request.submission_file_comment_id is not null then
                update public.submission_file_comments
                set points = param_closed_points
                where id = current_request.submission_file_comment_id;
            elsif current_request.submission_comment_id is not null then
                update public.submission_comments
                set points = param_closed_points
                where id = current_request.submission_comment_id;
            elsif current_request.submission_artifact_comment_id is not null then
                update public.submission_artifact_comments
                set points = param_closed_points
                where id = current_request.submission_artifact_comment_id;
            end if;
            
        when 'draft' then
            raise exception 'Cannot transition back to draft status';
            
        else
            raise exception 'Invalid status: %', new_status;
    end case;
    
    -- Send notifications to all students connected to the submission
    insert into public.notifications (class_id, subject, body, style, user_id)
    select 
        current_request.class_id,
        '{}'::jsonb as subject,
        jsonb_build_object(
            'type', 'regrade_request',
            'action', 'status_change',
            'regrade_request_id', regrade_request_id,
            'old_status', current_request.status,
            'new_status', new_status,
            'submission_id', current_request.submission_id,
            'updated_by', profile_id
        ) as body,
        'info' as style,
        ur.user_id
    from public.user_roles ur
    where ur.class_id = current_request.class_id
      and ur.role = 'student'
      and ur.private_profile_id != profile_id
      and ur.private_profile_id in (
        -- Get submission owner profile
        select s.profile_id 
        from public.submissions s 
        where s.id = current_request.submission_id
        
        union
        
        -- Get all group members if submission belongs to a group
        select agm.profile_id
        from public.submissions s
        inner join public.assignment_groups_members agm 
            on agm.assignment_group_id = s.assignment_group_id
        where s.id = current_request.submission_id
          and s.assignment_group_id is not null
      );
    
    -- If status is escalated, also notify all instructors
    if new_status = 'escalated' then
        insert into public.notifications (class_id, subject, body, style, user_id)
        select 
            current_request.class_id,
            '{}'::jsonb as subject,
            jsonb_build_object(
                'type', 'regrade_request',
                'action', 'escalated',
                'regrade_request_id', regrade_request_id,
                'old_status', current_request.status,
                'new_status', new_status,
                'submission_id', current_request.submission_id,
                'escalated_by', profile_id
            ) as body,
            'warning' as style,
            ur.user_id
        from public.user_roles ur
        where ur.class_id = current_request.class_id
          and ur.role = 'instructor';
    end if;
    
    return true;
end;
$function$;

CREATE OR REPLACE FUNCTION public.update_regrade_request_last_comment()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
begin
    -- Update the regrade request with last comment info
    update public.submission_regrade_requests
    set last_commented_at = NEW.created_at,
        last_commented_by = NEW.author
    where id = NEW.submission_regrade_request_id;
    
    return NEW;
end;
$function$;

CREATE OR REPLACE FUNCTION public.notify_regrade_request_participants()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO ''
AS $function$
declare
    regrade_request_record record;
begin
    -- Get the regrade request details
    select *
    into regrade_request_record
    from public.submission_regrade_requests
    where id = NEW.submission_regrade_request_id;
    
    -- If no regrade request found, exit early (shouldn't happen due to FK constraint)
    if not found then
        return NEW;
    end if;
    
    -- Notify all participants except the comment author
    insert into public.notifications (class_id, subject, body, style, user_id)
    select distinct
        NEW.class_id,
        '{}'::jsonb as subject,
        jsonb_build_object(
            'type', 'regrade_request',
            'action', 'new_comment',
            'regrade_request_id', regrade_request_record.id,
            'submission_id', regrade_request_record.submission_id,
            'comment_author', NEW.author,
            'comment_id', NEW.id
        ) as body,
        'info' as style,
        ur.user_id
    from public.user_roles ur
    where ur.class_id = NEW.class_id
      and ur.private_profile_id in (
        -- Get assignee of the regrade request
        select regrade_request_record.assignee
        
        union
        
        -- Get submission owner profile
        select s.profile_id 
        from public.submissions s 
        where s.id = regrade_request_record.submission_id
        
        union
        
        -- Get all group members if submission belongs to a group
        select agm.profile_id
        from public.submissions s
        inner join public.assignment_groups_members agm 
            on agm.assignment_group_id = s.assignment_group_id
        where s.id = regrade_request_record.submission_id
          and s.assignment_group_id is not null
        
        union
        
        -- Get all previous comment authors from this regrade request
        select author from public.submission_regrade_request_comments 
        where submission_regrade_request_id = NEW.submission_regrade_request_id
      )
      and ur.private_profile_id != NEW.author; -- Exclude the new comment author
    
    return NEW;
end;
$function$;

-- Performance indices for regrade request queries

-- Index for finding comments by submission review (used in trigger to find all participants)
CREATE INDEX submission_comments_submission_review_id_idx 
    ON public.submission_comments (submission_review_id);

CREATE INDEX submission_file_comments_submission_review_id_idx 
    ON public.submission_file_comments (submission_review_id);

CREATE INDEX submission_artifact_comments_submission_review_id_idx 
    ON public.submission_artifact_comments (submission_review_id);

-- Index for finding comments by regrade request (for future queries)
CREATE INDEX submission_comments_regrade_request_id_idx 
    ON public.submission_comments (regrade_request_id);

CREATE INDEX submission_file_comments_regrade_request_id_idx 
    ON public.submission_file_comments (regrade_request_id);

CREATE INDEX submission_artifact_comments_regrade_request_id_idx 
    ON public.submission_artifact_comments (regrade_request_id);

-- Composite index for user_roles lookups by class and role (used in status transitions)
CREATE INDEX user_roles_class_id_role_idx 
    ON public.user_roles (class_id, role);

-- Composite index for user_roles lookups by class and private_profile (used in notifications)
CREATE INDEX user_roles_class_id_private_profile_id_idx 
    ON public.user_roles (class_id, private_profile_id);

-- Index for assignment_groups_members by assignment_group_id (used in participant lookups)
CREATE INDEX assignment_groups_members_assignment_group_id_idx 
    ON public.assignment_groups_members (assignment_group_id);

-- Composite index for submission_reviews lookups by submission and rubric (used in CreateRegradeRequest)
CREATE INDEX submission_reviews_submission_id_rubric_id_idx 
    ON public.submission_reviews (submission_id, rubric_id);

-- Index for submissions by assignment_group_id (used in participant lookups)
CREATE INDEX submissions_assignment_group_id_idx 
    ON public.submissions (assignment_group_id) 
    WHERE assignment_group_id IS NOT NULL;

-- Index for regrade requests by assignment_id (for assignment-level regrade management)
CREATE INDEX submission_regrade_requests_assignment_id_idx 
    ON public.submission_regrade_requests (assignment_id);

CREATE OR REPLACE FUNCTION public.authorize_for_submission_regrade_comment(submission_regrade_request_id bigint)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
declare
    request_record record;
begin
    -- Get the regrade request details
    select srr.status, srr.submission_id
    into request_record
    from public.submission_regrade_requests srr
    where srr.id = submission_regrade_request_id;
    
    -- If regrade request not found, deny access
    if not found then
        return false;
    end if;
    
    -- If regrade request is closed, deny access
    if request_record.status = 'closed' then
        return false;
    end if;
    
    -- Check if user is authorized for the submission
    return public.authorize_for_submission(request_record.submission_id);
end;
$function$;

create table "public"."submission_regrade_request_comments" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "submission_regrade_request_id" bigint not null,
    "submission_id" bigint not null,
    "assignment_id" bigint not null,
    "author" uuid not null,
    "comment" text not null,
    "class_id" bigint not null
);

alter table "public"."submission_regrade_request_comments" enable row level security;

CREATE UNIQUE INDEX submission_regrade_request_comments_pkey ON public.submission_regrade_request_comments USING btree (id);

alter table "public"."submission_regrade_request_comments" add constraint "submission_regrade_request_comments_pkey" PRIMARY KEY using index "submission_regrade_request_comments_pkey";

alter table "public"."submission_regrade_request_comments" add constraint "submission_regrade_request_comments_submission_regrade_request_id_fkey" FOREIGN KEY (submission_regrade_request_id) REFERENCES submission_regrade_requests(id) not valid;

alter table "public"."submission_regrade_request_comments" validate constraint "submission_regrade_request_comments_submission_regrade_request_id_fkey";

alter table "public"."submission_regrade_request_comments" add constraint "submission_regrade_request_comments_author_fkey" FOREIGN KEY (author) REFERENCES profiles(id) not valid;

alter table "public"."submission_regrade_request_comments" validate constraint "submission_regrade_request_comments_author_fkey";

alter table "public"."submission_regrade_request_comments" add constraint "submission_regrade_request_comments_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) not valid;

alter table "public"."submission_regrade_request_comments" validate constraint "submission_regrade_request_comments_class_id_fkey";

alter table "public"."submission_regrade_request_comments" add constraint "submission_regrade_request_comments_submission_id_fkey" FOREIGN KEY (submission_id) REFERENCES submissions(id) not valid;

alter table "public"."submission_regrade_request_comments" validate constraint "submission_regrade_request_comments_submission_id_fkey";

alter table "public"."submission_regrade_request_comments" add constraint "submission_regrade_request_comments_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES assignments(id) not valid;

alter table "public"."submission_regrade_request_comments" validate constraint "submission_regrade_request_comments_assignment_id_fkey";

create policy "allow_create_if_authorized_for_submission_regrade_comment"
on "public"."submission_regrade_request_comments"
as permissive
for insert
to public
with check (authorizeforclassgrader(class_id) or authorize_for_submission_regrade_comment(submission_regrade_request_id));

create policy "allow_read_if_authorized_for_submission"
on "public"."submission_regrade_request_comments"
as permissive
for select
to public
using (
    authorizeforclassgrader(class_id)
    or authorize_for_submission(submission_id));

-- Index for performance on regrade request lookups
CREATE INDEX submission_regrade_request_comments_submission_regrade_request_id_idx 
    ON public.submission_regrade_request_comments (submission_regrade_request_id);

-- Index for performance on class lookups
CREATE INDEX submission_regrade_request_comments_class_id_idx 
    ON public.submission_regrade_request_comments (class_id);

-- Index for performance on submission lookups
CREATE INDEX submission_regrade_request_comments_submission_id_idx 
    ON public.submission_regrade_request_comments (submission_id);

-- Index for performance on assignment lookups
CREATE INDEX submission_regrade_request_comments_assignment_id_idx 
    ON public.submission_regrade_request_comments (assignment_id);


-- Create trigger for regrade request comments
CREATE TRIGGER notify_regrade_participants_on_regrade_comment 
    AFTER INSERT ON public.submission_regrade_request_comments 
    FOR EACH ROW EXECUTE FUNCTION notify_regrade_request_participants();

-- Create trigger to update last comment info on regrade requests
CREATE TRIGGER update_last_comment_on_regrade_comment 
    AFTER INSERT ON public.submission_regrade_request_comments 
    FOR EACH ROW EXECUTE FUNCTION update_regrade_request_last_comment();


drop policy "authorizeforclass" on "public"."rubric_checks";

create policy "instructors and graders see all"
on "public"."rubric_checks"
as permissive
for select
to public
using (authorizeforclassgrader(class_id));

create policy "students see only based on visibility"
on "public"."rubric_checks"
as permissive
for select
to public
using (
    EXISTS (
        SELECT 1
        FROM rubric_criteria rc
        JOIN rubrics r ON (rc.rubric_id = r.id)
        WHERE rc.id = rubric_checks.rubric_criteria_id 
          AND authorizeforclass(r.class_id)
          -- Students can see rubric checks only if rubric is not private
          -- and based on the student_visibility setting
          AND r.is_private = false 
          AND (
              -- ALWAYS: Students can always see these rubric checks
              rubric_checks.student_visibility = 'always'::rubric_check_student_visibility
              
              OR
              
              -- IF_RELEASED: Students can see if their submission review is released
              (
                  rubric_checks.student_visibility = 'if_released'::rubric_check_student_visibility
                  AND EXISTS (
                      SELECT 1
                      FROM submissions s
                      JOIN submission_reviews sr ON (s.id = sr.submission_id)
                      WHERE s.assignment_id = r.assignment_id
                        AND sr.released = true
                        AND authorize_for_submission(s.id)
                  )
              )
              
              OR
              
              -- IF_APPLIED: Students can see if this rubric check has been applied to their submission
              (
                  rubric_checks.student_visibility = 'if_applied'::rubric_check_student_visibility
                  AND (
                      -- Check if rubric check is applied via submission_comments
                      EXISTS (
                          SELECT 1
                          FROM submission_comments sc
                          JOIN submissions s ON (sc.submission_id = s.id)
                          WHERE sc.rubric_check_id = rubric_checks.id
                            AND sc.released = true
                            AND authorize_for_submission(s.id)
                      )
                      
                      OR

                      -- Check if rubric check is applied via submission_file_comments
                      EXISTS (
                          SELECT 1
                          FROM submission_file_comments sfc
                          JOIN submissions s ON (sfc.submission_id = s.id)
                          WHERE sfc.rubric_check_id = rubric_checks.id
                            AND sfc.released = true
                            AND authorize_for_submission(s.id)
                      )

                      OR
                      
                      -- Check if rubric check is applied via submission_artifact_comments
                      EXISTS (
                          SELECT 1
                          FROM submission_artifact_comments sac
                          JOIN submissions s ON (sac.submission_id = s.id)
                          JOIN submission_reviews sr ON (s.id = sr.submission_id)
                          WHERE sac.rubric_check_id = rubric_checks.id
                            AND sr.released = true
                            AND authorize_for_submission(s.id)
                      )
                  )
              )
          )
    )
);

create policy "graders all, students own"
on "public"."submission_regrade_requests"
as permissive
for select
to public
using ((authorizeforclassgrader(class_id) OR authorize_for_submission(submission_id)));

-- Assignment overview view with submission and regrade request statistics
CREATE OR REPLACE VIEW "public"."assignment_overview" 
WITH (security_invoker = TRUE) AS
SELECT 
    a.id,
    a.title,
    a.release_date,
    a.due_date,
    a.class_id,
    COALESCE(active_submissions.count, 0) AS active_submissions_count,
    COALESCE(open_regrade_requests.count, 0) AS open_regrade_requests_count
FROM assignments a
LEFT JOIN (
    SELECT 
        assignment_id,
        COUNT(*) as count
    FROM submissions 
    WHERE is_active = true
    GROUP BY assignment_id
) active_submissions ON a.id = active_submissions.assignment_id
LEFT JOIN (
    SELECT 
        assignment_id,
        COUNT(*) as count
    FROM submission_regrade_requests
    WHERE status IN ('opened', 'escalated')
    GROUP BY assignment_id
) open_regrade_requests ON a.id = open_regrade_requests.assignment_id;

-- Create unified broadcast function for regrade requests (class-level)
CREATE OR REPLACE FUNCTION broadcast_regrade_request_data_change()
RETURNS TRIGGER AS $$
DECLARE
    class_id BIGINT;
    assignee_profile_id UUID;
    profile_id UUID;
    affected_profile_ids UUID[];
    staff_payload JSONB;
    user_payload JSONB;
BEGIN
    -- Get the class_id and assignee_profile_id
    IF TG_OP = 'INSERT' THEN
        class_id := NEW.class_id;
        assignee_profile_id := NEW.assignee;
    ELSIF TG_OP = 'UPDATE' THEN
        class_id := COALESCE(NEW.class_id, OLD.class_id);
        assignee_profile_id := COALESCE(NEW.assignee, OLD.assignee);
    ELSIF TG_OP = 'DELETE' THEN
        class_id := OLD.class_id;
        assignee_profile_id := OLD.assignee;
    END IF;

    IF class_id IS NOT NULL THEN
        -- Create payload with multiplexing information
        staff_payload := jsonb_build_object(
            'type', 'table_change',
            'operation', TG_OP,
            'table', TG_TABLE_NAME,
            'data', CASE 
                WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD)
                ELSE to_jsonb(NEW)
            END,
            'class_id', class_id,
            'timestamp', NOW()
        );

        -- Broadcast to staff channel
        PERFORM realtime.send(
            staff_payload,
            'broadcast',
            'class:' || class_id || ':staff',
            true
        );

        -- Also broadcast to the submission owner's channel and all group members
        IF TG_OP = 'INSERT' THEN
            -- Get all affected profile IDs (submission owner + group members)
            SELECT ARRAY(
                SELECT DISTINCT COALESCE(s.profile_id, agm.profile_id)
                FROM submissions s
                LEFT JOIN assignment_groups ag ON s.assignment_group_id = ag.id
                LEFT JOIN assignment_groups_members agm ON ag.id = agm.assignment_group_id
                WHERE s.id = NEW.submission_id
            ) INTO affected_profile_ids;
            
            -- Broadcast to all affected users
            IF array_length(affected_profile_ids, 1) > 0 THEN
                user_payload := staff_payload || jsonb_build_object('target_audience', 'user');
                -- Send to each affected user
                FOREACH profile_id IN ARRAY affected_profile_ids
                LOOP
                    IF profile_id IS NOT NULL THEN
                        PERFORM realtime.send(
                            user_payload,
                            'broadcast',
                            'class:' || class_id || ':user:' || profile_id,
                            true
                        );
                    END IF;
                END LOOP;
            END IF;
        ELSIF TG_OP = 'UPDATE' THEN
            -- For updates, check both old and new submission owners and group members
            DECLARE
                old_affected_profile_ids UUID[];
                new_affected_profile_ids UUID[];
            BEGIN
                -- Get old affected profile IDs (submission owner + group members)
                SELECT ARRAY(
                    SELECT DISTINCT COALESCE(s.profile_id, agm.profile_id)
                    FROM submissions s
                    LEFT JOIN assignment_groups ag ON s.assignment_group_id = ag.id
                    LEFT JOIN assignment_groups_members agm ON ag.id = agm.assignment_group_id
                    WHERE s.id = OLD.submission_id
                ) INTO old_affected_profile_ids;
                
                -- Get new affected profile IDs (submission owner + group members)
                SELECT ARRAY(
                    SELECT DISTINCT COALESCE(s.profile_id, agm.profile_id)
                    FROM submissions s
                    LEFT JOIN assignment_groups ag ON s.assignment_group_id = ag.id
                    LEFT JOIN assignment_groups_members agm ON ag.id = agm.assignment_group_id
                    WHERE s.id = NEW.submission_id
                ) INTO new_affected_profile_ids;
                
                -- Broadcast to old affected users if submission_id changed
                IF OLD.submission_id != NEW.submission_id AND array_length(old_affected_profile_ids, 1) > 0 THEN
                    user_payload := staff_payload || jsonb_build_object('target_audience', 'user');
                    FOREACH profile_id IN ARRAY old_affected_profile_ids
                    LOOP
                        IF profile_id IS NOT NULL THEN
                            PERFORM realtime.send(
                                user_payload,
                                'broadcast',
                                'class:' || class_id || ':user:' || profile_id,
                                true
                            );
                        END IF;
                    END LOOP;
                END IF;
                
                -- Broadcast to new affected users
                IF array_length(new_affected_profile_ids, 1) > 0 THEN
                    user_payload := staff_payload || jsonb_build_object('target_audience', 'user');
                    FOREACH profile_id IN ARRAY new_affected_profile_ids
                    LOOP
                        IF profile_id IS NOT NULL THEN
                            PERFORM realtime.send(
                                user_payload,
                                'broadcast',
                                'class:' || class_id || ':user:' || profile_id,
                                true
                            );
                        END IF;
                    END LOOP;
                END IF;
            END;
        ELSIF TG_OP = 'DELETE' THEN
            -- For deletes, broadcast to the submission owner and all group members
            SELECT ARRAY(
                SELECT DISTINCT COALESCE(s.profile_id, agm.profile_id)
                FROM submissions s
                LEFT JOIN assignment_groups ag ON s.assignment_group_id = ag.id
                LEFT JOIN assignment_groups_members agm ON ag.id = agm.assignment_group_id
                WHERE s.id = OLD.submission_id
            ) INTO affected_profile_ids;
            
            -- Broadcast to all affected users
            IF array_length(affected_profile_ids, 1) > 0 THEN
                user_payload := staff_payload || jsonb_build_object('target_audience', 'user');
                FOREACH profile_id IN ARRAY affected_profile_ids
                LOOP
                    IF profile_id IS NOT NULL THEN
                        PERFORM realtime.send(
                            user_payload,
                            'broadcast',
                            'class:' || class_id || ':user:' || profile_id,
                            true
                        );
                    END IF;
                END LOOP;
            END IF;
        END IF;
    END IF;

    -- Return the appropriate record
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for regrade requests
CREATE OR REPLACE TRIGGER broadcast_regrade_requests_unified
    AFTER INSERT OR UPDATE OR DELETE ON "public"."submission_regrade_requests"
    FOR EACH ROW
    EXECUTE FUNCTION broadcast_regrade_request_data_change();

-- Create trigger for regrade request comments
CREATE OR REPLACE TRIGGER broadcast_regrade_comments_unified
    AFTER INSERT OR UPDATE OR DELETE ON "public"."submission_regrade_request_comments"
    FOR EACH ROW
    EXECUTE FUNCTION broadcast_submission_data_change();

-- Add comments for documentation
COMMENT ON FUNCTION broadcast_regrade_request_data_change() IS 
'Broadcasts changes to submission_regrade_requests table using unified channel system. Messages are sent to both staff channel and assignee/user channels. Regrade requests are class-level events.';
