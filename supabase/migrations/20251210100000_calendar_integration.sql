-- Calendar Integration Migration
-- Adds ICS calendar support for office hours and events scheduling

-- 1. Add ICS URL columns to classes table
ALTER TABLE public.classes ADD COLUMN IF NOT EXISTS office_hours_ics_url text;
ALTER TABLE public.classes ADD COLUMN IF NOT EXISTS events_ics_url text;

COMMENT ON COLUMN public.classes.office_hours_ics_url IS 'URL to ICS file for office hours schedule';
COMMENT ON COLUMN public.classes.events_ics_url IS 'URL to ICS file for other events (staff meetings, etc.)';

-- 2. Extend discord_channel_type enum with new channel types
ALTER TYPE public.discord_channel_type ADD VALUE IF NOT EXISTS 'scheduling';
ALTER TYPE public.discord_channel_type ADD VALUE IF NOT EXISTS 'operations';

-- 3. Create calendar_events table
CREATE TABLE IF NOT EXISTS public.calendar_events (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  class_id bigint NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
  calendar_type text NOT NULL CHECK (calendar_type IN ('office_hours', 'events')),
  uid text NOT NULL, -- ICS event UID
  title text NOT NULL,
  description text,
  start_time timestamptz NOT NULL,
  end_time timestamptz NOT NULL,
  location text,
  queue_name text, -- Extracted queue name from title format "Name (Queue)"
  organizer_name text, -- Person name extracted from title
  raw_ics_data jsonb,
  -- Announcement tracking (NULL = not yet announced)
  start_announced_at timestamptz, -- When we announced the start
  end_announced_at timestamptz,   -- When we announced the end
  change_announced_at timestamptz, -- When we announced add/change to #scheduling
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  UNIQUE(class_id, calendar_type, uid)
);

-- Add indexes for common queries
CREATE INDEX IF NOT EXISTS idx_calendar_events_class_type ON public.calendar_events(class_id, calendar_type);
CREATE INDEX IF NOT EXISTS idx_calendar_events_start_time ON public.calendar_events(start_time);
CREATE INDEX IF NOT EXISTS idx_calendar_events_end_time ON public.calendar_events(end_time);
CREATE INDEX IF NOT EXISTS idx_calendar_events_unannounced_start ON public.calendar_events(class_id, start_time) WHERE start_announced_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_calendar_events_unannounced_end ON public.calendar_events(class_id, end_time) WHERE end_announced_at IS NULL;

COMMENT ON TABLE public.calendar_events IS 'Stores parsed calendar events from ICS feeds for office hours and other events';

-- 4. Create calendar_sync_state table
CREATE TABLE IF NOT EXISTS public.calendar_sync_state (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  class_id bigint NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
  calendar_type text NOT NULL CHECK (calendar_type IN ('office_hours', 'events')),
  last_sync_at timestamptz,
  last_etag text,
  last_hash text, -- Hash of content for change detection
  sync_error text,
  created_at timestamptz DEFAULT now() NOT NULL,
  UNIQUE(class_id, calendar_type)
);

CREATE INDEX IF NOT EXISTS idx_calendar_sync_state_class ON public.calendar_sync_state(class_id);

COMMENT ON TABLE public.calendar_sync_state IS 'Tracks sync state for calendar ICS feeds to enable efficient polling';

-- 5. Create class_staff_settings table (for staff-only settings like edit URLs)
CREATE TABLE IF NOT EXISTS public.class_staff_settings (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  class_id bigint NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
  setting_key text NOT NULL,
  setting_value text,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  UNIQUE(class_id, setting_key)
);

CREATE INDEX IF NOT EXISTS idx_class_staff_settings_class ON public.class_staff_settings(class_id);
CREATE INDEX IF NOT EXISTS idx_class_staff_settings_key ON public.class_staff_settings(class_id, setting_key);

COMMENT ON TABLE public.class_staff_settings IS 'Staff-only settings for classes (e.g., calendar edit URLs)';

-- 6. Enable RLS on new tables
ALTER TABLE public.calendar_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.calendar_sync_state ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.class_staff_settings ENABLE ROW LEVEL SECURITY;

-- 7. RLS Policies for calendar_events
-- Students can read office_hours events for their enrolled classes
DROP POLICY IF EXISTS calendar_events_student_select ON public.calendar_events;
CREATE POLICY calendar_events_student_select ON public.calendar_events
  FOR SELECT TO authenticated
  USING (
    calendar_type = 'office_hours'
    AND EXISTS (
      SELECT 1 FROM public.user_roles ur
      WHERE ur.class_id = calendar_events.class_id
        AND ur.user_id = auth.uid()
        AND ur.disabled = false
    )
  );

-- Staff can read all calendar_events for their classes
DROP POLICY IF EXISTS calendar_events_staff_select ON public.calendar_events;
CREATE POLICY calendar_events_staff_select ON public.calendar_events
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles ur
      WHERE ur.class_id = calendar_events.class_id
        AND ur.user_id = auth.uid()
        AND ur.role IN ('instructor', 'grader')
    )
  );

-- Service role can do everything
DROP POLICY IF EXISTS calendar_events_service_role_all ON public.calendar_events;
CREATE POLICY calendar_events_service_role_all ON public.calendar_events
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

-- 8. RLS Policies for calendar_sync_state (service role only)
DROP POLICY IF EXISTS calendar_sync_state_service_role_all ON public.calendar_sync_state;
CREATE POLICY calendar_sync_state_service_role_all ON public.calendar_sync_state
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

-- Staff can view sync state for debugging
DROP POLICY IF EXISTS calendar_sync_state_staff_select ON public.calendar_sync_state;
CREATE POLICY calendar_sync_state_staff_select ON public.calendar_sync_state
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles ur
      WHERE ur.class_id = calendar_sync_state.class_id
        AND ur.user_id = auth.uid()
        AND ur.role IN ('instructor', 'grader')
    )
  );

-- 9. RLS Policies for class_staff_settings
-- Only staff can read
DROP POLICY IF EXISTS class_staff_settings_staff_select ON public.class_staff_settings;
CREATE POLICY class_staff_settings_staff_select ON public.class_staff_settings
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles ur
      WHERE ur.class_id = class_staff_settings.class_id
        AND ur.user_id = auth.uid()
        AND ur.role IN ('instructor', 'grader')
    )
  );

-- Only instructors can insert/update/delete
DROP POLICY IF EXISTS class_staff_settings_instructor_all ON public.class_staff_settings;
CREATE POLICY class_staff_settings_instructor_all ON public.class_staff_settings
  FOR ALL TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles ur
      WHERE ur.class_id = class_staff_settings.class_id
        AND ur.user_id = auth.uid()
        AND ur.role = 'instructor'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.user_roles ur
      WHERE ur.class_id = class_staff_settings.class_id
        AND ur.user_id = auth.uid()
        AND ur.role = 'instructor'
    )
  );

-- Service role can do everything
DROP POLICY IF EXISTS class_staff_settings_service_role_all ON public.class_staff_settings;
CREATE POLICY class_staff_settings_service_role_all ON public.class_staff_settings
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

-- 10. Realtime broadcast trigger for calendar_events
CREATE OR REPLACE FUNCTION public.broadcast_calendar_events_change()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  class_id_value bigint;
  calendar_type_value text;
  payload jsonb;
BEGIN
  IF TG_OP = 'DELETE' THEN
    class_id_value := OLD.class_id;
    calendar_type_value := OLD.calendar_type;
  ELSE
    class_id_value := NEW.class_id;
    calendar_type_value := NEW.calendar_type;
  END IF;

  -- Standard table_change payload format
  payload := jsonb_build_object(
    'type', 'table_change',
    'operation', TG_OP,
    'table', TG_TABLE_NAME,
    'data', CASE WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE to_jsonb(NEW) END,
    'class_id', class_id_value,
    'timestamp', NOW()
  );

  -- office_hours â†’ students channel (+ staff)
  IF calendar_type_value = 'office_hours' THEN
    PERFORM public.safe_broadcast(payload, 'broadcast', format('class:%s:students', class_id_value), true);
  END IF;
  
  -- Always send to staff (they see both calendar types)
  PERFORM public.safe_broadcast(payload, 'broadcast', format('class:%s:staff', class_id_value), true);

  RETURN COALESCE(NEW, OLD);
END;
$$;

DROP TRIGGER IF EXISTS broadcast_calendar_events_realtime ON public.calendar_events;
CREATE TRIGGER broadcast_calendar_events_realtime
  AFTER INSERT OR UPDATE OR DELETE ON public.calendar_events
  FOR EACH ROW EXECUTE FUNCTION public.broadcast_calendar_events_change();

COMMENT ON FUNCTION public.broadcast_calendar_events_change() IS 
'Broadcasts calendar_events changes. Office hours go to students+staff channels, events go to staff only.';

-- 11. Update trigger for updated_at columns
CREATE OR REPLACE FUNCTION public.update_calendar_events_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS update_calendar_events_updated_at ON public.calendar_events;
CREATE TRIGGER update_calendar_events_updated_at
  BEFORE UPDATE ON public.calendar_events
  FOR EACH ROW EXECUTE FUNCTION public.update_calendar_events_updated_at();

CREATE OR REPLACE FUNCTION public.update_class_staff_settings_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS update_class_staff_settings_updated_at ON public.class_staff_settings;
CREATE TRIGGER update_class_staff_settings_updated_at
  BEFORE UPDATE ON public.class_staff_settings
  FOR EACH ROW EXECUTE FUNCTION public.update_class_staff_settings_updated_at();

-- 12. Grant permissions
GRANT SELECT ON public.calendar_events TO authenticated;
GRANT SELECT ON public.calendar_sync_state TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.class_staff_settings TO authenticated;

GRANT ALL ON public.calendar_events TO service_role;
GRANT ALL ON public.calendar_sync_state TO service_role;
GRANT ALL ON public.class_staff_settings TO service_role;

-- 13. Cron job for calendar sync (every 5 minutes)
CREATE OR REPLACE FUNCTION public.invoke_calendar_sync_background_task()
RETURNS void
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = public
AS $$
BEGIN
  PERFORM public.call_edge_function_internal(
    '/functions/v1/calendar-sync',
    'POST',
    '{"Content-type":"application/json","x-supabase-webhook-source":"calendar-sync"}'::jsonb,
    '{}'::jsonb,
    30000,
    null, null, null, null, null
  );
END;
$$;

REVOKE ALL ON FUNCTION public.invoke_calendar_sync_background_task() FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.invoke_calendar_sync_background_task() TO service_role;

-- Idempotent cron schedule: drop if exists, then create
SELECT cron.unschedule('calendar-sync-every-5-minutes')
WHERE EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'calendar-sync-every-5-minutes');

SELECT cron.schedule(
  'calendar-sync-every-5-minutes',
  '*/5 * * * *',
  $$SELECT public.invoke_calendar_sync_background_task();$$
);

COMMENT ON FUNCTION public.invoke_calendar_sync_background_task() IS 
'Invokes the calendar-sync edge function to poll ICS feeds and update calendar_events';

-- 14. Allow instructors to update ICS URLs on classes
-- Update the RLS helper function to allow ICS URL changes
CREATE OR REPLACE FUNCTION public.only_calendar_or_discord_ids_changed(new_row public.classes)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT COALESCE(
    (
      SELECT COALESCE(
        (
          SELECT bool_and(changed.key = ANY(ARRAY[
            'discord_server_id',
            'discord_channel_group_id',
            'office_hours_ics_url',
            'events_ics_url',
            'updated_at'
          ]))
          FROM (
            SELECT t.key
            FROM jsonb_each(to_jsonb(new_row)) AS t(key, value)
            WHERE (to_jsonb(old_row)->t.key) IS DISTINCT FROM t.value
          ) AS changed
        ),
        true  -- no differences -> allow
      )
      FROM public.classes old_row
      WHERE old_row.id = new_row.id
    ),
    false -- no matching row found
  );
$$;

-- Update the existing policy to use the new function
DROP POLICY IF EXISTS classes_instructor_update_discord_ids ON public.classes;
DROP POLICY IF EXISTS classes_instructor_update_calendar_or_discord_ids ON public.classes;
CREATE POLICY classes_instructor_update_calendar_or_discord_ids
  ON public.classes
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles ur
      WHERE ur.class_id = classes.id
        AND ur.user_id = auth.uid()
        AND ur.role = 'instructor'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.user_roles ur
      WHERE ur.class_id = classes.id
        AND ur.user_id = auth.uid()
        AND ur.role = 'instructor'
    )
    AND public.only_calendar_or_discord_ids_changed(classes)
  );

COMMENT ON FUNCTION public.only_calendar_or_discord_ids_changed IS 
'RLS helper: ensures only Discord IDs and calendar ICS URLs can be changed on classes rows by instructors';

-- 15. Update the trigger to also create #scheduling and #operations channels
CREATE OR REPLACE FUNCTION public.trigger_discord_create_roles_on_server_connect()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_roles_exist boolean;
BEGIN
  -- When discord_server_id is set (and wasn't set before), create roles and channels
  IF NEW.discord_server_id IS NOT NULL 
     AND (OLD.discord_server_id IS NULL OR OLD.discord_server_id IS DISTINCT FROM NEW.discord_server_id) THEN
    
    -- Check if roles already exist for this class
    SELECT EXISTS (
      SELECT 1 FROM public.discord_roles 
      WHERE class_id = NEW.id
    ) INTO v_roles_exist;
    
    IF NOT v_roles_exist THEN
      -- Enqueue role creation
      PERFORM public.enqueue_discord_roles_creation(NEW.id, NEW.discord_server_id);
      
      -- Also enqueue invite creation for users who already have Discord linked
      PERFORM public.enqueue_discord_invites_for_existing_users(NEW.id, NEW.discord_server_id);
    END IF;
    
    -- Create #scheduling channel if it doesn't exist
    IF NOT EXISTS (
      SELECT 1 FROM public.discord_channels
      WHERE class_id = NEW.id AND channel_type = 'scheduling'
    ) THEN
      PERFORM public.enqueue_discord_channel_creation(
        NEW.id,
        'scheduling'::public.discord_channel_type,
        NULL,
        'scheduling',
        NEW.discord_server_id
      );
    END IF;
    
    -- Create #operations channel if it doesn't exist
    IF NOT EXISTS (
      SELECT 1 FROM public.discord_channels
      WHERE class_id = NEW.id AND channel_type = 'operations'
    ) THEN
      PERFORM public.enqueue_discord_channel_creation(
        NEW.id,
        'operations'::public.discord_channel_type,
        NULL,
        'operations',
        NEW.discord_server_id
      );
    END IF;
  END IF;
  
  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    -- Log error but don't fail the update
    RAISE WARNING 'Error in trigger_discord_create_roles_on_server_connect for class_id=%: %', NEW.id, SQLERRM;
    RETURN NEW;
END;
$$;

-- 16. Update enqueue_discord_channel_creation to handle new channel types
CREATE OR REPLACE FUNCTION public.enqueue_discord_channel_creation(
  p_class_id bigint,
  p_channel_type public.discord_channel_type,
  p_resource_id bigint DEFAULT NULL,
  p_channel_name text DEFAULT NULL,
  p_guild_id text DEFAULT NULL
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_guild_id text;
  v_channel_group_id text;
  v_class_slug text;
  v_channel_name text;
BEGIN
  -- Get Discord server info from class
  SELECT c.discord_server_id, c.discord_channel_group_id, c.slug
  INTO v_guild_id, v_channel_group_id, v_class_slug
  FROM public.classes c
  WHERE c.id = p_class_id;

  -- Use provided guild_id or fall back to class's discord_server_id
  v_guild_id := COALESCE(p_guild_id, v_guild_id);

  -- Skip if no Discord server configured
  IF v_guild_id IS NULL THEN
    RETURN;
  END IF;

  -- Determine channel name if not provided
  IF p_channel_name IS NULL THEN
    CASE p_channel_type
      WHEN 'general' THEN
        v_channel_name := COALESCE(v_class_slug, 'general');
      WHEN 'assignment' THEN
        SELECT a.title INTO v_channel_name
        FROM public.assignments a
        WHERE a.id = p_resource_id;
        v_channel_name := COALESCE(v_channel_name, 'assignment-' || p_resource_id);
        v_channel_name := 'HW: ' || v_channel_name;
      WHEN 'lab' THEN
        SELECT ls.name INTO v_channel_name
        FROM public.lab_sections ls
        WHERE ls.id = p_resource_id;
        v_channel_name := COALESCE(v_channel_name, 'lab-' || p_resource_id);
        v_channel_name := 'Lab: ' || v_channel_name;
      WHEN 'office_hours' THEN
        SELECT hq.name INTO v_channel_name
        FROM public.help_queues hq
        WHERE hq.id = p_resource_id;
        v_channel_name := COALESCE(v_channel_name, 'office-hours-' || p_resource_id);
        v_channel_name := 'OH: ' || v_channel_name;
      WHEN 'regrades' THEN
        v_channel_name := 'Regrades';
      WHEN 'scheduling' THEN
        v_channel_name := 'scheduling';
      WHEN 'operations' THEN
        v_channel_name := 'operations';
      ELSE
        v_channel_name := 'channel';
    END CASE;
  ELSE
    v_channel_name := p_channel_name;
    -- Add prefix based on channel type if not already present
    IF p_channel_type = 'assignment' AND NOT v_channel_name LIKE 'HW:%' THEN
      v_channel_name := 'HW: ' || v_channel_name;
    ELSIF p_channel_type = 'lab' AND NOT v_channel_name LIKE 'Lab:%' THEN
      v_channel_name := 'Lab: ' || v_channel_name;
    ELSIF p_channel_type = 'office_hours' AND NOT v_channel_name LIKE 'OH:%' THEN
      v_channel_name := 'OH: ' || v_channel_name;
    END IF;
  END IF;

  -- Enqueue channel creation
  PERFORM pgmq_public.send(
    queue_name := 'discord_async_calls',
    message := jsonb_build_object(
      'method', 'create_channel',
      'args', jsonb_build_object(
        'guild_id', v_guild_id,
        'name', v_channel_name,
        'type', 0, -- Text channel
        'parent_id', v_channel_group_id
      ),
      'class_id', p_class_id,
      'channel_type', p_channel_type,
      'resource_id', p_resource_id
    )
  );
END;
$$;

COMMENT ON FUNCTION public.enqueue_discord_channel_creation IS 
'Enqueues creation of a Discord channel for a class. Handles all channel types including scheduling and operations.';

-- 17. RPC for processing calendar announcements transactionally with batching
CREATE OR REPLACE FUNCTION public.process_calendar_announcements()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_now timestamptz := NOW();
  v_messages jsonb[] := '{}';
  v_event RECORD;
  v_channel_id text;
  v_message jsonb;
  v_has_multiple_queues boolean;
  v_queue_name text;
  v_display_name text;
  v_date_str text;
  v_time_str text;
  v_emoji text;
  v_action text;
  v_changed_ids bigint[] := '{}';
  v_started_ids bigint[] := '{}';
  v_ended_ids bigint[] := '{}';
  v_processed_count int := 0;
BEGIN
  -- 1. Process schedule change announcements (new/changed events not yet announced)
  FOR v_event IN
    SELECT 
      ce.id,
      ce.class_id,
      ce.calendar_type,
      ce.title,
      ce.start_time,
      ce.end_time,
      ce.organizer_name,
      ce.queue_name,
      dc.discord_channel_id,
      c.time_zone
    FROM public.calendar_events ce
    INNER JOIN public.classes c ON c.id = ce.class_id AND c.discord_server_id IS NOT NULL
    LEFT JOIN public.discord_channels dc ON dc.class_id = ce.class_id AND dc.channel_type = 'scheduling'
    WHERE ce.change_announced_at IS NULL
      AND ce.end_time >= v_now
    LIMIT 500
  LOOP
    IF v_event.discord_channel_id IS NOT NULL THEN
      v_date_str := to_char(v_event.start_time AT TIME ZONE v_event.time_zone, 'Dy, Mon DD');
      v_time_str := to_char(v_event.start_time AT TIME ZONE v_event.time_zone, 'HH12:MI AM') || ' - ' || 
                   to_char(v_event.end_time AT TIME ZONE v_event.time_zone, 'HH12:MI AM');
      
      v_message := jsonb_build_object(
        'method', 'send_message',
        'args', jsonb_build_object(
          'channel_id', v_event.discord_channel_id,
          'content', 'ðŸ“… **' || v_event.title || '** has been added to the schedule',
          'embeds', jsonb_build_array(jsonb_build_object(
            'description', 'ðŸ“† ' || v_date_str || E'\nâ° ' || v_time_str,
            'color', 65280 -- green
          ))
        ),
        'class_id', v_event.class_id
      );
      v_messages := array_append(v_messages, v_message);
    END IF;
    v_changed_ids := array_append(v_changed_ids, v_event.id);
  END LOOP;

  -- 2. Process start announcements (office hours and events that have started)
  FOR v_event IN
    SELECT 
      ce.id,
      ce.class_id,
      ce.calendar_type,
      ce.title,
      ce.organizer_name,
      ce.queue_name,
      c.discord_server_id,
      -- Get office hours channel (match by queue name if multiple queues)
      CASE 
        WHEN ce.calendar_type = 'office_hours' THEN (
          SELECT dc.discord_channel_id 
          FROM public.discord_channels dc
          LEFT JOIN public.help_queues hq ON hq.id = dc.resource_id AND dc.channel_type = 'office_hours'
          WHERE dc.class_id = ce.class_id 
            AND dc.channel_type = 'office_hours'
            AND (ce.queue_name IS NULL OR hq.name ILIKE ce.queue_name OR dc.resource_id IS NULL)
          LIMIT 1
        )
        ELSE (
          SELECT dc.discord_channel_id 
          FROM public.discord_channels dc
          WHERE dc.class_id = ce.class_id AND dc.channel_type = 'operations'
          LIMIT 1
        )
      END as discord_channel_id,
      (SELECT COUNT(*) > 1 FROM public.help_queues WHERE class_id = ce.class_id) as has_multiple_queues
    FROM public.calendar_events ce
    INNER JOIN public.classes c ON c.id = ce.class_id AND c.discord_server_id IS NOT NULL
    WHERE ce.start_announced_at IS NULL
      AND ce.start_time <= v_now
    LIMIT 500
  LOOP
    IF v_event.discord_channel_id IS NOT NULL THEN
      IF v_event.calendar_type = 'office_hours' THEN
        v_display_name := COALESCE(v_event.organizer_name, v_event.title);
        IF v_event.has_multiple_queues AND v_event.queue_name IS NOT NULL THEN
          v_display_name := v_display_name || ' (' || v_event.queue_name || ')';
        END IF;
        v_message := jsonb_build_object(
          'method', 'send_message',
          'args', jsonb_build_object(
            'channel_id', v_event.discord_channel_id,
            'content', 'ðŸŸ¢ **' || v_display_name || '** is now on duty'
          ),
          'class_id', v_event.class_id
        );
      ELSE
        v_message := jsonb_build_object(
          'method', 'send_message',
          'args', jsonb_build_object(
            'channel_id', v_event.discord_channel_id,
            'content', 'ðŸš€ **' || v_event.title || '** is starting now'
          ),
          'class_id', v_event.class_id
        );
      END IF;
      v_messages := array_append(v_messages, v_message);
    END IF;
    v_started_ids := array_append(v_started_ids, v_event.id);
  END LOOP;

  -- 3. Process end announcements (office hours and events that have ended)
  FOR v_event IN
    SELECT 
      ce.id,
      ce.class_id,
      ce.calendar_type,
      ce.title,
      ce.organizer_name,
      ce.queue_name,
      c.discord_server_id,
      CASE 
        WHEN ce.calendar_type = 'office_hours' THEN (
          SELECT dc.discord_channel_id 
          FROM public.discord_channels dc
          LEFT JOIN public.help_queues hq ON hq.id = dc.resource_id AND dc.channel_type = 'office_hours'
          WHERE dc.class_id = ce.class_id 
            AND dc.channel_type = 'office_hours'
            AND (ce.queue_name IS NULL OR hq.name ILIKE ce.queue_name OR dc.resource_id IS NULL)
          LIMIT 1
        )
        ELSE (
          SELECT dc.discord_channel_id 
          FROM public.discord_channels dc
          WHERE dc.class_id = ce.class_id AND dc.channel_type = 'operations'
          LIMIT 1
        )
      END as discord_channel_id,
      (SELECT COUNT(*) > 1 FROM public.help_queues WHERE class_id = ce.class_id) as has_multiple_queues
    FROM public.calendar_events ce
    INNER JOIN public.classes c ON c.id = ce.class_id AND c.discord_server_id IS NOT NULL
    WHERE ce.end_announced_at IS NULL
      AND ce.end_time <= v_now
    LIMIT 500
  LOOP
    IF v_event.discord_channel_id IS NOT NULL THEN
      IF v_event.calendar_type = 'office_hours' THEN
        v_display_name := COALESCE(v_event.organizer_name, v_event.title);
        IF v_event.has_multiple_queues AND v_event.queue_name IS NOT NULL THEN
          v_display_name := v_display_name || ' (' || v_event.queue_name || ')';
        END IF;
        v_message := jsonb_build_object(
          'method', 'send_message',
          'args', jsonb_build_object(
            'channel_id', v_event.discord_channel_id,
            'content', 'ðŸ”´ **' || v_display_name || '** is now off duty'
          ),
          'class_id', v_event.class_id
        );
      ELSE
        v_message := jsonb_build_object(
          'method', 'send_message',
          'args', jsonb_build_object(
            'channel_id', v_event.discord_channel_id,
            'content', 'âœ… **' || v_event.title || '** has ended'
          ),
          'class_id', v_event.class_id
        );
      END IF;
      v_messages := array_append(v_messages, v_message);
    END IF;
    v_ended_ids := array_append(v_ended_ids, v_event.id);
  END LOOP;

  -- 4. Batch insert all messages into pgmq
  IF array_length(v_messages, 1) > 0 THEN
    PERFORM pgmq_public.send_batch(
      queue_name := 'discord_async_calls',
      messages := v_messages
    );
  END IF;

  -- 5. Batch update announcement timestamps
  IF array_length(v_changed_ids, 1) > 0 THEN
    UPDATE public.calendar_events
    SET change_announced_at = v_now
    WHERE id = ANY(v_changed_ids);
  END IF;

  IF array_length(v_started_ids, 1) > 0 THEN
    UPDATE public.calendar_events
    SET start_announced_at = v_now
    WHERE id = ANY(v_started_ids);
  END IF;

  IF array_length(v_ended_ids, 1) > 0 THEN
    UPDATE public.calendar_events
    SET end_announced_at = v_now
    WHERE id = ANY(v_ended_ids);
  END IF;

  v_processed_count := COALESCE(array_length(v_changed_ids, 1), 0) + 
                       COALESCE(array_length(v_started_ids, 1), 0) + 
                       COALESCE(array_length(v_ended_ids, 1), 0);

  RETURN jsonb_build_object(
    'success', true,
    'processed_count', v_processed_count,
    'messages_queued', COALESCE(array_length(v_messages, 1), 0),
    'change_announcements', COALESCE(array_length(v_changed_ids, 1), 0),
    'start_announcements', COALESCE(array_length(v_started_ids, 1), 0),
    'end_announcements', COALESCE(array_length(v_ended_ids, 1), 0)
  );
END;
$$;

REVOKE ALL ON FUNCTION public.process_calendar_announcements() FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.process_calendar_announcements() TO service_role;

COMMENT ON FUNCTION public.process_calendar_announcements() IS 
'Processes all pending calendar announcements in a single transaction with batched pgmq inserts. Returns count of processed events.';
