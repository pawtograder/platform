-- SIS Sync Cron Job Setup
-- Creates automated hourly sync of SIS-linked classes to keep enrollments up to date

-- 1. Create SIS sync status tracking table
CREATE TABLE IF NOT EXISTS "public"."sis_sync_status" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "course_id" bigint NOT NULL,
    "course_section_id" bigint,
    "lab_section_id" bigint,
    "last_sync_status" text,
    "last_sync_time" timestamp with time zone,
    "last_sync_message" text,
    "sync_enabled" boolean DEFAULT true NOT NULL,
    CONSTRAINT "sis_sync_status_section_constraint" CHECK (
        (course_section_id IS NOT NULL AND lab_section_id IS NULL) OR 
        (course_section_id IS NULL AND lab_section_id IS NOT NULL)
    ),
    CONSTRAINT "sis_sync_status_unique_course_section" UNIQUE (course_id, course_section_id),
    CONSTRAINT "sis_sync_status_unique_lab_section" UNIQUE (course_id, lab_section_id)
);

-- Add foreign key constraints
ALTER TABLE ONLY "public"."sis_sync_status"
    ADD CONSTRAINT "sis_sync_status_course_id_fkey" 
    FOREIGN KEY ("course_id") REFERENCES "public"."classes"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sis_sync_status"
    ADD CONSTRAINT "sis_sync_status_course_section_id_fkey" 
    FOREIGN KEY ("course_section_id") REFERENCES "public"."class_sections"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sis_sync_status"
    ADD CONSTRAINT "sis_sync_status_lab_section_id_fkey" 
    FOREIGN KEY ("lab_section_id") REFERENCES "public"."lab_sections"("id") ON DELETE CASCADE;

-- Enable RLS
ALTER TABLE "public"."sis_sync_status" ENABLE ROW LEVEL SECURITY;

-- Grant permissions
GRANT ALL ON TABLE "public"."sis_sync_status" TO "authenticated";
GRANT ALL ON TABLE "public"."sis_sync_status" TO "service_role";

-- Create RLS policies for sis_sync_status table
CREATE POLICY "Admin users can view all sync status" ON "public"."sis_sync_status"
    FOR SELECT USING (authorize_for_admin());

CREATE POLICY "Service role can manage all sync status" ON "public"."sis_sync_status"
    FOR ALL USING (auth.role() = 'service_role');

CREATE POLICY "Admin users can update sync status" ON "public"."sis_sync_status"
    FOR UPDATE USING (authorize_for_admin());

-- 2. Create function to trigger SIS sync via edge function
CREATE OR REPLACE FUNCTION trigger_sis_sync(p_class_id bigint DEFAULT NULL)
RETURNS json AS $$
DECLARE
    sync_result json;
BEGIN
    -- Call the edge function to sync SIS data
    SELECT content INTO sync_result
    FROM call_edge_function_internal(
        'course-import-sis',
        'POST',
        '{"x-edge-function-secret": "' || current_setting('app.edge_function_secret', true) || '"}',
        CASE 
            WHEN p_class_id IS NOT NULL THEN 
                json_build_object('classId', p_class_id::text)
            ELSE 
                '{}'::json
        END
    );
    
    RETURN sync_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. Create admin function to manually trigger SIS sync
CREATE OR REPLACE FUNCTION admin_trigger_sis_sync(p_class_id bigint DEFAULT NULL)
RETURNS json AS $$
BEGIN
    -- Check admin authorization
    IF NOT authorize_for_admin() THEN
        RAISE EXCEPTION 'Access denied: Admin role required';
    END IF;

    RETURN trigger_sis_sync(p_class_id);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4. Set up pg_cron job to run SIS sync hourly
-- Note: This requires the pg_cron extension and appropriate permissions
-- The job will sync all SIS-linked classes every hour

DO $$
BEGIN
    -- Check if pg_cron extension is available
    IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron') THEN
        -- Schedule hourly SIS sync at 15 minutes past each hour
        -- This avoids potential conflicts with other top-of-hour jobs
        PERFORM cron.schedule(
            'sis-enrollment-sync',
            '15 * * * *',  -- Every hour at :15
            'SELECT trigger_sis_sync();'
        );
        
        RAISE NOTICE 'SIS sync cron job scheduled to run hourly at :15';
    ELSE
        RAISE NOTICE 'pg_cron extension not available - SIS sync job not scheduled';
    END IF;
EXCEPTION
    WHEN insufficient_privilege THEN
        RAISE NOTICE 'Insufficient privileges to schedule cron job - must be run by superuser';
    WHEN OTHERS THEN
        RAISE NOTICE 'Failed to schedule SIS sync cron job: %', SQLERRM;
END $$;

-- 5. Create function to check SIS sync status and last run times
CREATE OR REPLACE FUNCTION admin_get_sis_sync_status()
RETURNS TABLE (
    class_id bigint,
    class_name text,
    term text,
    sis_sections_count bigint,
    last_sync_time timestamptz,
    last_sync_status text,
    last_sync_message text,
    sync_enabled boolean,
    total_invitations bigint,
    pending_invitations bigint,
    expired_invitations bigint
) AS $$
BEGIN
    -- Check admin authorization
    IF NOT authorize_for_admin() THEN
        RAISE EXCEPTION 'Access denied: Admin role required';
    END IF;

    RETURN QUERY
    SELECT 
        c.id as class_id,
        c.name as class_name,
        c.term,
        (
            (SELECT COUNT(*) FROM public.class_sections cs WHERE cs.class_id = c.id AND cs.sis_crn IS NOT NULL) +
            (SELECT COUNT(*) FROM public.lab_sections ls WHERE ls.class_id = c.id AND ls.sis_crn IS NOT NULL)
        ) as sis_sections_count,
        sync_summary.last_sync_time,
        sync_summary.last_sync_status,
        sync_summary.last_sync_message,
        NOT COALESCE(c.archived, false) as sync_enabled,
        COALESCE(invite_stats.total_invitations, 0) as total_invitations,
        COALESCE(invite_stats.pending_invitations, 0) as pending_invitations,
        COALESCE(invite_stats.expired_invitations, 0) as expired_invitations
    FROM public.classes c
    LEFT JOIN (
        SELECT 
            invitations.class_id,
            COUNT(*) as total_invitations,
            COUNT(*) FILTER (WHERE invitations.status = 'pending') as pending_invitations,
            COUNT(*) FILTER (WHERE invitations.status = 'expired') as expired_invitations
        FROM public.invitations
        GROUP BY invitations.class_id
    ) invite_stats ON c.id = invite_stats.class_id
    LEFT JOIN (
        SELECT 
            sss.course_id,
            MAX(sss.last_sync_time) as last_sync_time,
            -- Get the most recent sync status (from the row with latest last_sync_time)
            (SELECT sss2.last_sync_status FROM public.sis_sync_status sss2 
             WHERE sss2.course_id = sss.course_id 
             ORDER BY sss2.last_sync_time DESC NULLS LAST 
             LIMIT 1) as last_sync_status,
            -- Get the most recent sync message
            (SELECT sss2.last_sync_message FROM public.sis_sync_status sss2 
             WHERE sss2.course_id = sss.course_id 
             ORDER BY sss2.last_sync_time DESC NULLS LAST 
             LIMIT 1) as last_sync_message
        FROM public.sis_sync_status sss
        GROUP BY sss.course_id
    ) sync_summary ON c.id = sync_summary.course_id
    WHERE EXISTS (
        SELECT 1 FROM public.class_sections cs 
        WHERE cs.class_id = c.id AND cs.sis_crn IS NOT NULL
    )
    OR EXISTS (
        SELECT 1 FROM public.lab_sections ls 
        WHERE ls.class_id = c.id AND ls.sis_crn IS NOT NULL
    )
    ORDER BY c.term DESC, c.name;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6. Create function to enable/disable SIS sync for a class (by archiving/unarchiving)
CREATE OR REPLACE FUNCTION admin_set_sis_sync_enabled(
    p_class_id bigint,
    p_enabled boolean,
    p_admin_user_id uuid DEFAULT auth.uid()
)
RETURNS boolean AS $$
BEGIN
    -- Check admin authorization
    IF NOT authorize_for_admin(p_admin_user_id) THEN
        RAISE EXCEPTION 'Access denied: Admin role required';
    END IF;

    -- Enable/disable by archiving/unarchiving the class
    UPDATE public.classes SET
        archived = NOT p_enabled,
        updated_at = now()
    WHERE classes.id = p_class_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 7. Create function to update SIS sync status for a section
CREATE OR REPLACE FUNCTION update_sis_sync_status(
    p_course_id bigint,
    p_course_section_id bigint DEFAULT NULL,
    p_lab_section_id bigint DEFAULT NULL,
    p_sync_status text DEFAULT NULL,
    p_sync_message text DEFAULT NULL
)
RETURNS bigint AS $$
DECLARE
    v_status_id bigint;
BEGIN
    -- Validate that exactly one section ID is provided
    IF (p_course_section_id IS NULL AND p_lab_section_id IS NULL) OR 
       (p_course_section_id IS NOT NULL AND p_lab_section_id IS NOT NULL) THEN
        RAISE EXCEPTION 'Exactly one of course_section_id or lab_section_id must be provided';
    END IF;

    -- Insert or update sync status record
    INSERT INTO public.sis_sync_status (
        course_id,
        course_section_id,
        lab_section_id,
        last_sync_status,
        last_sync_time,
        last_sync_message,
        sync_enabled
    )
    VALUES (
        p_course_id,
        p_course_section_id,
        p_lab_section_id,
        p_sync_status,
        now(),
        p_sync_message,
        true
    )
    ON CONFLICT (course_id, course_section_id) WHERE course_section_id IS NOT NULL
    DO UPDATE SET
        last_sync_status = EXCLUDED.last_sync_status,
        last_sync_time = EXCLUDED.last_sync_time,
        last_sync_message = EXCLUDED.last_sync_message
    RETURNING id INTO v_status_id;

    -- Handle lab sections conflict separately due to different unique constraint
    IF v_status_id IS NULL AND p_lab_section_id IS NOT NULL THEN
        INSERT INTO public.sis_sync_status (
            course_id,
            course_section_id,
            lab_section_id,
            last_sync_status,
            last_sync_time,
            last_sync_message,
            sync_enabled
        )
        VALUES (
            p_course_id,
            p_course_section_id,
            p_lab_section_id,
            p_sync_status,
            now(),
            p_sync_message,
            true
        )
        ON CONFLICT (course_id, lab_section_id) WHERE lab_section_id IS NOT NULL
        DO UPDATE SET
            last_sync_status = EXCLUDED.last_sync_status,
            last_sync_time = EXCLUDED.last_sync_time,
            last_sync_message = EXCLUDED.last_sync_message
        RETURNING id INTO v_status_id;
    END IF;

    RETURN v_status_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8. Create function to enable/disable sync for specific sections
CREATE OR REPLACE FUNCTION admin_set_section_sync_enabled(
    p_course_id bigint,
    p_enabled boolean,
    p_course_section_id bigint DEFAULT NULL,
    p_lab_section_id bigint DEFAULT NULL,
    p_admin_user_id uuid DEFAULT auth.uid()
)
RETURNS boolean AS $$
BEGIN
    -- Check admin authorization
    IF NOT authorize_for_admin(p_admin_user_id) THEN
        RAISE EXCEPTION 'Access denied: Admin role required';
    END IF;

    -- Validate that exactly one section ID is provided
    IF (p_course_section_id IS NULL AND p_lab_section_id IS NULL) OR 
       (p_course_section_id IS NOT NULL AND p_lab_section_id IS NOT NULL) THEN
        RAISE EXCEPTION 'Exactly one of course_section_id or lab_section_id must be provided';
    END IF;

    -- Update or create sync status record
    PERFORM update_sis_sync_status(
        p_course_id,
        p_course_section_id,
        p_lab_section_id,
        CASE WHEN p_enabled THEN 'enabled' ELSE 'disabled' END,
        CASE WHEN p_enabled THEN 'Sync enabled by admin' ELSE 'Sync disabled by admin' END
    );

    -- Update the sync_enabled flag specifically
    IF p_course_section_id IS NOT NULL THEN
        UPDATE public.sis_sync_status SET
            sync_enabled = p_enabled
        WHERE course_id = p_course_id AND course_section_id = p_course_section_id;
    ELSE
        UPDATE public.sis_sync_status SET
            sync_enabled = p_enabled
        WHERE course_id = p_course_id AND lab_section_id = p_lab_section_id;
    END IF;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Comments for documentation
COMMENT ON TABLE sis_sync_status IS 'Tracks SIS sync status and history for class and lab sections';
COMMENT ON FUNCTION trigger_sis_sync IS 'Triggers SIS enrollment sync via edge function. Can sync all classes or specific class.';
COMMENT ON FUNCTION admin_trigger_sis_sync IS 'Admin-only function to manually trigger SIS sync';
COMMENT ON FUNCTION admin_get_sis_sync_status IS 'Gets status of all SIS-linked classes for admin monitoring';
COMMENT ON FUNCTION admin_set_sis_sync_enabled IS 'Enables/disables SIS sync for a class by archiving/unarchiving';
COMMENT ON FUNCTION update_sis_sync_status IS 'Updates or creates SIS sync status record for a section. Used by edge functions.';
COMMENT ON FUNCTION admin_set_section_sync_enabled IS 'Admin function to enable/disable sync for specific class or lab sections';

-- Grant necessary permissions
GRANT EXECUTE ON FUNCTION trigger_sis_sync TO postgres;
GRANT EXECUTE ON FUNCTION admin_trigger_sis_sync TO authenticated;
GRANT EXECUTE ON FUNCTION admin_get_sis_sync_status TO authenticated;
GRANT EXECUTE ON FUNCTION admin_set_sis_sync_enabled TO authenticated;
GRANT EXECUTE ON FUNCTION update_sis_sync_status TO service_role;
GRANT EXECUTE ON FUNCTION admin_set_section_sync_enabled TO authenticated;
