alter table "public"."discussion_topics" add column "assignment_id" bigint;

alter table "public"."discussion_topics" add constraint "discussion_topics_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.assignments(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."discussion_topics" validate constraint "discussion_topics_assignment_id_fkey";


  create policy "Instructors can create topics in their class"
  on "public"."discussion_topics"
  as permissive
  for insert
  to authenticated
with check (public.authorizeforclassinstructor(class_id));



  create policy "Instructors can delete topics in their class"
  on "public"."discussion_topics"
  as permissive
  for delete
  to authenticated
using (public.authorizeforclassinstructor(class_id));



  create policy "Instructors can update topics in their class"
  on "public"."discussion_topics"
  as permissive
  for update
  to authenticated
using (public.authorizeforclassinstructor(class_id))
with check (public.authorizeforclassinstructor(class_id));


-- Add topic icons and default-follow support

ALTER TABLE public.discussion_topics
  ADD COLUMN IF NOT EXISTS icon text;

ALTER TABLE public.discussion_topics
  ADD COLUMN IF NOT EXISTS default_follow boolean NOT NULL DEFAULT false;

-- Allow instructors to update icon/default_follow even on default topics.
-- (UI can still restrict editing topic name/description/color for default topics.)
DROP POLICY IF EXISTS "Instructors can update topics in their class" ON public.discussion_topics;

CREATE POLICY "Instructors can update topics in their class"
ON public.discussion_topics
AS PERMISSIVE
FOR UPDATE
TO authenticated
USING (public.authorizeforclassinstructor(class_id))
WITH CHECK (public.authorizeforclassinstructor(class_id));

-- Topic following (including default-follow overrides)

CREATE TABLE IF NOT EXISTS public.discussion_topic_followers (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  updated_at timestamp with time zone DEFAULT now() NOT NULL,
  user_id uuid NOT NULL REFERENCES public.users(user_id) ON DELETE CASCADE,
  class_id bigint NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
  topic_id bigint NOT NULL REFERENCES public.discussion_topics(id) ON DELETE CASCADE,
  following boolean NOT NULL DEFAULT true,
  CONSTRAINT discussion_topic_followers_user_topic_uniq UNIQUE (user_id, topic_id)
);

-- Row-level security: personal preference per user
ALTER TABLE public.discussion_topic_followers ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "CRUD for self" ON public.discussion_topic_followers;
CREATE POLICY "CRUD for self"
  ON public.discussion_topic_followers
  AS PERMISSIVE
  FOR ALL
  TO authenticated
  USING ((select auth.uid()) = user_id)
  WITH CHECK ((select auth.uid()) = user_id);

-- Broadcast changes only to the individual user channel: class:$class_id:user:$private_profile_id
CREATE OR REPLACE FUNCTION public.broadcast_discussion_topic_followers_user_only() RETURNS trigger
  LANGUAGE plpgsql SECURITY DEFINER
  SET search_path TO ''
AS $$
DECLARE
  class_id_value bigint;
  row_id text;
  follower_user_id uuid;
  follower_profile_id uuid;
  user_payload jsonb;
BEGIN
  IF TG_OP = 'INSERT' THEN
    class_id_value := NEW.class_id;
    row_id := NEW.id;
    follower_user_id := NEW.user_id;
  ELSIF TG_OP = 'UPDATE' THEN
    class_id_value := COALESCE(NEW.class_id, OLD.class_id);
    row_id := COALESCE(NEW.id, OLD.id);
    follower_user_id := COALESCE(NEW.user_id, OLD.user_id);
  ELSIF TG_OP = 'DELETE' THEN
    class_id_value := OLD.class_id;
    row_id := OLD.id;
    follower_user_id := OLD.user_id;
  END IF;

  IF class_id_value IS NOT NULL AND follower_user_id IS NOT NULL THEN
    SELECT ur.private_profile_id INTO follower_profile_id
    FROM public.user_roles ur
    WHERE ur.user_id = follower_user_id AND ur.class_id = class_id_value
    LIMIT 1;
  END IF;

  IF class_id_value IS NOT NULL AND follower_profile_id IS NOT NULL THEN
    user_payload := jsonb_build_object(
      'type', 'table_change',
      'operation', TG_OP,
      'table', TG_TABLE_NAME,
      'row_id', row_id,
      'class_id', class_id_value,
      'data', CASE
        WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD)
        ELSE to_jsonb(NEW)
      END,
      'timestamp', NOW()
    );

    PERFORM realtime.send(
      user_payload,
      'broadcast',
      'class:' || class_id_value || ':user:' || follower_profile_id,
      true
    );
  END IF;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$$;

DROP TRIGGER IF EXISTS broadcast_discussion_topic_followers_realtime ON public.discussion_topic_followers;
CREATE TRIGGER broadcast_discussion_topic_followers_realtime
  AFTER INSERT OR UPDATE OR DELETE
  ON public.discussion_topic_followers
  FOR EACH ROW
  EXECUTE FUNCTION public.broadcast_discussion_topic_followers_user_only();

-- Maintain updated_at
CREATE OR REPLACE FUNCTION public.set_discussion_topic_followers_updated_at() RETURNS trigger
  LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS set_discussion_topic_followers_updated_at ON public.discussion_topic_followers;
CREATE TRIGGER set_discussion_topic_followers_updated_at
  BEFORE UPDATE
  ON public.discussion_topic_followers
  FOR EACH ROW
  EXECUTE FUNCTION public.set_discussion_topic_followers_updated_at();

-- Grants (follow existing pattern of user-only preference tables)
GRANT ALL ON TABLE public.discussion_topic_followers TO authenticated;
GRANT ALL ON TABLE public.discussion_topic_followers TO service_role;

-- Identity sequence permissions for inserts
GRANT USAGE, SELECT ON SEQUENCE public.discussion_topic_followers_id_seq TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE public.discussion_topic_followers_id_seq TO service_role;
