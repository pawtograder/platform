CREATE TABLE "public"."self_review_settings" (
    "id" bigint generated by default as identity not null,
    "enabled" boolean not null default false,
    "deadline_offset" bigint,
    "allow_early" boolean,
    "class_id" bigint not null 
);

ALTER TABLE "public"."self_review_settings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "anyone in the course can view self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR SELECT
USING (
    authorizeforclassinstructor(class_id) OR authorizeforclassgrader(class_id) 
    OR authorizeforclass(class_id)
);

CREATE POLICY "instructors can insert self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR INSERT
WITH CHECK (
    authorizeforclassinstructor(class_id)
);

CREATE POLICY "instructors can update self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR UPDATE
USING (
    authorizeforclassinstructor(class_id) 
);

CREATE POLICY "instructors can delete review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR DELETE
USING (
    authorizeforclassinstructor(class_id)
);

ALTER TABLE ONLY "public"."self_review_settings"
    ADD CONSTRAINT "self_review_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE "public"."self_review_settings"
    ADD CONSTRAINT "self_review_settings_class_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."classes"("id");

ALTER TABLE "public"."assignments" ADD COLUMN "self_review_setting_id" bigint NOT NULL;

ALTER TABLE "public"."assignments"
    ADD CONSTRAINT "assignments_self_review_setting_fkey" FOREIGN KEY ("self_review_setting_id") REFERENCES "public"."self_review_settings"("id");

CREATE POLICY "Students can give themselves negative deadline exceptions"
ON "public"."assignment_due_date_exceptions"
AS PERMISSIVE 
FOR INSERT
WITH CHECK (
   "hours" < 0 
);

CREATE POLICY "Deadline exceptions never inserted after early finish"
ON "public"."assignment_due_date_exceptions"
AS RESTRICTIVE 
FOR INSERT
WITH CHECK (
   NOT EXISTS (
    SELECT 1 FROM "public"."assignment_due_date_exceptions" adde
    WHERE (student_id = adde.student_id OR assignment_group_id = adde.assignment_group_id)
    AND assignment_id = adde.assignment_id AND class_id = adde.class_id AND adde.hours < 0
   )
);

CREATE OR REPLACE FUNCTION public.assignments_grader_config_auto_populate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
    declare 
    rubric_id int;
    self_rubric_id int;
    begin
  
  INSERT INTO autograder (id, class_id) VALUES (NEW.id, NEW.class_id);
  INSERT INTO autograder_regression_test (autograder_id,repository) VALUES (NEW.id, NEW.template_repo);
  INSERT INTO rubrics (name, class_id, assignment_id) VALUES ('Grading Rubric', NEW.class_id, NEW.id) RETURNING id into rubric_id;
  INSERT INTO rubrics (name, class_id, assignment_id) VALUES ('Self Rubric', NEW.class_id, NEW.id) RETURNING id into self_rubric_id;
  UPDATE assignments set grading_rubric_id=rubric_id WHERE id=NEW.id;
UPDATE assignments set self_review_rubric_id=self_rubric_id WHERE id=NEW.id;
  RETURN NULL;
end;$function$
;

-- TEMPORARY: REFINE!!!!!!!
CREATE POLICY "Anyone can insert on review assignments"
ON "public"."review_assignments"
AS PERMISSIVE 
FOR INSERT
WITH CHECK (
    authorizeforclass(class_id)
);

CREATE OR REPLACE FUNCTION public.auto_assign_self_reviews(this_assignment_id bigint, this_profile_id uuid) 
RETURNS void 
LANGUAGE plpgsql 
AS $$ 
DECLARE     
    this_assignment public.assignments;     
    this_self_review_setting public.self_review_settings;     
    this_net_deadline_change integer := 0;     
    this_active_submission_id bigint;     
    this_group_id bigint; 
BEGIN     
    -- Get the assignment first     
    SELECT * INTO this_assignment FROM public.assignments WHERE id = this_assignment_id;          
    
    -- Check if assignment exists     
    IF this_assignment.id IS NULL THEN         
        RETURN;     
    END IF;      
    
    -- Confirm this is a private profile for a student in this class, else abort     
    IF NOT EXISTS (         
        SELECT 1 FROM user_roles          
        WHERE private_profile_id = this_profile_id          
        AND role = 'student'
        AND class_id = this_assignment.class_id     
    ) THEN         
        RETURN;     
    END IF;      
    
    -- Get the group of the student for this assignment     
    SELECT assignment_group_id INTO this_group_id      
    FROM public.assignment_groups_members      
    WHERE profile_id = this_profile_id      
    AND class_id = this_assignment.class_id      
    AND assignment_id = this_assignment.id      
    LIMIT 1;      
    
    -- Get the self review setting     
    SELECT * INTO this_self_review_setting      
    FROM public.self_review_settings      
    WHERE id = this_assignment.self_review_setting_id;
    
    -- If self reviews are not enabled for this assignment, abort     
    IF this_self_review_setting.enabled IS NOT TRUE THEN         
        RETURN;     
    END IF;          
    
    -- If there is an existing review assignment for this student for this assignment, abort     
    IF EXISTS (         
        SELECT 1 FROM review_assignments          
        WHERE assignment_id = this_assignment.id          
        AND assignee_profile_id = this_profile_id     
    ) THEN         
        RETURN;     
    END IF;      
    
    -- Calculate the deadline offset by combining the deadline changes     
    SELECT COALESCE(SUM(hours), 0) INTO this_net_deadline_change      
    FROM public.assignment_due_date_exceptions      
    WHERE assignment_id = this_assignment.id      
    AND (student_id = this_profile_id OR assignment_group_id = this_group_id);      
    
    -- If deadline has not passed, abort     
    IF NOT (this_assignment.due_date + INTERVAL '1 hour' * this_net_deadline_change <= NOW()) THEN         
        RETURN;     
    END IF;      
    
    -- Get the active submission id for this profile     
    SELECT id INTO this_active_submission_id      
    FROM public.submissions      
    WHERE profile_id = this_profile_id      
    AND assignment_id = this_assignment.id
    AND is_active = TRUE     
    LIMIT 1;      
    
    -- If active submission does not exist, abort     
    IF this_active_submission_id IS NULL THEN         
        RETURN;     
    END IF;          
    
    INSERT INTO review_assignments (         
        due_date,         
        assignee_profile_id,         
        submission_id,         
        assignment_id,         
        rubric_id,         
        class_id     
    )     
    VALUES (         
        this_assignment.due_date + INTERVAL '1 hour' * this_net_deadline_change + INTERVAL '1 hour' * this_self_review_setting.deadline_offset,
        this_profile_id,         
        this_active_submission_id,         
        this_assignment.id,         
        this_assignment.self_review_rubric_id,         
        this_assignment.class_id     
    ); 
END; 
$$;

ALTER FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) OWNER TO "postgres";

GRANT ALL ON FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) TO "anon";
GRANT ALL ON FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) TO "service_role";

CREATE OR REPLACE FUNCTION auto_assign_self_reviews_trigger()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- if a negative exception was inserted, then student moved forward their deadline.  assign them a self review.
    PERFORM auto_assign_self_reviews(NEW.assignment_id, NEW.student_id);
    RETURN NEW;
END;
$$;

CREATE TRIGGER self_review_insert_after_student_finish 
AFTER INSERT ON public.assignment_due_date_exceptions 
FOR EACH ROW
EXECUTE FUNCTION auto_assign_self_reviews_trigger();

-- NOTE: auto_assign_self_reviews_trigger can be reused for assignment due date passing w/o student triggering themselves

-- Function to check for passed dates
CREATE OR REPLACE FUNCTION check_assignment_deadlines_passed()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
    -- get all assignments where the deadline has passed but the longest late day window has not passed
    -- for each assignment, get all profiles for the class that assignment is for
    -- for each assignment x profile combination, call auto_assign_self_reviews to assign reviews to the needed students

    -- special case to consider: professor gives student an extension that is greater than the maximum number of 
    -- late days for this assignment.  this will never trigger the function to be called 
    -- -> could have a separate trigger for iterating through exceptions for dates that have passed in the hour or something 
    -- to account for the super long extensions

END;
$$;

-- Schedule to run every 5 minutes
-- SELECT cron.schedule('check_assignment_deadlines_passed', '*/5 * * * *', 'SELECT check_assignment_deadlines_passed();');
