CREATE TABLE "public"."self_review_settings" (
    "id" bigint generated by default as identity not null,
    "enabled" boolean not null default false,
    "deadline_offset" bigint,
    "allow_early" boolean,
    "class_id" bigint not null 
);

ALTER TABLE "public"."self_review_settings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "anyone in the course can view self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR SELECT
TO authenticated
USING (
    authorizeforclassinstructor(class_id) OR authorizeforclassgrader(class_id) 
    OR authorizeforclass(class_id)
);

CREATE POLICY "instructors can insert self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR INSERT
TO authenticated
WITH CHECK (
    authorizeforclassinstructor(class_id)
);

CREATE POLICY "instructors can update self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR UPDATE
TO authenticated
USING (
    authorizeforclassinstructor(class_id) 
);

CREATE POLICY "instructors can delete review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR DELETE
TO authenticated
USING (
    authorizeforclassinstructor(class_id)
);

ALTER TABLE "public"."assignment_due_date_exceptions" ADD COLUMN "minutes" integer NOT NULL default 0;

CREATE POLICY "Students can give themselves negative deadline exceptions"
ON "public"."assignment_due_date_exceptions"
AS PERMISSIVE 
FOR INSERT
TO authenticated
WITH CHECK (
   (("hours" * 60 + "minutes" < 0)) AND 
(authorizeforprofile(student_id) OR authorizeforassignmentgroup(assignment_group_id)));

ALTER TABLE ONLY "public"."self_review_settings"
    ADD CONSTRAINT "self_review_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE "public"."self_review_settings"
    ADD CONSTRAINT "self_review_settings_class_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."classes"("id");

ALTER TABLE "public"."assignments" ADD COLUMN "self_review_setting_id" bigint NOT NULL;

ALTER TABLE "public"."assignments"
    ADD CONSTRAINT "assignments_self_review_setting_fkey" FOREIGN KEY ("self_review_setting_id") REFERENCES "public"."self_review_settings"("id");

CREATE POLICY "Deadline exceptions never inserted after early finish"
ON "public"."assignment_due_date_exceptions"
AS RESTRICTIVE 
FOR INSERT
TO authenticated
WITH CHECK (
   NOT EXISTS (
    SELECT 1 FROM "public"."assignment_due_date_exceptions" adde
    WHERE (student_id = adde.student_id OR assignment_group_id = adde.assignment_group_id)
    AND assignment_id = adde.assignment_id AND class_id = adde.class_id AND adde.hours < 0
   )
);

CREATE OR REPLACE FUNCTION public.assignments_grader_config_auto_populate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
    declare 
    rubric_id int;
    self_rubric_id int;
    begin
  
  INSERT INTO autograder (id, class_id) VALUES (NEW.id, NEW.class_id);
  INSERT INTO autograder_regression_test (autograder_id,repository) VALUES (NEW.id, NEW.template_repo);
  INSERT INTO rubrics (name, class_id, assignment_id) VALUES ('Grading Rubric', NEW.class_id, NEW.id) RETURNING id into rubric_id;
  INSERT INTO rubrics (name, class_id, assignment_id) VALUES ('Self Rubric', NEW.class_id, NEW.id) RETURNING id into self_rubric_id;
  UPDATE assignments set grading_rubric_id=rubric_id WHERE id=NEW.id;
UPDATE assignments set self_review_rubric_id=self_rubric_id WHERE id=NEW.id;
  RETURN NULL;
end;$function$
;

CREATE OR REPLACE FUNCTION public.auto_assign_self_reviews(this_assignment_id bigint, this_profile_id uuid) 
RETURNS void 
LANGUAGE plpgsql 
SECURITY DEFINER
AS $$ 
DECLARE     
    this_assignment public.assignments;     
    this_group_id bigint; 
    this_self_review_setting public.self_review_settings;     
    this_net_deadline_change_hours integer := 0;     
    this_net_deadline_change_minutes integer := 0;     
    this_active_submission_id bigint;
    utc_now TIMESTAMP := date_trunc('minute', now() + interval '59 second'); -- round up to nearest minute
BEGIN    
    -- Get the assignment first     
    SELECT * INTO this_assignment FROM public.assignments WHERE id = this_assignment_id;          
    
    -- Check if assignment exists     
    IF this_assignment.id IS NULL THEN 
        RETURN;          
    END IF;      
    
    -- Confirm this is a private profile for a student in this class, else abort     
    IF NOT EXISTS (         
        SELECT 1 FROM user_roles          
        WHERE private_profile_id = this_profile_id          
        AND role = 'student'
        AND class_id = this_assignment.class_id     
    ) THEN  
        RETURN;
    END IF;      
    
    -- Get the group of the student for this assignment     
    SELECT assignment_group_id INTO this_group_id      
    FROM public.assignment_groups_members      
    WHERE profile_id = this_profile_id      
    AND class_id = this_assignment.class_id      
    AND assignment_id = this_assignment.id      
    LIMIT 1;      
    
    -- Get the self review setting     
    SELECT * INTO this_self_review_setting      
    FROM public.self_review_settings      
    WHERE id = this_assignment.self_review_setting_id;
    
    -- If self reviews are not enabled for this assignment, abort     
    IF this_self_review_setting.enabled IS NOT TRUE THEN       
        RETURN;       
    END IF;          
    
    -- If there is an existing review assignment for this student for this assignment, abort     
    IF EXISTS (         
        SELECT 1 FROM review_assignments          
        WHERE assignment_id = this_assignment.id          
        AND assignee_profile_id = this_profile_id     
    ) THEN 
       RETURN;       
    END IF;      
    
    SELECT COALESCE(SUM("hours"), 0) INTO this_net_deadline_change_hours      
    FROM public.assignment_due_date_exceptions      
    WHERE assignment_id = this_assignment.id      
    AND (student_id = this_profile_id OR assignment_group_id = this_group_id);     

    SELECT COALESCE(SUM("minutes"), 0) INTO this_net_deadline_change_minutes 
    FROM public.assignment_due_date_exceptions      
    WHERE assignment_id = this_assignment.id      
    AND (student_id = this_profile_id OR assignment_group_id = this_group_id);     

    
    -- If deadline has not passed, abort     
    IF NOT (this_assignment.due_date AT TIME ZONE 'UTC' + INTERVAL '1 hour' * this_net_deadline_change_hours  + 
    INTERVAL '1 minute' * this_net_deadline_change_minutes <= utc_now) THEN         
       RETURN;       
    END IF;      
    
    -- Get the active submission id for this profile     
    SELECT id INTO this_active_submission_id      
    FROM public.submissions      
    WHERE ((profile_id IS NOT NULL AND profile_id = this_profile_id) OR (assignment_group_id IS NOT NULL AND assignment_group_id = this_group_id)) 
    AND assignment_id = this_assignment_id
    AND is_active = true     
    LIMIT 1;      
    
    -- If active submission does not exist, abort     
    IF this_active_submission_id IS NULL THEN  
        RETURN;       
    END IF;          

    INSERT INTO review_assignments (   
        due_date,         
        assignee_profile_id,         
        submission_id,         
        assignment_id,         
        rubric_id,         
        class_id   
    )     
    VALUES (        
        this_assignment.due_date AT TIME ZONE 'UTC' + (INTERVAL '1 hour' * this_net_deadline_change_hours) + (INTERVAL '1 minute' * this_net_deadline_change_minutes) + (INTERVAL '1 hour' * this_self_review_setting.deadline_offset),
        this_profile_id,         
        this_active_submission_id,         
        this_assignment.id,         
        this_assignment.self_review_rubric_id,         
        this_assignment.class_id
    );
END; 
$$;

ALTER FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) OWNER TO "postgres";

GRANT ALL ON FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) TO "anon";
GRANT ALL ON FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) TO "service_role";

CREATE OR REPLACE FUNCTION auto_assign_self_reviews_trigger()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE 
    profile_record uuid;
BEGIN
    IF NEW.assignment_group_id IS NOT NULL THEN -- if exception is for a group, create for all in group 
        FOR profile_record IN (
            SELECT "profile_id" FROM public.assignment_groups_members WHERE assignment_group_id = NEW.assignment_group_id AND assignment_id = NEW.assignment_id
        ) LOOP
            PERFORM auto_assign_self_reviews(NEW.assignment_id, profile_record);
        END LOOP;
    ELSE -- else create only for single student
        PERFORM auto_assign_self_reviews(NEW.assignment_id, NEW.student_id);
    END IF;
    RETURN NEW;
END;
$$;

-- For after a student marks their assignment "finished early" to get the self review
CREATE TRIGGER self_review_insert_after_student_finish 
AFTER INSERT ON public.assignment_due_date_exceptions 
FOR EACH ROW
EXECUTE FUNCTION auto_assign_self_reviews_trigger();

-- For regular and extended assignment deadlines
CREATE OR REPLACE FUNCTION check_assignment_deadlines_passed()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE 
    assignment_record public.assignments;
    profile_record public.profiles;
BEGIN
    FOR assignment_record IN (
        SELECT * FROM assignments -- non archived assignment with passed deadline
        WHERE archived_at IS NULL AND (due_date AT TIME ZONE 'UTC' <= NOW() AT TIME ZONE 'UTC');  
    ) LOOP
        FOR profile_record IN (
            SELECT * FROM public.profiles prof
            WHERE is_private_profile = true
            AND assignment_record.class_id = class_id
            AND EXISTS (
                SELECT 1 FROM user_roles WHERE private_profile_id = prof.id AND "role" = 'student'
            ) 
        ) LOOP
            PERFORM auto_assign_self_reviews(assignment_record.id, profile_record.id);
        END LOOP;
        
    END LOOP;
END;
$$;

create extension pg_cron with schema pg_catalog;

grant usage on schema cron to postgres; grant all privileges on all tables in schema cron to postgres;

SELECT cron.schedule('check_assignment_deadlines_passed', '* * * * *', 'SELECT check_assignment_deadlines_passed();');