CREATE TABLE "public"."self_review_settings" (
    "id" bigint generated by default as identity not null,
    "enabled" boolean not null default false,
    "deadline_offset" bigint,
    "allow_early" boolean,
    "class_id" bigint not null 
);

ALTER TABLE "public"."self_review_settings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "anyone in the course can view self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR SELECT
TO authenticated
USING (
    authorizeforclassinstructor(class_id) OR authorizeforclassgrader(class_id) 
    OR authorizeforclass(class_id)
);

CREATE POLICY "instructors can insert self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR INSERT
TO authenticated
WITH CHECK (
    authorizeforclassinstructor(class_id)
);

CREATE POLICY "instructors can update self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR UPDATE
TO authenticated
USING (
    authorizeforclassinstructor(class_id) 
);

CREATE POLICY "instructors can delete review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR DELETE
TO authenticated
USING (
    authorizeforclassinstructor(class_id)
);

ALTER TABLE ONLY "public"."self_review_settings"
    ADD CONSTRAINT "self_review_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE "public"."self_review_settings"
    ADD CONSTRAINT "self_review_settings_class_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."classes"("id");

ALTER TABLE "public"."assignments" ADD COLUMN "self_review_setting_id" bigint NOT NULL;

ALTER TABLE "public"."assignments"
    ADD CONSTRAINT "assignments_self_review_setting_fkey" FOREIGN KEY ("self_review_setting_id") REFERENCES "public"."self_review_settings"("id");

CREATE POLICY "Deadline exceptions never inserted after early finish"
ON "public"."assignment_due_date_exceptions"
AS RESTRICTIVE 
FOR INSERT
TO authenticated
WITH CHECK (
   NOT EXISTS (
    SELECT 1 FROM "public"."assignment_due_date_exceptions" adde
    WHERE (student_id = adde.student_id OR assignment_group_id = adde.assignment_group_id)
    AND assignment_id = adde.assignment_id AND class_id = adde.class_id AND adde.hours < 0
   )
);

CREATE OR REPLACE FUNCTION public.assignments_grader_config_auto_populate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
    declare 
    rubric_id int;
    self_rubric_id int;
    begin
  
  INSERT INTO autograder (id, class_id) VALUES (NEW.id, NEW.class_id);
  INSERT INTO autograder_regression_test (autograder_id,repository) VALUES (NEW.id, NEW.template_repo);
  INSERT INTO rubrics (name, class_id, assignment_id) VALUES ('Grading Rubric', NEW.class_id, NEW.id) RETURNING id into rubric_id;
  INSERT INTO rubrics (name, class_id, assignment_id) VALUES ('Self Rubric', NEW.class_id, NEW.id) RETURNING id into self_rubric_id;
  UPDATE assignments set grading_rubric_id=rubric_id WHERE id=NEW.id;
UPDATE assignments set self_review_rubric_id=self_rubric_id WHERE id=NEW.id;
  RETURN NULL;
end;$function$
;

CREATE OR REPLACE FUNCTION public.auto_assign_self_reviews(this_assignment_id bigint, this_profile_id uuid) 
RETURNS void 
LANGUAGE plpgsql 
SECURITY DEFINER
AS $$ 
DECLARE     
    this_assignment public.assignments;     
    this_group_id bigint; 
    this_self_review_setting public.self_review_settings;     
    this_net_deadline_change integer := 0;     
    this_active_submission_id bigint;     
BEGIN     
    -- Get the assignment first     
    SELECT * INTO this_assignment FROM public.assignments WHERE id = this_assignment_id;          
    
    -- Check if assignment exists     
    IF this_assignment.id IS NULL THEN         
        RETURN;     
    END IF;      
    
    -- Confirm this is a private profile for a student in this class, else abort     
    IF NOT EXISTS (         
        SELECT 1 FROM user_roles          
        WHERE private_profile_id = this_profile_id          
        AND role = 'student'
        AND class_id = this_assignment.class_id     
    ) THEN         
        RETURN;     
    END IF;      
    
    -- Get the group of the student for this assignment     
    SELECT assignment_group_id INTO this_group_id      
    FROM public.assignment_groups_members      
    WHERE profile_id = this_profile_id      
    AND class_id = this_assignment.class_id      
    AND assignment_id = this_assignment.id      
    LIMIT 1;      
    
    -- Get the self review setting     
    SELECT * INTO this_self_review_setting      
    FROM public.self_review_settings      
    WHERE id = this_assignment.self_review_setting_id;
    
    -- If self reviews are not enabled for this assignment, abort     
    IF this_self_review_setting.enabled IS NOT TRUE THEN         
        RETURN;     
    END IF;          
    
    -- If there is an existing review assignment for this student for this assignment, abort     
    IF EXISTS (         
        SELECT 1 FROM review_assignments          
        WHERE assignment_id = this_assignment.id          
        AND assignee_profile_id = this_profile_id     
    ) THEN         
        RETURN;     
    END IF;      
    
    -- Calculate the deadline offset by combining the deadline changes     
    SELECT COALESCE(SUM(hours), 0) INTO this_net_deadline_change      
    FROM public.assignment_due_date_exceptions      
    WHERE assignment_id = this_assignment.id      
    AND (student_id = this_profile_id OR assignment_group_id = this_group_id);      
    
    -- If deadline has not passed, abort     
    IF NOT (this_assignment.due_date + INTERVAL '1 hour' * this_net_deadline_change <= NOW()) THEN         
        RETURN;     
    END IF;      
    
    -- Get the active submission id for this profile     
    SELECT id INTO this_active_submission_id      
    FROM public.submissions      
    WHERE profile_id = this_profile_id      
    AND assignment_id = this_assignment.id
    AND is_active = TRUE     
    LIMIT 1;      
    
    -- If active submission does not exist, abort     
    IF this_active_submission_id IS NULL THEN         
        RETURN;     
    END IF;          
    
    INSERT INTO review_assignments (         
        due_date,         
        assignee_profile_id,         
        submission_id,         
        assignment_id,         
        rubric_id,         
        class_id,   
    )     
    VALUES (         
        this_assignment.due_date + INTERVAL '1 hour' * this_net_deadline_change + INTERVAL '1 hour' * this_self_review_setting.deadline_offset,
        this_profile_id,         
        this_active_submission_id,         
        this_assignment.id,         
        this_assignment.self_review_rubric_id,         
        this_assignment.class_id,
    ); 
END; 
$$;

ALTER FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) OWNER TO "postgres";

GRANT ALL ON FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) TO "anon";
GRANT ALL ON FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_assign_self_reviews"(this_assignment_id bigint, this_profile_id uuid) TO "service_role";

CREATE OR REPLACE FUNCTION auto_assign_self_reviews_trigger()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    PERFORM auto_assign_self_reviews(NEW.assignment_id, NEW.student_id);
    RETURN NEW;
END;
$$;

CREATE TRIGGER self_review_insert_after_student_finish 
AFTER INSERT ON public.assignment_due_date_exceptions 
FOR EACH ROW
EXECUTE FUNCTION auto_assign_self_reviews_trigger();


CREATE OR REPLACE FUNCTION check_assignment_deadlines_passed()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE 
    recent_assignment public.assignments;
    profile_record public.profiles;
BEGIN
    -- Loop through recent assignments
    FOR recent_assignment IN (
        SELECT * FROM assignments
        WHERE due_date <= NOW()  -- add 1 for flexibility in case someone turns in close to deadline to ensure captured
          AND due_date + INTERVAL '1 hour' * (max_late_tokens * 24 + 1) >= NOW()
    ) LOOP
        
         -- For each assignment, get all profiles for the class that assignment is for
        FOR profile_record IN (
            SELECT * FROM public.profiles prof
            WHERE is_private_profile = true
            AND recent_assignment.class_id = class_id
            AND EXISTS (
                SELECT 1 FROM user_roles WHERE private_profile_id = prof.id AND "role" = 'student'
            )
        ) LOOP
            -- Call the auto_assign_self_reviews function for each assignment x profile combination
            PERFORM auto_assign_self_reviews(recent_assignment.id, profile_record.id);
            
        END LOOP;
        
    END LOOP;
END;
$$;

create extension pg_cron with schema pg_catalog;

grant usage on schema cron to postgres; grant all privileges on all tables in schema cron to postgres;

-- schedule function to run every minute
SELECT cron.schedule('check_assignment_deadlines_passed', '* * * * *', 'SELECT check_assignment_deadlines_passed();');

-- special case to consider: professor gives student an extension that is greater than the maximum number of 
-- late days for this assignment.  this will never trigger the function to be called 
-- -> could have a separate trigger for iterating through exceptions for dates that have passed in the hour or something 
-- to account for the super long extensions
