CREATE TABLE "public"."self_review_settings" (
    "id" bigint generated by default as identity not null,
    "enabled" boolean not null default false,
    "deadline_offset" bigint,
    "allow_early" boolean,
    "class_id" bigint not null 
);

ALTER TABLE "public"."self_review_settings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "anyone in the course can view self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR SELECT
USING (
    authorizeforclassinstructor(class_id) OR authorizeforclassgrader(class_id) 
    OR authorizeforclass(class_id)
);

CREATE POLICY "instructors can insert self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR INSERT
WITH CHECK (
    authorizeforclassinstructor(class_id)
);

CREATE POLICY "instructors can update self review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR UPDATE
USING (
    authorizeforclassinstructor(class_id) 
);

CREATE POLICY "instructors can delete review settings" 
ON "public"."self_review_settings"
AS PERMISSIVE
FOR DELETE
USING (
    authorizeforclassinstructor(class_id)
);

ALTER TABLE ONLY "public"."self_review_settings"
    ADD CONSTRAINT "self_review_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE "public"."self_review_settings"
    ADD CONSTRAINT "self_review_settings_class_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."classes"("id");

ALTER TABLE "public"."assignments" ADD COLUMN "self_review_setting_id" bigint NOT NULL;

ALTER TABLE "public"."assignments"
    ADD CONSTRAINT "assignments_self_review_setting_fkey" FOREIGN KEY ("self_review_setting_id") REFERENCES "public"."self_review_settings"("id");

CREATE POLICY "Students can give themselves negative deadline exceptions"
ON "public"."assignment_due_date_exceptions"
AS PERMISSIVE 
FOR INSERT
WITH CHECK (
   "hours" < 0 
);

CREATE POLICY "Deadline exceptions never inserted after early finish"
ON "public"."assignment_due_date_exceptions"
AS RESTRICTIVE 
FOR INSERT
WITH CHECK (
   NOT EXISTS (
    SELECT 1 FROM "public"."assignment_due_date_exceptions" adde
    WHERE (student_id = adde.student_id OR assignment_group_id = adde.assignment_group_id)
    AND assignment_id = adde.assignment_id AND class_id = adde.class_id AND adde.hours < 0
   )
);

CREATE OR REPLACE FUNCTION public.assignments_grader_config_auto_populate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
    declare 
    rubric_id int;
    self_rubric_id int;
    begin
  
  INSERT INTO autograder (id, class_id) VALUES (NEW.id, NEW.class_id);
  INSERT INTO autograder_regression_test (autograder_id,repository) VALUES (NEW.id, NEW.template_repo);
  INSERT INTO rubrics (name, class_id, assignment_id) VALUES ('Grading Rubric', NEW.class_id, NEW.id) RETURNING id into rubric_id;
  INSERT INTO rubrics (name, class_id, assignment_id) VALUES ('Self Rubric', NEW.class_id, NEW.id) RETURNING id into self_rubric_id;
  UPDATE assignments set grading_rubric_id=rubric_id WHERE id=NEW.id;
UPDATE assignments set self_review_rubric_id=self_rubric_id WHERE id=NEW.id;
  RETURN NULL;
end;$function$
;

CREATE OR REPLACE FUNCTION auto_assign_self_reviews()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO review_assignments (
        due_date,
        assignee_profile_id,
        submission_id,
        assignment_id,
        rubric_id,
        class_id
    )
    SELECT 
        -- due_date: if there is a exception, use that. else, use regular assignment due date.  add hour offset.
        CASE 
            WHEN ade.hours IS NOT NULL THEN a.due_date + INTERVAL '1 hour' * ade.hours + INTERVAL '1 hour' * srs.deadline_offset
            ELSE a.due_date + INTERVAL '1 hour' * srs.deadline_offset
        END as due_date,
        -- assignee_profile_id: private profile id is assigned  
        p.id as assignee_profile_id,
        -- submission_id: find the id of the active submission for this profile 
        (
            SELECT s.id 
            FROM submissions s 
            WHERE s.profile_id = p.id 
            AND s.is_active = TRUE 
            LIMIT 1
        ) as submission_id,
        -- assignment_id: any assignment that has unassigned self reviews that are now needed
        a.id as assignment_id,
        -- rubric_id: the self review rubric of the assignment 
        a.self_review_rubric_id,
        -- class_id: the class id of the assignment 
        a.class_id
    FROM assignments a -- for each assignment x profile combination
    CROSS JOIN profiles p 
    LEFT JOIN assignment_due_date_exceptions ade ON (  -- grab any exceptions for this profile for this assignment -- whether they're the student or in the group
        ade.assignment_id = a.id 
        AND 
        (ade.student_id = p.id OR (SELECT "assignment_group_id" FROM public.assignment_groups_members WHERE profile_id = p.id LIMIT 1) - ade.assignment_group_id)
    )
    JOIN self_review_settings srs ON srs.id = a.self_review_setting_id -- grab the self review settings for assignment a
    WHERE -- determine whether this profile needs a review assignment created for this programming assignment based on the following conditions:
        -- Profile conditions: only use profiles that are private, for the class of the programming assignment, and students
        p.is_private_profile = TRUE
        AND p.class_id = a.class_id
        AND EXISTS (
            SELECT 1 FROM user_roles urs 
            WHERE urs.private_profile_id = p.id 
            AND urs.role = 'student' 
        )
        -- Self review settings must be enabled
        AND srs.enabled = true
        -- There should not be an existing self review assignment for this profile on this assignment
        AND NOT EXISTS (
            SELECT 1 FROM review_assignments ra 
            WHERE ra.assignment_id = a.id 
            AND ra.assignee_profile_id = p.id
        )
        -- Assignment deadline has passed (either regular due date or exception due date)
        AND (
            -- Case 1: No exception exists, use regular due date
            (ade.student_id IS NULL AND a.due_date <= NOW())
            OR
            -- Case 2: Exception exists, use exception due date ** TODO: right now there could be multiple due date exceptions floating around.  is this handled?
            (ade.student_id IS NOT NULL AND a.due_date + INTERVAL '1 hour' * ade.hours <= NOW())
        );

END;
$$;

CREATE OR REPLACE FUNCTION auto_assign_self_reviews_trigger()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    PERFORM auto_assign_self_reviews();
    RETURN NEW;
END;
$$;


CREATE TRIGGER self_review_insert_after_student_finish 
AFTER INSERT ON public.assignment_due_date_exceptions 
FOR EACH ROW
EXECUTE FUNCTION auto_assign_self_reviews_trigger();

