-- Create async GitHub worker infrastructure
-- 1) Ensure queue exists
select pgmq.create('async_calls');

-- Enum for async call methods
do $$ begin
  if not exists (select 1 from pg_type where typname = 'github_async_method') then
    create type public.github_async_method as enum (
      'sync_student_team',
      'sync_staff_team',
      'create_repo',
      'sync_repo_permissions',
      'archive_repo_and_lock'
    );
  end if;
end $$;

-- 2) Logging table for API Gateway calls
create table if not exists public.api_gateway_calls (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  method public.github_async_method not null,
  status_code integer not null,
  class_id bigint null references public.classes(id) on delete set null,
  debug_id text null,
  latency_ms integer null,
  message_enqueued_at timestamptz null
);

alter table public.api_gateway_calls enable row level security;

-- Tighten grants; RLS will also apply
revoke all on table public.api_gateway_calls from anon, authenticated;
grant insert, select on table public.api_gateway_calls to service_role;

-- Indexes
create index if not exists api_gateway_calls_class_created_idx on public.api_gateway_calls using btree (class_id, created_at desc);
create index if not exists api_gateway_calls_errors_partial_idx on public.api_gateway_calls using btree (class_id, created_at desc) where status_code >= 500;

-- RLS policies for service_role only
drop policy if exists api_gateway_calls_service_role_select on public.api_gateway_calls;
create policy api_gateway_calls_service_role_select on public.api_gateway_calls for select to service_role using (true);
drop policy if exists api_gateway_calls_service_role_insert on public.api_gateway_calls;
create policy api_gateway_calls_service_role_insert on public.api_gateway_calls for insert to service_role with check (true);

-- 3) RPC to record a call metric (used by edge worker)
create or replace function public.log_api_gateway_call(
  p_method text,
  p_status_code integer,
  p_class_id bigint default null,
  p_debug_id text default null,
  p_message_enqueued_at timestamptz default null,
  p_latency_ms integer default null
) returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.api_gateway_calls(method, status_code, class_id, debug_id, message_enqueued_at, latency_ms)
  values (p_method::public.github_async_method, p_status_code, p_class_id, p_debug_id, p_message_enqueued_at, p_latency_ms);
end;
$$;

revoke all on function public.log_api_gateway_call(text, integer, bigint, text, timestamptz, integer) from public;
grant execute on function public.log_api_gateway_call(text, integer, bigint, text, timestamptz, integer) to service_role;

-- 4) Enqueue helpers for async calls
-- Envelope: { method: text, args: jsonb, class_id: bigint, debug_id: text }

create or replace function public.enqueue_github_create_repo(
  p_class_id bigint,
  p_org text,
  p_repo_name text,
  p_template_repo text,
  p_course_slug text,
  p_github_usernames text[],
  p_is_template_repo boolean default false,
  p_debug_id text default null
) returns bigint
language sql
security definer
set search_path = public
as $$
  select pgmq_public.send(
    'async_calls',
    jsonb_build_object(
      'method', 'create_repo',
      'class_id', p_class_id,
      'debug_id', p_debug_id,
      'args', jsonb_build_object(
        'org', p_org,
        'repoName', p_repo_name,
        'templateRepo', p_template_repo,
        'isTemplateRepo', p_is_template_repo,
        'courseSlug', p_course_slug,
        'githubUsernames', p_github_usernames
      )
    )
  );
$$;

revoke all on function public.enqueue_github_create_repo(bigint, text, text, text, text, text[], boolean, text) from public;
grant execute on function public.enqueue_github_create_repo(bigint, text, text, text, text, text[], boolean, text) to service_role;

create or replace function public.enqueue_github_sync_student_team(
  p_class_id bigint,
  p_org text,
  p_course_slug text,
  p_debug_id text default null
) returns bigint
language sql
security definer
set search_path = public
as $$
  select pgmq_public.send(
    'async_calls',
    jsonb_build_object(
      'method', 'sync_student_team',
      'class_id', p_class_id,
      'debug_id', p_debug_id,
      'args', jsonb_build_object(
        'org', p_org,
        'courseSlug', p_course_slug
      )
    )
  );
$$;

revoke all on function public.enqueue_github_sync_student_team(bigint, text, text, text) from public;
grant execute on function public.enqueue_github_sync_student_team(bigint, text, text, text) to service_role;

create or replace function public.enqueue_github_sync_staff_team(
  p_class_id bigint,
  p_org text,
  p_course_slug text,
  p_debug_id text default null
) returns bigint
language sql
security definer
set search_path = public
as $$
  select pgmq_public.send(
    'async_calls',
    jsonb_build_object(
      'method', 'sync_staff_team',
      'class_id', p_class_id,
      'debug_id', p_debug_id,
      'args', jsonb_build_object(
        'org', p_org,
        'courseSlug', p_course_slug
      )
    )
  );
$$;

revoke all on function public.enqueue_github_sync_staff_team(bigint, text, text, text) from public;
grant execute on function public.enqueue_github_sync_staff_team(bigint, text, text, text) to service_role;

create or replace function public.enqueue_github_sync_repo_permissions(
  p_class_id bigint,
  p_org text,
  p_repo text,
  p_course_slug text,
  p_github_usernames text[],
  p_debug_id text default null
) returns bigint
language sql
security definer
set search_path = public
as $$
  select pgmq_public.send(
    'async_calls',
    jsonb_build_object(
      'method', 'sync_repo_permissions',
      'class_id', p_class_id,
      'debug_id', p_debug_id,
      'args', jsonb_build_object(
        'org', p_org,
        'repo', p_repo,
        'courseSlug', p_course_slug,
        'githubUsernames', p_github_usernames
      )
    )
  );
$$;

revoke all on function public.enqueue_github_sync_repo_permissions(bigint, text, text, text, text[], text) from public;
grant execute on function public.enqueue_github_sync_repo_permissions(bigint, text, text, text, text[], text) to service_role;

create or replace function public.enqueue_github_archive_repo(
  p_class_id bigint,
  p_org text,
  p_repo text,
  p_debug_id text default null
) returns bigint
language sql
security definer
set search_path = public
as $$
  select pgmq_public.send(
    'async_calls',
    jsonb_build_object(
      'method', 'archive_repo_and_lock',
      'class_id', p_class_id,
      'debug_id', p_debug_id,
      'args', jsonb_build_object(
        'org', p_org,
        'repo', p_repo
      )
    )
  );
$$;

revoke all on function public.enqueue_github_archive_repo(bigint, text, text, text) from public;
grant execute on function public.enqueue_github_archive_repo(bigint, text, text, text) to service_role;

-- 5) Metrics aggregation RPC for async worker
-- Returns per-class, per-method counts and recent (last hour) error rate and avg latency
create or replace function public.get_async_github_metrics()
returns table (
  class_id bigint,
  method text,
  calls_total bigint,
  errors_total bigint,
  errors_recent_1h bigint,
  avg_latency_ms numeric
)
language sql
security definer
set search_path = public
as $$
  select
    class_id,
    method::text as method,
    count(*)::bigint as calls_total,
    count(*) filter (where status_code >= 500) ::bigint as errors_total,
    count(*) filter (where status_code >= 500 and created_at >= now() - interval '1 hour') ::bigint as errors_recent_1h,
    avg(latency_ms)::numeric as avg_latency_ms
  from public.api_gateway_calls
  group by class_id, method;
$$;

revoke all on function public.get_async_github_metrics() from public;
grant execute on function public.get_async_github_metrics() to service_role, anon, authenticated;

-- 6) Replace edge function invocations with enqueue RPCs for team sync
create or replace function public.sync_staff_github_team(class_id integer)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_slug text;
  v_org text;
begin
  if class_id is null then
    raise warning 'sync_staff_github_team called with NULL class_id, skipping';
    return;
  end if;
  if auth.uid() is not null and not public.authorizeforclassinstructor(class_id::bigint) then
    raise exception 'Access denied: Only instructors can sync staff GitHub team for class %', class_id;
  end if;
  select slug, github_org into v_slug, v_org from public.classes where id = class_id;
  if v_slug is null or v_org is null then
    raise exception 'Class not found or missing org/slug for class %', class_id;
  end if;
  perform public.enqueue_github_sync_staff_team(class_id::bigint, v_org, v_slug, null);
end;
$$;


create or replace function public.sync_student_github_team(class_id integer)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_slug text;
  v_org text;
begin
  if class_id is null then
    raise warning 'sync_student_github_team called with NULL class_id, skipping';
    return;
  end if;
  if auth.uid() is not null and not public.authorizeforclassinstructor(class_id::bigint) then
    raise exception 'Access denied: Only instructors can sync student GitHub team for class %', class_id;
  end if;
  select slug, github_org into v_slug, v_org from public.classes where id = class_id;
  if v_slug is null or v_org is null then
    raise exception 'Class not found or missing org/slug for class %', class_id;
  end if;
  perform public.enqueue_github_sync_student_team(class_id::bigint, v_org, v_slug, null);
end;
$$;

-- 7) Replace create_all_repos_for_assignment to enqueue create_repo jobs (non-batch abstraction)
-- Clean up legacy overloads to avoid ambiguity
drop function if exists public.create_all_repos_for_assignment(bigint, bigint);
drop function if exists public.create_all_repos_for_assignment(integer, integer);

create or replace function public.create_all_repos_for_assignment(course_id bigint, assignment_id bigint, p_force boolean default false)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_course_id bigint := course_id;
  v_assignment_id bigint := assignment_id;
  v_slug text;
  v_org text;
  v_template_repo text;
  v_group_config text;
  v_assignment_slug text;
  r_user_id uuid;
  r_username text;
  r_group_id bigint;
  r_group_name text;
  r_members text[];
begin
  raise notice 'Enqueue create_all_repos_for_assignment course_id=%, assignment_id=%, force=%', v_course_id, v_assignment_id, p_force;
  if v_course_id is null or v_assignment_id is null then
    raise warning 'create_all_repos_for_assignment called with NULL parameters, skipping';
    return;
  end if;

  -- Only instructors (manual) or service role may enable force
  if auth.uid() is not null and not public.authorizeforclassinstructor(v_course_id::bigint) then
    raise exception 'Access denied: Only instructors can force-create repos for class %', v_course_id;
  end if;

  select c.slug, c.github_org, a.template_repo, a.group_config, a.slug
  into v_slug, v_org, v_template_repo, v_group_config, v_assignment_slug
  from public.assignments a
  join public.classes c on c.id = a.class_id
  where a.id = v_assignment_id and a.class_id = v_course_id;

  if v_slug is null or v_org is null or v_template_repo is null or v_template_repo = '' then
    raise exception 'Invalid class/assignment or missing template repo (class_id %, assignment_id %)', course_id, assignment_id;
  end if;

  raise notice 'Resolved org=%, slug=%, template=%', v_org, v_slug, v_template_repo;

  -- Enqueue individual repos for students not in groups; if p_force, enqueue even if repo exists
  for r_user_id, r_username in
    select ur.user_id, u.github_username
    from public.user_roles ur
    join public.users u on u.user_id = ur.user_id
    where ur.class_id = v_course_id
      and ur.role = 'student'
      and u.github_username is not null
      and not exists (
        select 1 from public.assignment_groups_members agm
        join public.assignment_groups ag on ag.id = agm.assignment_group_id
        where ag.assignment_id = v_assignment_id and agm.profile_id = ur.private_profile_id
      )
      and (
        p_force
        or not exists (
          select 1 from public.repositories r
          where r.assignment_id = v_assignment_id and r.profile_id = ur.private_profile_id
        )
      )
  loop
    raise notice 'Enqueue individual repo: %/%', v_org, v_slug || '-' || v_assignment_slug || '-' || r_username;
    perform public.enqueue_github_create_repo(
      v_course_id,
      v_org,
      v_slug || '-' || v_assignment_slug || '-' || r_username,
      v_template_repo,
      v_slug,
      array[r_username],
      false,
      null
    );
  end loop;

  -- Enqueue group repos; if p_force, enqueue even if repo exists (worker will sync permissions)
  for r_group_id, r_group_name, r_members in
    select ag.id as group_id,
           ag.name as group_name,
           array_remove(array_agg(u.github_username), null) as members
    from public.assignment_groups ag
    left join public.assignment_groups_members agm on agm.assignment_group_id = ag.id
    left join public.user_roles ur on ur.private_profile_id = agm.profile_id
    left join public.users u on u.user_id = ur.user_id
    where ag.assignment_id = v_assignment_id
      and (
        p_force
        or not exists (
          select 1 from public.repositories r where r.assignment_group_id = ag.id
        )
      )
    group by ag.id, ag.name
  loop
    raise notice 'Enqueue group repo: %/%', v_org, v_slug || '-' || v_assignment_slug || '-group-' || r_group_name;
    perform public.enqueue_github_create_repo(
      v_course_id,
      v_org,
      v_slug || '-' || v_assignment_slug || '-group-' || r_group_name,
      v_template_repo,
      v_slug,
      r_members,
      false,
      null
    );
  end loop;
end;
$$;

-- overload for integer parameters kept for compatibility
create or replace function public.create_all_repos_for_assignment(course_id integer, assignment_id integer, p_force boolean default false)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  perform public.create_all_repos_for_assignment(course_id::bigint, assignment_id::bigint, p_force);
end;
$$;

-- 8) Replace create_repos_for_student to enqueue per-assignment create_repo (non-batch)
create or replace function public.create_repos_for_student(user_id uuid, class_id integer default null, p_force boolean default false)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_username text;
  v_slug text;
  v_org text;
begin
  if user_id is null then
    raise warning 'create_repos_for_student called with NULL user_id, skipping';
    return;
  end if;

  select github_username into v_username from public.users where user_id = user_id;
  if v_username is null or v_username = '' then
    raise exception 'User % has no GitHub username linked', user_id;
  end if;

  if p_force then
    -- If called manually (auth present), require instructor for the target class. If class_id is null, forbid for non-service callers.
    if auth.uid() is not null then
      if class_id is null then
        raise exception 'Force create for all classes requires service role';
      end if;
      if not public.authorizeforclassinstructor(class_id::bigint) then
        raise exception 'Access denied: Only instructors can force-create repos for class %', class_id;
      end if;
    end if;
  end if;

  for
    select a.id as assignment_id, a.slug as assignment_slug, a.template_repo, c.id as course_id, c.slug as course_slug, c.github_org
    from public.assignments a
    join public.classes c on c.id = a.class_id
    join public.user_roles ur on ur.class_id = c.id
    where ur.user_id = user_id
      and (class_id is null or c.id = class_id)
      and a.template_repo is not null and a.template_repo <> ''
      and a.group_config <> 'groups'
      and (
        p_force
        or not exists (
          select 1 from public.repositories r
          join public.profiles p on p.id = r.profile_id
          where r.assignment_id = a.id and p.user_id = user_id
        )
      )
  loop
    perform public.enqueue_github_create_repo(
      course_id,
      github_org,
      course_slug || '-' || assignment_slug || '-' || v_username,
      template_repo,
      course_slug,
      array[v_username],
      false,
      null
    );
  end loop;
end;
$$;


