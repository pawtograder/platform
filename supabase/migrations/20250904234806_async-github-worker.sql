-- Create async GitHub worker infrastructure
-- 1) Ensure queue exists
do $$
begin
  perform pgmq.create('async_calls');
exception when others then
  -- queue likely exists; ignore
  null;
end $$;


-- Enum for async call methods
do $$ begin
  if not exists (select 1 from pg_type where typname = 'github_async_method') then
    create type public.github_async_method as enum (
      'sync_student_team',
      'sync_staff_team',
      'create_repo',
      'sync_repo_permissions',
      'archive_repo_and_lock'
    );
  end if;
end $$;

-- 2) Logging table for API Gateway calls
create table if not exists public.api_gateway_calls (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  method public.github_async_method not null,
  status_code integer not null,
  class_id bigint null references public.classes(id) on delete set null,
  debug_id text null,
  latency_ms integer null,
  message_processed_at timestamptz null
);

alter table public.api_gateway_calls enable row level security;

-- Tighten grants; RLS will also apply
revoke all on table public.api_gateway_calls from anon, authenticated;
grant insert, select on table public.api_gateway_calls to service_role;

-- Indexes
create index if not exists api_gateway_calls_class_created_idx on public.api_gateway_calls using btree (class_id, created_at desc);
create index if not exists api_gateway_calls_errors_partial_idx on public.api_gateway_calls using btree (class_id, created_at desc) where status_code >= 500;

-- RLS policies for service_role only
drop policy if exists api_gateway_calls_service_role_select on public.api_gateway_calls;
create policy api_gateway_calls_service_role_select on public.api_gateway_calls for select to service_role using (true);
drop policy if exists api_gateway_calls_service_role_insert on public.api_gateway_calls;
create policy api_gateway_calls_service_role_insert on public.api_gateway_calls for insert to service_role with check (true);

-- 3) RPC to record a call metric (used by edge worker)
create or replace function public.log_api_gateway_call(
  p_method text,
  p_status_code integer,
  p_class_id bigint default null,
  p_debug_id text default null,
  p_message_processed_at timestamptz default null,
  p_latency_ms integer default null
) returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.api_gateway_calls(method, status_code, class_id, debug_id, message_processed_at, latency_ms)
  values (p_method::public.github_async_method, p_status_code, p_class_id, p_debug_id, p_message_processed_at, p_latency_ms);
end;
$$;

-- 9) Background invoker and cron schedule for the GitHub async worker
create or replace function public.invoke_github_async_worker_background_task()
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  queue_size integer;
  worker_count integer;
  i integer;
  message_count integer;
  open_circuits integer;
begin
  -- Check if there are at least 50 messages by reading 50 with 0 expiration
  -- Messages automatically become available again immediately with 0 expiration
  select count(*)::integer into message_count from pgmq_public.read('async_calls', 0, 50);
  
  -- If we got 50 messages, there are at least 50 (could be more)
  -- If we got fewer, that's the actual count
  if message_count = 50 then
    queue_size := 30; -- At least 30, could be more
  else
    queue_size := message_count; -- Exact count
  end if;
  
  -- Determine number of workers based on queue size
  if queue_size >= 20 then
    worker_count := 20;
    raise notice 'High queue load detected (% messages), starting % workers', queue_size, worker_count;
  elsif queue_size >= 10 then
    worker_count := 10;
    raise notice 'Moderate queue load detected (% messages), starting % workers', queue_size, worker_count;
  else
    worker_count := 2;
    raise notice 'Normal queue load (% messages), starting % workers', queue_size, worker_count;
  end if;
  
  -- If any circuit is OPEN, cap worker count to 1 to mass-slowdown
  select count(*)::integer into open_circuits
  from public.github_circuit_breakers
  where state = 'open' and (open_until is null or open_until > now());
  if open_circuits > 0 then
    worker_count := 1;
    raise notice 'Circuit breaker active (% open). Capping workers to %', open_circuits, worker_count;
  end if;
  
  -- Start workers dynamically
  for i in 1..worker_count loop
    perform public.call_edge_function_internal(
      '/functions/v1/github-async-worker',
      'POST',
      '{"Content-type":"application/json","x-supabase-webhook-source":"github-async-worker"}'::jsonb,
      '{}'::jsonb,
      3000,
      null, null, null, null, null
    );
  end loop;
end;
$$;

revoke all on function public.invoke_github_async_worker_background_task() from public;
grant execute on function public.invoke_github_async_worker_background_task() to service_role;

-- 3b) Circuit breaker store and RPCs
create table if not exists public.github_circuit_breakers (
  scope text not null,
  key text not null,
  state text not null default 'closed', -- 'open' | 'half_open' | 'closed'
  open_until timestamptz null,
  last_reason text null,
  updated_at timestamptz not null default now(),
  primary key (scope, key)
);

alter table public.github_circuit_breakers enable row level security;
revoke all on table public.github_circuit_breakers from anon, authenticated;
grant select, insert, update on table public.github_circuit_breakers to service_role;

drop policy if exists github_circuit_breakers_srv_select on public.github_circuit_breakers;
create policy github_circuit_breakers_srv_select on public.github_circuit_breakers for select to service_role using (true);
drop policy if exists github_circuit_breakers_srv_mod on public.github_circuit_breakers;
create policy github_circuit_breakers_srv_mod on public.github_circuit_breakers for all to service_role using (true) with check (true);

-- Events table to count circuit breaker trips
create table if not exists public.github_circuit_breaker_events (
  id bigint generated by default as identity primary key,
  scope text not null,
  key text not null,
  reason text null,
  opened_at timestamptz not null default now()
);

alter table public.github_circuit_breaker_events enable row level security;
revoke all on table public.github_circuit_breaker_events from anon, authenticated;
grant select, insert on table public.github_circuit_breaker_events to service_role;

drop policy if exists github_circuit_breaker_events_srv_select on public.github_circuit_breaker_events;
create policy github_circuit_breaker_events_srv_select on public.github_circuit_breaker_events for select to service_role using (true);
drop policy if exists github_circuit_breaker_events_srv_insert on public.github_circuit_breaker_events;
create policy github_circuit_breaker_events_srv_insert on public.github_circuit_breaker_events for insert to service_role with check (true);

-- Add trip_count for breaker trip tracking
do $$ begin
  if not exists (
    select 1 from information_schema.columns
    where table_schema = 'public' and table_name = 'github_circuit_breakers' and column_name = 'trip_count'
  ) then
    alter table public.github_circuit_breakers add column trip_count integer not null default 0;
  end if;
end $$;

create or replace function public.open_github_circuit(
  p_scope text,
  p_key text,
  p_open_for_seconds integer,
  p_reason text default null
) returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  v_row public.github_circuit_breakers%rowtype;
  v_seconds integer := greatest(1, p_open_for_seconds);
  v_trip_count integer;
begin
  select * into v_row from public.github_circuit_breakers where scope = p_scope and key = p_key for update;

  if not found then
    insert into public.github_circuit_breakers(scope, key, state, open_until, last_reason, updated_at, trip_count)
    values (p_scope, p_key, 'open', now() + make_interval(secs => v_seconds), p_reason, now(), 1);
    v_trip_count := 1;
  else
    if v_row.state = 'open' and (v_row.open_until is null or v_row.open_until > now()) then
      v_trip_count := v_row.trip_count + 1;
      if v_trip_count >= 3 then
        v_row.open_until := now() + interval '24 hours';
      else
        -- Exponential increase when tripped again during the open window
        v_seconds := least(43200, v_seconds * 2);
        v_row.open_until := greatest(v_row.open_until, now() + make_interval(secs => v_seconds));
      end if;
    else
      v_trip_count := 1;
      v_row.open_until := now() + make_interval(secs => v_seconds);
      v_row.state := 'open';
    end if;
    update public.github_circuit_breakers
      set state = v_row.state,
          open_until = v_row.open_until,
          last_reason = coalesce(p_reason, v_row.last_reason),
          updated_at = now(),
          trip_count = v_trip_count
      where scope = p_scope and key = p_key;
  end if;

  insert into public.github_circuit_breaker_events(scope, key, reason)
  values (p_scope, p_key, coalesce(p_reason, 'unspecified'));

  return (select trip_count from public.github_circuit_breakers where scope = p_scope and key = p_key);
end;
$$;

revoke all on function public.open_github_circuit(text, text, integer, text) from public;
grant execute on function public.open_github_circuit(text, text, integer, text) to service_role;

create or replace function public.get_github_circuit(
  p_scope text,
  p_key text
) returns table(state text, open_until timestamptz)
language sql
security definer
set search_path = public
as $$
  select c.state, c.open_until from public.github_circuit_breakers c where c.scope = p_scope and c.key = p_key;
$$;

revoke all on function public.get_github_circuit(text, text) from public;
grant execute on function public.get_github_circuit(text, text) to service_role;

-- Idempotent cron schedule: drop if exists, then create
select cron.unschedule('invoke-github-async-worker-every-minute')
where exists (select 1 from cron.job where jobname = 'invoke-github-async-worker-every-minute');
select cron.schedule(
  'invoke-github-async-worker-every-minute',
  '* * * * *',
  $$select public.invoke_github_async_worker_background_task();$$
);

revoke all on function public.log_api_gateway_call(text, integer, bigint, text, timestamptz, integer) from public;
grant execute on function public.log_api_gateway_call(text, integer, bigint, text, timestamptz, integer) to service_role;

-- Function to update log record by ID
create or replace function public.update_api_gateway_call(
  p_log_id bigint,
  p_status_code integer,
  p_latency_ms integer default null
) returns void
language sql
security definer
set search_path = public
as $$
  update public.api_gateway_calls
  set status_code = p_status_code,
      latency_ms = p_latency_ms,
      message_processed_at = now()
  where id = p_log_id;
$$;

revoke all on function public.update_api_gateway_call(bigint, integer, integer) from public;
grant execute on function public.update_api_gateway_call(bigint, integer, integer) to service_role;

-- 4) Enqueue helpers for async calls
-- Envelope: { method: text, args: jsonb, class_id: bigint, debug_id: text }

create or replace function public.enqueue_github_create_repo(
  p_class_id bigint,
  p_org text,
  p_repo_name text,
  p_template_repo text,
  p_course_slug text,
  p_github_usernames text[],
  p_is_template_repo boolean default false,
  p_debug_id text default null
) returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  log_id bigint;
  message_id bigint;
begin
  -- Insert log record first
  insert into public.api_gateway_calls(method, status_code, class_id, debug_id)
  values ('create_repo', 0, p_class_id, p_debug_id)
  returning id into log_id;
  
  -- Enqueue message with log_id
  select pgmq_public.send(
    'async_calls',
    jsonb_build_object(
      'method', 'create_repo',
      'class_id', p_class_id,
      'debug_id', p_debug_id,
      'log_id', log_id,
      'args', jsonb_build_object(
        'org', p_org,
        'repoName', p_repo_name,
        'templateRepo', p_template_repo,
        'isTemplateRepo', p_is_template_repo,
        'courseSlug', p_course_slug,
        'githubUsernames', p_github_usernames
      )
    )
  ) into message_id;
  
  return message_id;
end;
$$;

revoke all on function public.enqueue_github_create_repo(bigint, text, text, text, text, text[], boolean, text) from public;
grant execute on function public.enqueue_github_create_repo(bigint, text, text, text, text, text[], boolean, text) to service_role;

create or replace function public.enqueue_github_sync_student_team(
  p_class_id bigint,
  p_org text,
  p_course_slug text,
  p_debug_id text default null
) returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  log_id bigint;
  message_id bigint;
begin
  -- Insert log record first
  insert into public.api_gateway_calls(method, status_code, class_id, debug_id)
  values ('sync_student_team', 0, p_class_id, p_debug_id)
  returning id into log_id;
  
  -- Enqueue message with log_id
  select pgmq_public.send(
    'async_calls',
    jsonb_build_object(
      'method', 'sync_student_team',
      'class_id', p_class_id,
      'debug_id', p_debug_id,
      'log_id', log_id,
      'args', jsonb_build_object(
        'org', p_org,
        'courseSlug', p_course_slug
      )
    )
  ) into message_id;
  
  return message_id;
end;
$$;

revoke all on function public.enqueue_github_sync_student_team(bigint, text, text, text) from public;
grant execute on function public.enqueue_github_sync_student_team(bigint, text, text, text) to service_role;

create or replace function public.enqueue_github_sync_staff_team(
  p_class_id bigint,
  p_org text,
  p_course_slug text,
  p_debug_id text default null
) returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  log_id bigint;
  message_id bigint;
begin
  -- Insert log record first
  insert into public.api_gateway_calls(method, status_code, class_id, debug_id)
  values ('sync_staff_team', 0, p_class_id, p_debug_id)
  returning id into log_id;
  
  -- Enqueue message with log_id
  select pgmq_public.send(
    'async_calls',
    jsonb_build_object(
      'method', 'sync_staff_team',
      'class_id', p_class_id,
      'debug_id', p_debug_id,
      'log_id', log_id,
      'args', jsonb_build_object(
        'org', p_org,
        'courseSlug', p_course_slug
      )
    )
  ) into message_id;
  
  return message_id;
end;
$$;

revoke all on function public.enqueue_github_sync_staff_team(bigint, text, text, text) from public;
grant execute on function public.enqueue_github_sync_staff_team(bigint, text, text, text) to service_role;

create or replace function public.enqueue_github_sync_repo_permissions(
  p_class_id bigint,
  p_org text,
  p_repo text,
  p_course_slug text,
  p_github_usernames text[],
  p_debug_id text default null
) returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  log_id bigint;
  message_id bigint;
begin
  -- Insert log record first
  insert into public.api_gateway_calls(method, status_code, class_id, debug_id)
  values ('sync_repo_permissions', 0, p_class_id, p_debug_id)
  returning id into log_id;
  
  -- Enqueue message with log_id
  select pgmq_public.send(
    'async_calls',
    jsonb_build_object(
      'method', 'sync_repo_permissions',
      'class_id', p_class_id,
      'debug_id', p_debug_id,
      'log_id', log_id,
      'args', jsonb_build_object(
        'org', p_org,
        'repo', p_repo,
        'courseSlug', p_course_slug,
        'githubUsernames', p_github_usernames
      )
    )
  ) into message_id;
  
  return message_id;
end;
$$;

revoke all on function public.enqueue_github_sync_repo_permissions(bigint, text, text, text, text[], text) from public;
grant execute on function public.enqueue_github_sync_repo_permissions(bigint, text, text, text, text[], text) to service_role;

create or replace function public.enqueue_github_archive_repo(
  p_class_id bigint,
  p_org text,
  p_repo text,
  p_debug_id text default null
) returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  log_id bigint;
  message_id bigint;
begin
  -- Insert log record first
  insert into public.api_gateway_calls(method, status_code, class_id, debug_id)
  values ('archive_repo_and_lock', 0, p_class_id, p_debug_id)
  returning id into log_id;
  
  -- Enqueue message with log_id
  select pgmq_public.send(
    'async_calls',
    jsonb_build_object(
      'method', 'archive_repo_and_lock',
      'class_id', p_class_id,
      'debug_id', p_debug_id,
      'log_id', log_id,
      'args', jsonb_build_object(
        'org', p_org,
        'repo', p_repo
      )
    )
  ) into message_id;
  
  return message_id;
end;
$$;

revoke all on function public.enqueue_github_archive_repo(bigint, text, text, text) from public;
grant execute on function public.enqueue_github_archive_repo(bigint, text, text, text) to service_role;

-- 5) Metrics aggregation RPC for async worker
-- Returns per-class, per-method counts and recent (last hour) error rate and avg latency
create or replace function public.get_async_github_metrics()
returns table (
  class_id bigint,
  method text,
  calls_total bigint,
  errors_total bigint,
  errors_recent_1h bigint,
  avg_latency_ms numeric
)
language sql
security definer
set search_path = public
as $$
  select
    class_id,
    method::text as method,
    count(*)::bigint as calls_total,
    count(*) filter (where status_code >= 500) ::bigint as errors_total,
    count(*) filter (where status_code >= 500 and created_at >= now() - interval '1 hour') ::bigint as errors_recent_1h,
    avg(latency_ms)::numeric as avg_latency_ms
  from public.api_gateway_calls
  group by class_id, method;
$$;

revoke all on function public.get_async_github_metrics() from public, anon, authenticated;
grant execute on function public.get_async_github_metrics() to service_role;

-- 5b) Recent API metrics helper (per class/method/status over a time window)
create or replace function public.get_github_api_metrics_recent(p_window_seconds integer default 3600)
returns table (
  class_id bigint,
  method text,
  status_code integer,
  calls bigint,
  avg_latency_ms numeric
)
language sql
security definer
set search_path = public
as $$
  select
    class_id,
    method::text as method,
    status_code,
    count(*)::bigint as calls,
    avg(latency_ms)::numeric as avg_latency_ms
  from public.api_gateway_calls
  where created_at >= now() - make_interval(secs => p_window_seconds)
  group by class_id, method, status_code;
$$;

revoke all on function public.get_github_api_metrics_recent(integer) from public, anon, authenticated;
grant execute on function public.get_github_api_metrics_recent(integer) to service_role;

-- 6) Replace edge function invocations with enqueue RPCs for team sync
create or replace function public.sync_staff_github_team(class_id integer)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_slug text;
  v_org text;
begin
  if class_id is null then
    raise warning 'sync_staff_github_team called with NULL class_id, skipping';
    return;
  end if;
  if auth.uid() is not null and not public.authorizeforclassinstructor(class_id::bigint) then
    raise exception 'Access denied: Only instructors can sync staff GitHub team for class %', class_id;
  end if;
  select slug, github_org into v_slug, v_org from public.classes where id = class_id;
  if v_slug is null or v_org is null then
    raise exception 'Class not found or missing org/slug for class %', class_id;
  end if;
  perform public.enqueue_github_sync_staff_team(class_id::bigint, v_org, v_slug, null);
end;
$$;


create or replace function public.sync_student_github_team(class_id integer)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_slug text;
  v_org text;
begin
  if class_id is null then
    raise warning 'sync_student_github_team called with NULL class_id, skipping';
    return;
  end if;
  if auth.uid() is not null and not public.authorizeforclassinstructor(class_id::bigint) then
    raise exception 'Access denied: Only instructors can sync student GitHub team for class %', class_id;
  end if;
  select slug, github_org into v_slug, v_org from public.classes where id = class_id;
  if v_slug is null or v_org is null then
    raise exception 'Class not found or missing org/slug for class %', class_id;
  end if;
  perform public.enqueue_github_sync_student_team(class_id::bigint, v_org, v_slug, null);
end;
$$;

-- 7) Replace create_all_repos_for_assignment to enqueue create_repo jobs (non-batch abstraction)
-- Clean up legacy overloads to avoid ambiguity
drop function if exists public.create_all_repos_for_assignment(bigint, bigint);
drop function if exists public.create_all_repos_for_assignment(integer, integer);

create or replace function public.create_all_repos_for_assignment(course_id bigint, assignment_id bigint, p_force boolean default false)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_course_id bigint := course_id;
  v_assignment_id bigint := assignment_id;
  v_slug text;
  v_org text;
  v_template_repo text;
  v_group_config text;
  v_assignment_slug text;
  r_user_id uuid;
  r_username text;
  r_group_id bigint;
  r_group_name text;
  r_members text[];
begin
  raise notice 'Enqueue create_all_repos_for_assignment course_id=%, assignment_id=%, force=%', v_course_id, v_assignment_id, p_force;
  if v_course_id is null or v_assignment_id is null then
    raise warning 'create_all_repos_for_assignment called with NULL parameters, skipping';
    return;
  end if;

  -- Only instructors (manual) or service role may enable force
  if auth.uid() is not null and not public.authorizeforclassinstructor(v_course_id::bigint) then
    raise exception 'Access denied: Only instructors can force-create repos for class %', v_course_id;
  end if;

  select c.slug, c.github_org, a.template_repo, a.group_config, a.slug
  into v_slug, v_org, v_template_repo, v_group_config, v_assignment_slug
  from public.assignments a
  join public.classes c on c.id = a.class_id
  where a.id = v_assignment_id and a.class_id = v_course_id;

  if v_slug is null or v_org is null or v_template_repo is null or v_template_repo = '' then
    raise exception 'Invalid class/assignment or missing template repo (class_id %, assignment_id %)', course_id, assignment_id;
  end if;

  raise notice 'Resolved org=%, slug=%, template=%', v_org, v_slug, v_template_repo;

  -- Enqueue individual repos for students not in groups; if p_force, enqueue even if repo exists
  for r_user_id, r_username in
    select ur.user_id, u.github_username
    from public.user_roles ur
    join public.users u on u.user_id = ur.user_id
    where ur.class_id = v_course_id
      and ur.role = 'student'
      and u.github_username is not null
      and not exists (
        select 1 from public.assignment_groups_members agm
        join public.assignment_groups ag on ag.id = agm.assignment_group_id
        where ag.assignment_id = v_assignment_id and agm.profile_id = ur.private_profile_id
      )
      and (
        p_force
        or not exists (
          select 1 from public.repositories r
          where r.assignment_id = v_assignment_id and r.profile_id = ur.private_profile_id
        )
      )
  loop
    raise notice 'Enqueue individual repo: %/%', v_org, v_slug || '-' || v_assignment_slug || '-' || r_username;
    perform public.enqueue_github_create_repo(
      v_course_id,
      v_org,
      v_slug || '-' || v_assignment_slug || '-' || r_username,
      v_template_repo,
      v_slug,
      array[r_username],
      false,
      null
    );
  end loop;

  -- Enqueue group repos; if p_force, enqueue even if repo exists (worker will sync permissions)
  for r_group_id, r_group_name, r_members in
    select ag.id as group_id,
           ag.name as group_name,
           array_remove(array_agg(u.github_username), null) as members
    from public.assignment_groups ag
    left join public.assignment_groups_members agm on agm.assignment_group_id = ag.id
    left join public.user_roles ur on ur.private_profile_id = agm.profile_id
    left join public.users u on u.user_id = ur.user_id
    where ag.assignment_id = v_assignment_id
      and (
        p_force
        or not exists (
          select 1 from public.repositories r where r.assignment_group_id = ag.id
        )
      )
    group by ag.id, ag.name
  loop
    raise notice 'Enqueue group repo: %/%', v_org, v_slug || '-' || v_assignment_slug || '-group-' || r_group_name;
    perform public.enqueue_github_create_repo(
      v_course_id,
      v_org,
      v_slug || '-' || v_assignment_slug || '-group-' || r_group_name,
      v_template_repo,
      v_slug,
      r_members,
      false,
      null
    );
  end loop;
end;
$$;

-- overload for integer parameters kept for compatibility
create or replace function public.create_all_repos_for_assignment(course_id integer, assignment_id integer, p_force boolean default false)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  perform public.create_all_repos_for_assignment(course_id::bigint, assignment_id::bigint, p_force);
end;
$$;

-- Lock down the overload wrapper with same permissions as primary function
revoke all on function public.create_all_repos_for_assignment(integer, integer, boolean) from public;
grant execute on function public.create_all_repos_for_assignment(integer, integer, boolean) to service_role;

-- 8) Replace create_repos_for_student to enqueue per-assignment create_repo (non-batch)
-- Ensure no ambiguous overload remains before creating new signature
drop function if exists public.create_repos_for_student(uuid, integer);
create or replace function public.create_repos_for_student(user_id uuid, class_id integer default null, p_force boolean default false)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_username text;
  v_slug text;
  v_org text;
  v_user_id uuid := user_id;
  v_class_id integer := class_id;
  r_assignment_id bigint;
  r_assignment_slug text;
  r_template_repo text;
  r_course_id bigint;
  r_course_slug text;
  r_github_org text;
begin
  if user_id is null then
    raise warning 'create_repos_for_student called with NULL user_id, skipping';
    return;
  end if;

  select u.github_username into v_username from public.users u where u.user_id = v_user_id;
  if v_username is null or v_username = '' then
    raise exception 'User % has no GitHub username linked', user_id;
  end if;

  if p_force then
    -- If called manually (auth present), require instructor for the target class. If class_id is null, forbid for non-service callers.
    if auth.uid() is not null then
      if class_id is null then
        raise exception 'Force create for all classes requires service role';
      end if;
      if not public.authorizeforclassinstructor(class_id::bigint) then
        raise exception 'Access denied: Only instructors can force-create repos for class %', class_id;
      end if;
    end if;
  end if;

  for r_assignment_id, r_assignment_slug, r_template_repo, r_course_id, r_course_slug, r_github_org in
    select a.id as assignment_id, a.slug as assignment_slug, a.template_repo, c.id as course_id, c.slug as course_slug, c.github_org
    from public.assignments a
    join public.classes c on c.id = a.class_id
    join public.user_roles ur on ur.class_id = c.id
    where ur.user_id = v_user_id
      and (v_class_id is null or c.id = v_class_id)
      and a.template_repo is not null and a.template_repo <> ''
      and a.group_config <> 'groups'
      and (
        p_force
        or not exists (
          select 1 from public.repositories r
          where r.assignment_id = a.id and r.profile_id = ur.private_profile_id
        )
      )
  loop
    perform public.enqueue_github_create_repo(
      r_course_id,
      r_github_org,
      r_course_slug || '-' || r_assignment_slug || '-' || v_username,
      r_template_repo,
      r_course_slug,
      array[v_username],
      false,
      null
    );
  end loop;
end;
$$;


