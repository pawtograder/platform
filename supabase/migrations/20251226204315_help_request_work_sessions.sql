-- Create table for tracking TA work sessions on help requests
create table "public"."help_request_work_sessions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "help_request_id" bigint not null,
    "class_id" bigint not null,
    "ta_profile_id" uuid not null,
    "started_at" timestamp with time zone not null default now(),
    "ended_at" timestamp with time zone,
    "queue_depth_at_start" integer,
    "longest_wait_seconds_at_start" integer,
    "notes" text
);

alter table "public"."help_request_work_sessions" enable row level security;

-- Primary key
alter table "public"."help_request_work_sessions" add constraint "help_request_work_sessions_pkey" primary key ("id");

-- Foreign keys
alter table "public"."help_request_work_sessions" add constraint "help_request_work_sessions_help_request_id_fkey" 
    foreign key ("help_request_id") references "public"."help_requests"("id") on delete cascade;

alter table "public"."help_request_work_sessions" add constraint "help_request_work_sessions_class_id_fkey" 
    foreign key ("class_id") references "public"."classes"("id") on delete cascade;

alter table "public"."help_request_work_sessions" add constraint "help_request_work_sessions_ta_profile_id_fkey" 
    foreign key ("ta_profile_id") references "public"."profiles"("id") on delete restrict;

-- Indexes for performance
create index "idx_help_request_work_sessions_help_request_id" on "public"."help_request_work_sessions" ("help_request_id");
create index "idx_help_request_work_sessions_class_id" on "public"."help_request_work_sessions" ("class_id");
create index "idx_help_request_work_sessions_ta_profile_id" on "public"."help_request_work_sessions" ("ta_profile_id");
create index "idx_help_request_work_sessions_started_at" on "public"."help_request_work_sessions" ("started_at");
create index "idx_help_request_work_sessions_ended_at" on "public"."help_request_work_sessions" ("ended_at") where "ended_at" is not null;

-- RLS Policies (fully inlined SELECT, no function calls)

-- SELECT: Any staff (instructor/grader) in the class can view work sessions
create policy "Staff can view work sessions in their class"
on "public"."help_request_work_sessions"
for select
using (
    EXISTS (
        SELECT 1
        FROM public.user_privileges up
        WHERE up.user_id = auth.uid()
            AND up.class_id = help_request_work_sessions.class_id
            AND up.role IN ('instructor', 'grader')
    )
);

-- INSERT: Any staff can create work sessions
create policy "Staff can create work sessions"
on "public"."help_request_work_sessions"
for insert
with check (
    authorizeforclassgrader(class_id)
);

-- UPDATE: TAs can update their own records, instructors can update any
create policy "TAs can update own records, instructors can update any"
on "public"."help_request_work_sessions"
for update
using (
    -- Own records check (inlined)
    ta_profile_id IN (
        SELECT up.private_profile_id
        FROM public.user_privileges up
        WHERE up.user_id = auth.uid()
            AND up.private_profile_id IS NOT NULL
        UNION
        SELECT up.public_profile_id
        FROM public.user_privileges up
        WHERE up.user_id = auth.uid()
            AND up.public_profile_id IS NOT NULL
    )
    OR
    -- Instructor check (function acceptable for UPDATE)
    authorizeforclassinstructor(class_id)
)
with check (
    -- Same checks for WITH CHECK
    ta_profile_id IN (
        SELECT up.private_profile_id
        FROM public.user_privileges up
        WHERE up.user_id = auth.uid()
            AND up.private_profile_id IS NOT NULL
        UNION
        SELECT up.public_profile_id
        FROM public.user_privileges up
        WHERE up.user_id = auth.uid()
            AND up.public_profile_id IS NOT NULL
    )
    OR
    authorizeforclassinstructor(class_id)
);

-- DELETE: Only instructors can delete work sessions
create policy "Instructors can delete work sessions"
on "public"."help_request_work_sessions"
for delete
using (
    authorizeforclassinstructor(class_id)
);

-- Function to calculate queue metrics at session start
CREATE OR REPLACE FUNCTION public.calculate_queue_metrics_at_start(
    p_help_request_id bigint,
    p_queue_id bigint
)
RETURNS TABLE(queue_depth integer, longest_wait_seconds integer)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path TO ''
AS $$
DECLARE
    v_queue_depth integer;
    v_longest_wait_seconds integer;
BEGIN
    -- Calculate queue depth: count of open/in_progress requests in the same queue
    -- excluding the current request
    SELECT COUNT(*)::integer
    INTO v_queue_depth
    FROM public.help_requests
    WHERE help_queue = p_queue_id
        AND id != p_help_request_id
        AND status IN ('open', 'in_progress');

    -- Calculate longest wait time: max seconds since creation for open requests
    SELECT COALESCE(MAX(EXTRACT(EPOCH FROM (NOW() - created_at)))::integer, 0)
    INTO v_longest_wait_seconds
    FROM public.help_requests
    WHERE help_queue = p_queue_id
        AND status = 'open';

    RETURN QUERY SELECT v_queue_depth, v_longest_wait_seconds;
END;
$$;

-- Revoke public execute permissions - this function should only be called from triggers
REVOKE EXECUTE ON FUNCTION public.calculate_queue_metrics_at_start(bigint, bigint) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.calculate_queue_metrics_at_start(bigint, bigint) FROM authenticated;
REVOKE EXECUTE ON FUNCTION public.calculate_queue_metrics_at_start(bigint, bigint) FROM anon;

-- Only allow the postgres role (used by triggers) to execute this function
-- Triggers run with SECURITY DEFINER privileges, so they can still call it
GRANT EXECUTE ON FUNCTION public.calculate_queue_metrics_at_start(bigint, bigint) TO postgres;

-- Function to handle work session lifecycle
CREATE OR REPLACE FUNCTION public.trigger_help_request_work_sessions()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO ''
AS $$
DECLARE
    v_queue_metrics RECORD;
    v_active_session_id bigint;
BEGIN
    -- Only process if assignee or status changed
    IF OLD.assignee IS NOT DISTINCT FROM NEW.assignee 
        AND OLD.status IS NOT DISTINCT FROM NEW.status THEN
        RETURN NEW;
    END IF;

    -- Handle assignment start: assignee changed from NULL to a profile_id
    IF OLD.assignee IS NULL AND NEW.assignee IS NOT NULL THEN
        -- End any existing active session for this request (shouldn't happen, but safety check)
        UPDATE public.help_request_work_sessions
        SET ended_at = NOW()
        WHERE help_request_id = NEW.id
            AND ended_at IS NULL;

        -- Calculate queue metrics
        SELECT * INTO v_queue_metrics
        FROM public.calculate_queue_metrics_at_start(NEW.id, NEW.help_queue);

        -- Create new work session
        INSERT INTO public.help_request_work_sessions (
            help_request_id,
            class_id,
            ta_profile_id,
            started_at,
            queue_depth_at_start,
            longest_wait_seconds_at_start
        ) VALUES (
            NEW.id,
            NEW.class_id,
            NEW.assignee,
            NOW(),
            v_queue_metrics.queue_depth,
            v_queue_metrics.longest_wait_seconds
        );
    END IF;

    -- Handle assignment end: assignee changed from a profile_id to NULL or different profile
    IF OLD.assignee IS NOT NULL 
        AND (NEW.assignee IS NULL OR NEW.assignee != OLD.assignee) THEN
        -- End the active session for the old assignee
        UPDATE public.help_request_work_sessions
        SET ended_at = NOW()
        WHERE help_request_id = NEW.id
            AND ta_profile_id = OLD.assignee
            AND ended_at IS NULL;
    END IF;

    -- Handle status changes to resolved/closed: end any active sessions
    IF OLD.status IS DISTINCT FROM NEW.status 
        AND NEW.status IN ('resolved', 'closed') THEN
        -- End all active sessions for this request
        UPDATE public.help_request_work_sessions
        SET ended_at = COALESCE(ended_at, NOW())
        WHERE help_request_id = NEW.id
            AND ended_at IS NULL;
    END IF;

    RETURN NEW;
END;
$$;

-- Create trigger on help_requests table
CREATE TRIGGER help_request_work_sessions_trigger
AFTER UPDATE ON public.help_requests
FOR EACH ROW
EXECUTE FUNCTION public.trigger_help_request_work_sessions();

-- Add broadcast trigger for realtime updates
CREATE TRIGGER broadcast_help_request_work_sessions_change
AFTER INSERT OR DELETE OR UPDATE ON public.help_request_work_sessions
FOR EACH ROW
EXECUTE FUNCTION public.broadcast_help_request_data_change();

