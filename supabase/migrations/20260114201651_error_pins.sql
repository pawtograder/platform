-- Error Pins Feature Migration
-- Creates tables, types, RLS policies, and RPC functions for error pin matching system

-- ============================================================================
-- Step 1: Create ENUM type for error pin rule targets
-- ============================================================================

CREATE TYPE error_pin_rule_target AS ENUM (
    'grader_output_student',      -- grader_result_output where visibility = 'visible'
    'grader_output_hidden',       -- grader_result_output where visibility = 'hidden' 
    'lint_output',                -- grader_results.lint_output
    'test_name',                  -- grader_result_tests.name
    'test_part',                  -- grader_result_tests.part
    'test_output',                -- grader_result_tests.output
    'test_hidden_output',         -- grader_result_test_output.output
    'test_score_range',           -- grader_result_tests.score within range
    'grader_score_range',         -- grader_results.score within range
    'lint_failed'                 -- grader_results.lint_passed = false
);

-- ============================================================================
-- Step 2: Create error_pins table
-- ============================================================================

CREATE TABLE error_pins (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now() NOT NULL,
    discussion_thread_id bigint NOT NULL REFERENCES discussion_threads(id) ON DELETE CASCADE,
    assignment_id bigint NOT NULL REFERENCES assignments(id) ON DELETE CASCADE,
    class_id bigint NOT NULL REFERENCES classes(id) ON DELETE CASCADE,
    created_by uuid NOT NULL REFERENCES profiles(id),
    rule_logic text NOT NULL DEFAULT 'and' CHECK (rule_logic IN ('and', 'or')),
    enabled boolean NOT NULL DEFAULT true,
    UNIQUE(discussion_thread_id, assignment_id)
);

-- ============================================================================
-- Step 3: Create error_pin_rules table
-- ============================================================================

CREATE TABLE error_pin_rules (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    error_pin_id bigint NOT NULL REFERENCES error_pins(id) ON DELETE CASCADE,
    target error_pin_rule_target NOT NULL,
    match_type text NOT NULL DEFAULT 'contains' CHECK (match_type IN ('contains', 'regex', 'equals', 'range')),
    match_value text NOT NULL,
    match_value_max text,  -- For range matches (min in match_value, max here)
    test_name_filter text, -- Optional: only apply to tests matching this name pattern
    ordinal smallint NOT NULL DEFAULT 0
);

-- ============================================================================
-- Step 4: Create error_pin_submission_matches table (cache/lookup)
-- ============================================================================

CREATE TABLE error_pin_submission_matches (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    error_pin_id bigint NOT NULL REFERENCES error_pins(id) ON DELETE CASCADE,
    submission_id bigint NOT NULL REFERENCES submissions(id) ON DELETE CASCADE,
    grader_result_test_id bigint REFERENCES grader_result_tests(id) ON DELETE CASCADE,
    matched_at timestamptz DEFAULT now() NOT NULL
);

-- Unique index that treats NULLs as equal (PostgreSQL 15+)
CREATE UNIQUE INDEX idx_error_pin_submission_unique ON error_pin_submission_matches(error_pin_id, submission_id, grader_result_test_id) NULLS NOT DISTINCT;

-- ============================================================================
-- Indices for performance
-- ============================================================================

-- error_pins: Fast lookup by assignment_id (main query pattern)
CREATE INDEX idx_error_pins_assignment ON error_pins(assignment_id);

-- error_pins: Covering index for enabled pins per assignment (most common query)
CREATE INDEX idx_error_pins_assignment_enabled ON error_pins(assignment_id, enabled) WHERE enabled = true;

-- error_pin_rules: Fast lookup by error_pin_id
CREATE INDEX idx_error_pin_rules_pin ON error_pin_rules(error_pin_id);

-- error_pin_submission_matches: Fast lookup by submission
CREATE INDEX idx_error_pin_matches_submission ON error_pin_submission_matches(submission_id);

-- error_pin_submission_matches: Fast lookup by error_pin
CREATE INDEX idx_error_pin_matches_error_pin ON error_pin_submission_matches(error_pin_id);

-- ============================================================================
-- Step 5: Enable RLS on all tables
-- ============================================================================

ALTER TABLE error_pins ENABLE ROW LEVEL SECURITY;
ALTER TABLE error_pin_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE error_pin_submission_matches ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- Step 6: Create RLS Policies
-- ============================================================================

-- error_pins: Instructors and graders can CRUD all pins in their class
CREATE POLICY "Instructors and graders CRUD"
ON public.error_pins
FOR ALL
USING (
  EXISTS (
    SELECT 1
    FROM public.user_privileges up
    WHERE up.user_id = auth.uid()
      AND up.class_id = error_pins.class_id
      AND up.role IN ('instructor', 'grader')
  )
);

-- error_pins: Students can read enabled pins in their class
CREATE POLICY "Students read enabled pins in class"
ON public.error_pins
FOR SELECT
USING (
  enabled = true
  AND EXISTS (
    SELECT 1
    FROM public.user_privileges up
    WHERE up.user_id = auth.uid()
      AND up.class_id = error_pins.class_id
  )
);

-- error_pin_rules: Instructors and graders can CRUD rules via parent pin
CREATE POLICY "Instructors and graders CRUD"
ON public.error_pin_rules
FOR ALL
USING (
  EXISTS (
    SELECT 1
    FROM public.error_pins ep
    JOIN public.user_privileges up ON up.class_id = ep.class_id
    WHERE ep.id = error_pin_rules.error_pin_id
      AND up.user_id = auth.uid()
      AND up.role IN ('instructor', 'grader')
  )
);

-- error_pin_rules: Students can read rules for enabled pins
CREATE POLICY "Students read rules for enabled pins"
ON public.error_pin_rules
FOR SELECT
USING (
  EXISTS (
    SELECT 1
    FROM public.error_pins ep
    JOIN public.user_privileges up ON up.class_id = ep.class_id
    WHERE ep.id = error_pin_rules.error_pin_id
      AND ep.enabled = true
      AND up.user_id = auth.uid()
  )
);

-- error_pin_submission_matches: Instructors and graders can CRUD all matches
CREATE POLICY "Instructors and graders CRUD"
ON public.error_pin_submission_matches
FOR ALL
USING (
  EXISTS (
    SELECT 1
    FROM public.error_pins ep
    JOIN public.user_privileges up ON up.class_id = ep.class_id
    WHERE ep.id = error_pin_submission_matches.error_pin_id
      AND up.user_id = auth.uid()
      AND up.role IN ('instructor', 'grader')
  )
);

-- error_pin_submission_matches: Students can read matches for their own submissions
CREATE POLICY "Students read own submission matches"
ON public.error_pin_submission_matches
FOR SELECT
USING (
  EXISTS (
    SELECT 1
    FROM public.submissions s
    WHERE s.id = error_pin_submission_matches.submission_id
      AND s.profile_id IN (
        SELECT up.private_profile_id
        FROM public.user_privileges up
        WHERE up.user_id = auth.uid()
          AND up.private_profile_id IS NOT NULL
      )
  )
);

-- ============================================================================
-- Step 7: Grant permissions
-- ============================================================================

GRANT ALL ON TABLE error_pins TO authenticated;
GRANT ALL ON TABLE error_pin_rules TO authenticated;
GRANT ALL ON TABLE error_pin_submission_matches TO authenticated;

-- ============================================================================
-- Step 8: Helper function to evaluate a single rule against a submission
-- ============================================================================

CREATE OR REPLACE FUNCTION evaluate_error_pin_rule(
    p_target error_pin_rule_target,
    p_match_type text,
    p_match_value text,
    p_match_value_max text,
    p_test_name_filter text,
    p_submission_id bigint,
    p_grader_result_id bigint,
    p_test_id bigint DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_match_value text;
    v_match_result boolean := false;
    v_test_name text;
    v_test_part text;
    v_test_output text;
    v_test_score numeric;
    v_grader_score numeric;
    v_lint_output text;
    v_lint_passed boolean;
    v_grader_output_student text;
    v_grader_output_hidden text;
    v_test_hidden_output text;
BEGIN
    -- Apply test_name_filter if specified (skip if NULL or empty string)
    IF p_test_name_filter IS NOT NULL AND p_test_name_filter != '' AND p_test_id IS NOT NULL THEN
        SELECT name INTO v_test_name
        FROM grader_result_tests
        WHERE id = p_test_id;
        
        IF v_test_name IS NULL OR v_test_name !~ p_test_name_filter THEN
            RETURN false;
        END IF;
    END IF;

    -- Evaluate based on target type
    CASE p_target
        WHEN 'test_name' THEN
            IF p_test_id IS NULL THEN RETURN false; END IF;
            SELECT name INTO v_test_name FROM grader_result_tests WHERE id = p_test_id;
            IF v_test_name IS NULL THEN RETURN false; END IF;
            v_match_value := v_test_name;

        WHEN 'test_part' THEN
            IF p_test_id IS NULL THEN RETURN false; END IF;
            SELECT part INTO v_test_part FROM grader_result_tests WHERE id = p_test_id;
            IF v_test_part IS NULL THEN RETURN false; END IF;
            v_match_value := v_test_part;

        WHEN 'test_output' THEN
            IF p_test_id IS NULL THEN RETURN false; END IF;
            SELECT output INTO v_test_output FROM grader_result_tests WHERE id = p_test_id;
            IF v_test_output IS NULL THEN RETURN false; END IF;
            v_match_value := v_test_output;

        WHEN 'test_hidden_output' THEN
            IF p_test_id IS NULL THEN RETURN false; END IF;
            SELECT gro.output INTO v_test_hidden_output
            FROM grader_result_test_output gro
            WHERE gro.grader_result_test_id = p_test_id
            LIMIT 1;
            IF v_test_hidden_output IS NULL THEN RETURN false; END IF;
            v_match_value := v_test_hidden_output;

        WHEN 'test_score_range' THEN
            IF p_test_id IS NULL THEN RETURN false; END IF;
            SELECT score INTO v_test_score FROM grader_result_tests WHERE id = p_test_id;
            IF v_test_score IS NULL THEN RETURN false; END IF;
            -- Range matching handled separately below
            IF p_match_type = 'range' THEN
                RETURN v_test_score >= p_match_value::numeric 
                   AND (p_match_value_max IS NULL OR v_test_score <= p_match_value_max::numeric);
            END IF;
            RETURN false;

        WHEN 'grader_score_range' THEN
            SELECT score INTO v_grader_score FROM grader_results WHERE id = p_grader_result_id;
            IF v_grader_score IS NULL THEN RETURN false; END IF;
            IF p_match_type = 'range' THEN
                RETURN v_grader_score >= p_match_value::numeric 
                   AND (p_match_value_max IS NULL OR v_grader_score <= p_match_value_max::numeric);
            END IF;
            RETURN false;

        WHEN 'lint_output' THEN
            SELECT lint_output INTO v_lint_output FROM grader_results WHERE id = p_grader_result_id;
            IF v_lint_output IS NULL THEN RETURN false; END IF;
            v_match_value := v_lint_output;

        WHEN 'lint_failed' THEN
            SELECT lint_passed INTO v_lint_passed FROM grader_results WHERE id = p_grader_result_id;
            RETURN v_lint_passed = false;

        WHEN 'grader_output_student' THEN
            SELECT output INTO v_grader_output_student
            FROM grader_result_output
            WHERE grader_result_id = p_grader_result_id
              AND visibility = 'visible'
            LIMIT 1;
            IF v_grader_output_student IS NULL THEN RETURN false; END IF;
            v_match_value := v_grader_output_student;

        WHEN 'grader_output_hidden' THEN
            SELECT output INTO v_grader_output_hidden
            FROM grader_result_output
            WHERE grader_result_id = p_grader_result_id
              AND visibility != 'visible'
            LIMIT 1;
            IF v_grader_output_hidden IS NULL THEN RETURN false; END IF;
            v_match_value := v_grader_output_hidden;

        ELSE
            RETURN false;
    END CASE;

    -- Apply match type (skip for range and lint_failed which are handled above)
    IF p_target IN ('test_score_range', 'grader_score_range', 'lint_failed') THEN
        RETURN v_match_result;
    END IF;

    CASE p_match_type
        WHEN 'contains' THEN
            RETURN v_match_value ILIKE '%' || p_match_value || '%';
        WHEN 'equals' THEN
            RETURN v_match_value = p_match_value;
        WHEN 'regex' THEN
            BEGIN
                RETURN v_match_value ~ p_match_value;
            EXCEPTION WHEN OTHERS THEN
                RETURN false;
            END;
        ELSE
            RETURN false;
    END CASE;
END;
$$;

-- ============================================================================
-- Step 9: RPC: get_error_pin_matches_for_submission
-- ============================================================================

CREATE OR REPLACE FUNCTION get_error_pin_matches_for_submission(p_submission_id bigint)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
DECLARE
    v_assignment_id bigint;
    v_class_id bigint;
    v_grader_result_id bigint;
    v_test_id bigint;
    v_pin_record error_pins%ROWTYPE;
    v_rule_record error_pin_rules%ROWTYPE;
    v_rule_matches boolean;
    v_all_rules_match boolean;
    v_match_count int;
    v_result jsonb := '[]'::jsonb;
    v_match jsonb;
    v_matching_test_id bigint;
    v_has_grader_level_rule boolean;
    v_first_test_id bigint;
BEGIN
    -- Authorization check: verify caller is submission owner or authorized instructor/TA
    -- Get assignment and class for this submission
    SELECT assignment_id, class_id INTO v_assignment_id, v_class_id
    FROM submissions
    WHERE id = p_submission_id;
    
    IF v_assignment_id IS NULL OR v_class_id IS NULL THEN
        RETURN v_result;
    END IF;
    
    -- Check if user owns the submission OR is an instructor/grader for the course
    -- Return empty result if unauthorized to prevent leaking which threads matched other students' submissions
    IF NOT (authorize_for_submission(p_submission_id) OR authorizeforclassgrader(v_class_id)) THEN
        RETURN v_result;
    END IF;

    -- Check if matches already exist (cache hit)
    SELECT COUNT(*) INTO v_match_count
    FROM error_pin_submission_matches
    WHERE submission_id = p_submission_id;
    
    IF v_match_count > 0 THEN
        -- Cache hit: return existing matches
        SELECT jsonb_agg(
            jsonb_build_object(
                'error_pin_id', epm.error_pin_id,
                'discussion_thread_id', ep.discussion_thread_id,
                'grader_result_test_id', epm.grader_result_test_id,
                'thread_subject', dt.subject
            )
        ) INTO v_result
        FROM error_pin_submission_matches epm
        JOIN error_pins ep ON ep.id = epm.error_pin_id
        JOIN discussion_threads dt ON dt.id = ep.discussion_thread_id
        WHERE epm.submission_id = p_submission_id
          AND ep.enabled = true;
        
        RETURN COALESCE(v_result, '[]'::jsonb);
    END IF;

    -- Cache miss: compute matches
    -- Get the grader result for this submission
    SELECT id INTO v_grader_result_id
    FROM grader_results
    WHERE submission_id = p_submission_id
    ORDER BY created_at DESC
    LIMIT 1;
    
    IF v_grader_result_id IS NULL THEN
        RETURN v_result;
    END IF;

    -- Loop through all enabled error pins for this assignment
    FOR v_pin_record IN
        SELECT * FROM error_pins
        WHERE assignment_id = v_assignment_id
          AND enabled = true
    LOOP
        -- Evaluate rules based on logic (AND/OR)
        IF v_pin_record.rule_logic = 'and' THEN
            -- AND logic: all rules must match
            v_all_rules_match := true;
            v_matching_test_id := NULL;
            v_has_grader_level_rule := false;
            v_first_test_id := NULL;
            
            FOR v_rule_record IN
                SELECT * FROM error_pin_rules
                WHERE error_pin_id = v_pin_record.id
                ORDER BY ordinal
            LOOP
                v_rule_matches := false;
                IF v_rule_record.target IN ('lint_output', 'lint_failed', 'grader_score_range', 'grader_output_student', 'grader_output_hidden') THEN
                    v_has_grader_level_rule := true;
                    v_rule_matches := evaluate_error_pin_rule(
                        v_rule_record.target,
                        v_rule_record.match_type,
                        v_rule_record.match_value,
                        v_rule_record.match_value_max,
                        v_rule_record.test_name_filter,
                        p_submission_id,
                        v_grader_result_id
                    );
                ELSE
                    -- For test-level rules, check if any test matches
                    FOR v_test_id IN
                        SELECT id FROM grader_result_tests
                        WHERE grader_result_id = v_grader_result_id
                    LOOP
                        IF evaluate_error_pin_rule(
                            v_rule_record.target,
                            v_rule_record.match_type,
                            v_rule_record.match_value,
                            v_rule_record.match_value_max,
                            v_rule_record.test_name_filter,
                            p_submission_id,
                            v_grader_result_id,
                            v_test_id
                        ) THEN
                            v_rule_matches := true;
                            -- Track the test_id that matched
                            IF v_first_test_id IS NULL THEN
                                v_first_test_id := v_test_id;
                            ELSIF v_first_test_id != v_test_id THEN
                                -- Different test matched, can't use specific test_id
                                v_first_test_id := NULL;
                            END IF;
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
                IF NOT v_rule_matches THEN
                    v_all_rules_match := false;
                    EXIT;
                END IF;
            END LOOP;
            
            IF v_all_rules_match THEN
                -- If all rules are test-level and they all match the same test, use that test_id
                -- Otherwise, use NULL (submission-level match)
                IF NOT v_has_grader_level_rule AND v_first_test_id IS NOT NULL THEN
                    v_matching_test_id := v_first_test_id;
                END IF;
                
                INSERT INTO error_pin_submission_matches (error_pin_id, submission_id, grader_result_test_id)
                VALUES (v_pin_record.id, p_submission_id, v_matching_test_id)
                ON CONFLICT (error_pin_id, submission_id, grader_result_test_id) DO NOTHING;
            END IF;
        ELSE
            -- OR logic: any rule must match
            FOR v_rule_record IN
                SELECT * FROM error_pin_rules
                WHERE error_pin_id = v_pin_record.id
                ORDER BY ordinal
            LOOP
                IF v_rule_record.target IN ('lint_output', 'lint_failed', 'grader_score_range', 'grader_output_student', 'grader_output_hidden') THEN
                    v_rule_matches := evaluate_error_pin_rule(
                        v_rule_record.target,
                        v_rule_record.match_type,
                        v_rule_record.match_value,
                        v_rule_record.match_value_max,
                        v_rule_record.test_name_filter,
                        p_submission_id,
                        v_grader_result_id
                    );
                    IF v_rule_matches THEN
                        INSERT INTO error_pin_submission_matches (error_pin_id, submission_id, grader_result_test_id)
                        VALUES (v_pin_record.id, p_submission_id, NULL)
                        ON CONFLICT (error_pin_id, submission_id, grader_result_test_id) DO NOTHING;
                        EXIT; -- Found a match, done with this pin
                    END IF;
                ELSE
                    -- Check at test level
                    FOR v_test_id IN
                        SELECT id FROM grader_result_tests
                        WHERE grader_result_id = v_grader_result_id
                    LOOP
                        v_rule_matches := evaluate_error_pin_rule(
                            v_rule_record.target,
                            v_rule_record.match_type,
                            v_rule_record.match_value,
                            v_rule_record.match_value_max,
                            v_rule_record.test_name_filter,
                            p_submission_id,
                            v_grader_result_id,
                            v_test_id
                        );
                        IF v_rule_matches THEN
                            INSERT INTO error_pin_submission_matches (error_pin_id, submission_id, grader_result_test_id)
                            VALUES (v_pin_record.id, p_submission_id, v_test_id)
                            ON CONFLICT (error_pin_id, submission_id, grader_result_test_id) DO NOTHING;
                            EXIT; -- Found a match for this rule
                        END IF;
                    END LOOP;
                    IF v_rule_matches THEN
                        EXIT; -- Found a match, done with this pin
                    END IF;
                END IF;
            END LOOP;
        END IF;
    END LOOP;

    -- Return computed matches
    SELECT jsonb_agg(
        jsonb_build_object(
            'error_pin_id', epm.error_pin_id,
            'discussion_thread_id', ep.discussion_thread_id,
            'grader_result_test_id', epm.grader_result_test_id,
            'thread_subject', dt.subject
        )
    ) INTO v_result
    FROM error_pin_submission_matches epm
    JOIN error_pins ep ON ep.id = epm.error_pin_id
    JOIN discussion_threads dt ON dt.id = ep.discussion_thread_id
    WHERE epm.submission_id = p_submission_id
      AND ep.enabled = true;
    
    RETURN COALESCE(v_result, '[]'::jsonb);
END;
$$;

-- ============================================================================
-- Step 10: RPC: save_error_pin (with auto-populate)
-- ============================================================================

CREATE OR REPLACE FUNCTION save_error_pin(
    p_error_pin jsonb,
    p_rules jsonb
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
DECLARE
    v_pin_id bigint;
    v_assignment_id bigint;
    v_submission_id bigint;
    v_rule jsonb;
    v_grader_result_id bigint;
    v_test_id bigint;
    v_pin_record error_pins%ROWTYPE;
    v_rule_record error_pin_rules%ROWTYPE;
    v_rule_matches boolean;
    v_all_rules_match boolean;
    v_processed_count int := 0;
    v_matching_test_id bigint;
    v_has_grader_level_rule boolean;
    v_first_test_id bigint;
BEGIN
    IF NOT authorizeforclassgrader(  
        (SELECT class_id FROM assignments WHERE id = (p_error_pin->>'assignment_id')::bigint)  
    ) THEN  
        RAISE EXCEPTION 'Only instructors and graders can create or modify error pins';  
    END IF;  
  
    -- Insert or update error_pin
    IF (p_error_pin->>'id')::bigint IS NOT NULL THEN
        -- Update existing pin
        UPDATE error_pins
        SET discussion_thread_id = (p_error_pin->>'discussion_thread_id')::bigint,
            assignment_id = (p_error_pin->>'assignment_id')::bigint,
            class_id = (p_error_pin->>'class_id')::bigint,
            rule_logic = COALESCE(p_error_pin->>'rule_logic', 'and'),
            enabled = COALESCE((p_error_pin->>'enabled')::boolean, true)
        WHERE id = (p_error_pin->>'id')::bigint
        RETURNING id, assignment_id INTO v_pin_id, v_assignment_id;
    ELSE
        -- Insert new pin
        INSERT INTO error_pins (
            discussion_thread_id,
            assignment_id,
            class_id,
            created_by,
            rule_logic,
            enabled
        )
        VALUES (
            (p_error_pin->>'discussion_thread_id')::bigint,
            (p_error_pin->>'assignment_id')::bigint,
            (p_error_pin->>'class_id')::bigint,
            (p_error_pin->>'created_by')::uuid,
            COALESCE(p_error_pin->>'rule_logic', 'and'),
            COALESCE((p_error_pin->>'enabled')::boolean, true)
        )
        RETURNING id, assignment_id INTO v_pin_id, v_assignment_id;
    END IF;

    -- Delete old rules
    DELETE FROM error_pin_rules WHERE error_pin_id = v_pin_id;

    -- Insert new rules
    FOR v_rule IN SELECT * FROM jsonb_array_elements(p_rules)
    LOOP
        INSERT INTO error_pin_rules (
            error_pin_id,
            target,
            match_type,
            match_value,
            match_value_max,
            test_name_filter,
            ordinal
        )
        VALUES (
            v_pin_id,
            (v_rule->>'target')::error_pin_rule_target,
            COALESCE(v_rule->>'match_type', 'contains'),
            v_rule->>'match_value',
            v_rule->>'match_value_max',
            v_rule->>'test_name_filter',
            COALESCE((v_rule->>'ordinal')::smallint, 0)
        );
    END LOOP;

    -- Auto-populate: compute matches for all active submissions
    -- Clear existing matches first
    DELETE FROM error_pin_submission_matches WHERE error_pin_id = v_pin_id;

    -- Get pin record with rules
    SELECT * INTO v_pin_record FROM error_pins WHERE id = v_pin_id;

    -- Process each active submission
    FOR v_submission_id IN
        SELECT id FROM submissions
        WHERE assignment_id = v_assignment_id
          AND is_active = true
    LOOP
        -- Get grader result
        SELECT id INTO v_grader_result_id
        FROM grader_results
        WHERE submission_id = v_submission_id
        ORDER BY created_at DESC
        LIMIT 1;
        
        IF v_grader_result_id IS NULL THEN
            CONTINUE;
        END IF;

        -- Evaluate rules based on logic (AND/OR)
        IF v_pin_record.rule_logic = 'and' THEN
            -- AND logic: all rules must match
            v_all_rules_match := true;
            v_matching_test_id := NULL;
            v_has_grader_level_rule := false;
            v_first_test_id := NULL;
            
            FOR v_rule_record IN
                SELECT * FROM error_pin_rules
                WHERE error_pin_id = v_pin_id
                ORDER BY ordinal
            LOOP
                v_rule_matches := false;
                IF v_rule_record.target IN ('lint_output', 'lint_failed', 'grader_score_range', 'grader_output_student', 'grader_output_hidden') THEN
                    v_has_grader_level_rule := true;
                    v_rule_matches := evaluate_error_pin_rule(
                        v_rule_record.target,
                        v_rule_record.match_type,
                        v_rule_record.match_value,
                        v_rule_record.match_value_max,
                        v_rule_record.test_name_filter,
                        v_submission_id,
                        v_grader_result_id
                    );
                ELSE
                    -- For test-level rules, check if any test matches
                    FOR v_test_id IN
                        SELECT id FROM grader_result_tests
                        WHERE grader_result_id = v_grader_result_id
                    LOOP
                        IF evaluate_error_pin_rule(
                            v_rule_record.target,
                            v_rule_record.match_type,
                            v_rule_record.match_value,
                            v_rule_record.match_value_max,
                            v_rule_record.test_name_filter,
                            v_submission_id,
                            v_grader_result_id,
                            v_test_id
                        ) THEN
                            v_rule_matches := true;
                            -- Track the test_id that matched
                            IF v_first_test_id IS NULL THEN
                                v_first_test_id := v_test_id;
                            ELSIF v_first_test_id != v_test_id THEN
                                -- Different test matched, can't use specific test_id
                                v_first_test_id := NULL;
                            END IF;
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
                IF NOT v_rule_matches THEN
                    v_all_rules_match := false;
                    EXIT;
                END IF;
            END LOOP;
            
            IF v_all_rules_match THEN
                -- If all rules are test-level and they all match the same test, use that test_id
                -- Otherwise, use NULL (submission-level match)
                IF NOT v_has_grader_level_rule AND v_first_test_id IS NOT NULL THEN
                    v_matching_test_id := v_first_test_id;
                END IF;
                
                INSERT INTO error_pin_submission_matches (error_pin_id, submission_id, grader_result_test_id)
                VALUES (v_pin_id, v_submission_id, v_matching_test_id)
                ON CONFLICT DO NOTHING;
                v_processed_count := v_processed_count + 1;
            END IF;
        ELSE
            -- OR logic: any rule must match
            FOR v_rule_record IN
                SELECT * FROM error_pin_rules
                WHERE error_pin_id = v_pin_id
                ORDER BY ordinal
            LOOP
                IF v_rule_record.target IN ('lint_output', 'lint_failed', 'grader_score_range', 'grader_output_student', 'grader_output_hidden') THEN
                    v_rule_matches := evaluate_error_pin_rule(
                        v_rule_record.target,
                        v_rule_record.match_type,
                        v_rule_record.match_value,
                        v_rule_record.match_value_max,
                        v_rule_record.test_name_filter,
                        v_submission_id,
                        v_grader_result_id
                    );
                    IF v_rule_matches THEN
                        INSERT INTO error_pin_submission_matches (error_pin_id, submission_id, grader_result_test_id)
                        VALUES (v_pin_id, v_submission_id, NULL)
                        ON CONFLICT DO NOTHING;
                        v_processed_count := v_processed_count + 1;
                        EXIT; -- Found a match, done with this submission
                    END IF;
                ELSE
                    FOR v_test_id IN
                        SELECT id FROM grader_result_tests
                        WHERE grader_result_id = v_grader_result_id
                    LOOP
                        v_rule_matches := evaluate_error_pin_rule(
                            v_rule_record.target,
                            v_rule_record.match_type,
                            v_rule_record.match_value,
                            v_rule_record.match_value_max,
                            v_rule_record.test_name_filter,
                            v_submission_id,
                            v_grader_result_id,
                            v_test_id
                        );
                        IF v_rule_matches THEN
                            INSERT INTO error_pin_submission_matches (error_pin_id, submission_id, grader_result_test_id)
                            VALUES (v_pin_id, v_submission_id, v_test_id)
                            ON CONFLICT DO NOTHING;
                            v_processed_count := v_processed_count + 1;
                            EXIT; -- Found a match for this rule
                        END IF;
                    END LOOP;
                    IF v_rule_matches THEN
                        EXIT; -- Found a match, done with this submission
                    END IF;
                END IF;
            END LOOP;
        END IF;
    END LOOP;

    RETURN jsonb_build_object(
        'success', true,
        'error_pin_id', v_pin_id,
        'matches_populated', v_processed_count
    );
END;
$$;

-- ============================================================================
-- Step 11: RPC: preview_error_pin_matches
-- ============================================================================

CREATE OR REPLACE FUNCTION preview_error_pin_matches(
    p_assignment_id bigint,
    p_rules jsonb,
    p_rule_logic text DEFAULT 'and'
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
DECLARE
    v_submission_id bigint;
    v_grader_result_id bigint;
    v_test_id bigint;
    v_rule jsonb;
    v_rule_record RECORD;
    v_rule_matches boolean;
    v_all_rules_match boolean;
    v_matching_submissions bigint[] := '{}';
    v_match_count int := 0;
    v_class_id bigint;
BEGIN
    -- Authorization check: ensure caller is instructor or grader for the assignment's class
    SELECT class_id INTO v_class_id
    FROM assignments
    WHERE id = p_assignment_id;
    
    IF v_class_id IS NULL THEN
        RAISE EXCEPTION 'Assignment not found';
    END IF;
    
    IF NOT authorizeforclassgrader(v_class_id) THEN
        RAISE EXCEPTION 'Only instructors and graders can preview error pin matches';
    END IF;
    
    -- Create temporary table for rules with ON COMMIT DROP to ensure cleanup
    CREATE TEMP TABLE temp_preview_rules (
        target error_pin_rule_target,
        match_type text,
        match_value text,
        match_value_max text,
        test_name_filter text,
        ordinal smallint
    ) ON COMMIT DROP;

    BEGIN
        -- Insert rules into temp table
        FOR v_rule IN SELECT * FROM jsonb_array_elements(p_rules)
        LOOP
            INSERT INTO temp_preview_rules VALUES (
                (v_rule->>'target')::error_pin_rule_target,
                COALESCE(v_rule->>'match_type', 'contains'),
                v_rule->>'match_value',
                v_rule->>'match_value_max',
                v_rule->>'test_name_filter',
                COALESCE((v_rule->>'ordinal')::smallint, 0)
            );
        END LOOP;

        -- Process each active submission
        FOR v_submission_id IN
            SELECT id FROM submissions
            WHERE assignment_id = p_assignment_id
              AND is_active = true
        LOOP
            -- Get grader result
            SELECT id INTO v_grader_result_id
            FROM grader_results
            WHERE submission_id = v_submission_id
            ORDER BY created_at DESC
            LIMIT 1;
            
            IF v_grader_result_id IS NULL THEN
                CONTINUE;
            END IF;

            -- Evaluate rules based on logic (AND/OR) - same logic as save_error_pin
            IF p_rule_logic = 'and' THEN
                -- AND logic: all rules must match
                v_all_rules_match := true;
                FOR v_rule_record IN SELECT * FROM temp_preview_rules ORDER BY ordinal
                LOOP
                    v_rule_matches := false;
                    IF v_rule_record.target IN ('lint_output', 'lint_failed', 'grader_score_range', 'grader_output_student', 'grader_output_hidden') THEN
                        v_rule_matches := evaluate_error_pin_rule(
                            v_rule_record.target,
                            v_rule_record.match_type,
                            v_rule_record.match_value,
                            v_rule_record.match_value_max,
                            v_rule_record.test_name_filter,
                            v_submission_id,
                            v_grader_result_id
                        );
                    ELSE
                        -- For test-level rules, check if any test matches
                        FOR v_test_id IN
                            SELECT id FROM grader_result_tests
                            WHERE grader_result_id = v_grader_result_id
                        LOOP
                            IF evaluate_error_pin_rule(
                                v_rule_record.target,
                                v_rule_record.match_type,
                                v_rule_record.match_value,
                                v_rule_record.match_value_max,
                                v_rule_record.test_name_filter,
                                v_submission_id,
                                v_grader_result_id,
                                v_test_id
                            ) THEN
                                v_rule_matches := true;
                                EXIT;
                            END IF;
                        END LOOP;
                    END IF;
                    IF NOT v_rule_matches THEN
                        v_all_rules_match := false;
                        EXIT;
                    END IF;
                END LOOP;
                
                IF v_all_rules_match THEN
                    v_matching_submissions := array_append(v_matching_submissions, v_submission_id);
                    v_match_count := v_match_count + 1;
                END IF;
            ELSE
                -- OR logic: any rule must match
                FOR v_rule_record IN SELECT * FROM temp_preview_rules ORDER BY ordinal
                LOOP
                    IF v_rule_record.target IN ('lint_output', 'lint_failed', 'grader_score_range', 'grader_output_student', 'grader_output_hidden') THEN
                        v_rule_matches := evaluate_error_pin_rule(
                            v_rule_record.target,
                            v_rule_record.match_type,
                            v_rule_record.match_value,
                            v_rule_record.match_value_max,
                            v_rule_record.test_name_filter,
                            v_submission_id,
                            v_grader_result_id
                        );
                        IF v_rule_matches THEN
                            v_matching_submissions := array_append(v_matching_submissions, v_submission_id);
                            v_match_count := v_match_count + 1;
                            EXIT; -- Found a match, done with this submission
                        END IF;
                    ELSE
                        -- Check at test level
                        FOR v_test_id IN
                            SELECT id FROM grader_result_tests
                            WHERE grader_result_id = v_grader_result_id
                        LOOP
                            v_rule_matches := evaluate_error_pin_rule(
                                v_rule_record.target,
                                v_rule_record.match_type,
                                v_rule_record.match_value,
                                v_rule_record.match_value_max,
                                v_rule_record.test_name_filter,
                                v_submission_id,
                                v_grader_result_id,
                                v_test_id
                            );
                            IF v_rule_matches THEN
                                v_matching_submissions := array_append(v_matching_submissions, v_submission_id);
                                v_match_count := v_match_count + 1;
                                EXIT; -- Found a match for this rule
                            END IF;
                        END LOOP;
                        IF v_rule_matches THEN
                            EXIT; -- Found a match, done with this submission
                        END IF;
                    END IF;
                END LOOP;
            END IF;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            -- Ensure temp table is dropped even on exception
            DROP TABLE IF EXISTS temp_preview_rules;
            RAISE;
    END;

    -- Get all matching submissions with student names, ordered by most recent first
    -- We'll show the first 10 in the UI with an option to expand
    RETURN jsonb_build_object(
        'match_count', v_match_count,
        'submission_ids', v_matching_submissions,
        'recent_submissions', (
            SELECT COALESCE(jsonb_agg(submission_data), '[]'::jsonb)
            FROM (
                SELECT jsonb_build_object(
                    'submission_id', s.id,
                    'student_name', COALESCE(p.name, 'Unknown'),
                    'created_at', s.created_at
                ) AS submission_data
                FROM submissions s
                LEFT JOIN profiles p ON p.id = s.profile_id
                WHERE s.id = ANY(v_matching_submissions)
                ORDER BY s.created_at DESC
            ) recent_submissions_query
        )
    );
END;
$$;

-- ============================================================================
-- Step 12: RPC: reset_error_pin_matches
-- ============================================================================

CREATE OR REPLACE FUNCTION reset_error_pin_matches(p_error_pin_id bigint)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
DECLARE
    v_deleted_count int;
    v_error_pin_created_by uuid;
    v_error_pin_class_id bigint;
BEGIN
    -- Authorization check: verify caller is error pin owner or authorized instructor/TA/admin
    -- Get error pin ownership and class information
    SELECT created_by, class_id INTO v_error_pin_created_by, v_error_pin_class_id
    FROM error_pins
    WHERE id = p_error_pin_id;
    
    -- If error pin doesn't exist, return error
    IF v_error_pin_created_by IS NULL OR v_error_pin_class_id IS NULL THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Error pin not found'
        );
    END IF;
    
    -- Check if user is authorized: admin OR owns the error pin OR is instructor/grader for the class
    IF NOT (
        authorize_for_admin() 
        OR authorizeforprofile(v_error_pin_created_by)
        OR authorizeforclassgrader(v_error_pin_class_id)
    ) THEN
        RAISE EXCEPTION 'Access denied: Only error pin owners, instructors, graders, and admins can reset matches';
    END IF;
    
    -- Perform the deletion
    DELETE FROM error_pin_submission_matches
    WHERE error_pin_id = p_error_pin_id;
    
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
    
    RETURN jsonb_build_object(
        'success', true,
        'deleted_count', v_deleted_count
    );
END;
$$;
