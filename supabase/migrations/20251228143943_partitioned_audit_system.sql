-- Migration: Partitioned Audit System with Automatic Retention
-- This migration:
-- 1. Renames existing audit table to audit_legacy for later cleanup
-- 2. Creates a new partitioned audit table (partitioned by day)
-- 3. Implements bulk inserts via statement-level triggers
-- 4. Sets up automatic partition maintenance and 3-month retention via cron

-- ============================================================================
-- Step 1: Rename existing audit table and indexes
-- ============================================================================

ALTER TABLE public.audit RENAME TO audit_legacy;
ALTER INDEX IF EXISTS audit_pkey RENAME TO audit_legacy_pkey;
ALTER INDEX IF EXISTS idx_audit_user_id RENAME TO idx_audit_legacy_user_id;
ALTER INDEX IF EXISTS idx_audit_class_id RENAME TO idx_audit_legacy_class_id;

-- ============================================================================
-- Step 2: Create partitioned audit table
-- ============================================================================

CREATE TABLE public.audit (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "created_at" timestamptz NOT NULL DEFAULT now(),
    "class_id" bigint NOT NULL,
    "user_id" uuid,
    "table" text NOT NULL,
    "old" jsonb,
    "new" jsonb,
    "ip_addr" text,
    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- Enable RLS on the partitioned table
ALTER TABLE public.audit ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- Step 3: Create initial partitions (today through today+7 days)
-- ============================================================================

DO $$
DECLARE
    partition_date date;
    partition_name text;
    start_date timestamptz;
    end_date timestamptz;
BEGIN
    FOR i IN 0..7 LOOP
        partition_date := CURRENT_DATE + i;
        partition_name := 'audit_' || to_char(partition_date, 'YYYYMMDD');
        start_date := partition_date;
        end_date := partition_date + 1;
        
        EXECUTE format(
            'CREATE TABLE IF NOT EXISTS public.%I PARTITION OF public.audit 
             FOR VALUES FROM (%L) TO (%L)',
            partition_name, start_date, end_date
        );
    END LOOP;
END $$;

-- ============================================================================
-- Step 4: Create partition maintenance function
-- ============================================================================

CREATE OR REPLACE FUNCTION public.audit_maintain_partitions()
RETURNS void AS $$
DECLARE
    partition_date date;
    partition_name text;
    start_date timestamptz;
    end_date timestamptz;
    old_partition_name text;
BEGIN
    -- Create partitions for next 7 days (if they don't exist)
    FOR i IN 0..7 LOOP
        partition_date := CURRENT_DATE + i;
        partition_name := 'audit_' || to_char(partition_date, 'YYYYMMDD');
        start_date := partition_date;
        end_date := partition_date + 1;
        
        IF NOT EXISTS (
            SELECT 1 FROM pg_class 
            WHERE relname = partition_name 
            AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')
        ) THEN
            EXECUTE format(
                'CREATE TABLE public.%I PARTITION OF public.audit 
                 FOR VALUES FROM (%L) TO (%L)',
                partition_name, start_date, end_date
            );
        END IF;
    END LOOP;
    
    -- Drop partitions older than 90 days (3 months)
    FOR old_partition_name IN 
        SELECT tablename FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename LIKE 'audit_%'
        AND tablename ~ '^audit_[0-9]{8}$'
        AND substring(tablename from 7)::date < CURRENT_DATE - 90
    LOOP
        EXECUTE format('DROP TABLE IF EXISTS public.%I CASCADE', old_partition_name);
    END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- Step 5: Schedule cron job for partition maintenance
-- ============================================================================

-- Schedule daily partition maintenance (runs at midnight UTC)
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron') THEN
        -- Unschedule if it already exists
        PERFORM cron.unschedule('audit-partition-maintenance');
        
        -- Schedule the job
        PERFORM cron.schedule(
            'audit-partition-maintenance',
            '0 0 * * *',  -- Run daily at midnight UTC
            $$SELECT public.audit_maintain_partitions()$$
        );
    ELSE
        RAISE NOTICE 'pg_cron extension not available - partition maintenance job not scheduled';
    END IF;
END $$;

-- ============================================================================
-- Step 6: Create statement-level audit trigger function for bulk inserts
-- ============================================================================

CREATE OR REPLACE FUNCTION public.audit_statement_trigger()
RETURNS trigger AS $$
DECLARE
    remote_ip text;
    current_user_id uuid;
BEGIN
    -- Set fixed search_path to prevent search_path attacks
    PERFORM set_config('search_path', 'pg_catalog, public', true);
    
    -- Get current user ID
    current_user_id := auth.uid();
    
    -- Extract IP address from request headers
    SELECT split_part(
        current_setting('request.headers', true)::json->>'x-forwarded-for',
        ',', 1) INTO remote_ip;
        
    CASE TG_OP
    WHEN 'INSERT' THEN
        -- Bulk insert audit records for all new rows
        INSERT INTO public.audit (class_id, user_id, "table", old, new, ip_addr)
        SELECT n.class_id, current_user_id, TG_TABLE_NAME, NULL, row_to_json(n), remote_ip
        FROM NEW_TABLE n;
        
    WHEN 'UPDATE' THEN
        -- Bulk insert audit records for all updated rows
        INSERT INTO public.audit (class_id, user_id, "table", old, new, ip_addr)
        SELECT COALESCE(n.class_id, o.class_id), current_user_id, TG_TABLE_NAME, 
               row_to_json(o), row_to_json(n), remote_ip
        FROM NEW_TABLE n
        JOIN OLD_TABLE o ON n.id = o.id;
        
    WHEN 'DELETE' THEN
        -- Bulk insert audit records for all deleted rows
        INSERT INTO public.audit (class_id, user_id, "table", old, new, ip_addr)
        SELECT o.class_id, current_user_id, TG_TABLE_NAME, row_to_json(o), NULL, remote_ip
        FROM OLD_TABLE o;
        
    ELSE
        RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
    END CASE;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add comment for documentation
COMMENT ON FUNCTION public.audit_statement_trigger() IS 
'STATEMENT-level audit trigger that logs all changes in batch operations. Provides complete audit trail while being highly efficient for bulk operations. Supports INSERT, UPDATE, and DELETE operations.';

-- ============================================================================
-- Step 7: Drop old row-level triggers and create new statement-level triggers
-- ============================================================================

-- assignments
DROP TRIGGER IF EXISTS audit_assignments_insert_update ON public.assignments;
CREATE TRIGGER audit_assignments_insert
    AFTER INSERT ON public.assignments
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_assignments_update
    AFTER UPDATE ON public.assignments
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- submissions
DROP TRIGGER IF EXISTS audit_submissions_insert_update ON public.submissions;
CREATE TRIGGER audit_submissions_insert
    AFTER INSERT ON public.submissions
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_submissions_update
    AFTER UPDATE ON public.submissions
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- submission_reviews
DROP TRIGGER IF EXISTS submission_reviews_audit_insert_update ON public.submission_reviews;
CREATE TRIGGER audit_submission_reviews_insert
    AFTER INSERT ON public.submission_reviews
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_submission_reviews_update
    AFTER UPDATE ON public.submission_reviews
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- submission_comments
DROP TRIGGER IF EXISTS audit_submission_comment_insert_update ON public.submission_comments;
CREATE TRIGGER audit_submission_comments_insert
    AFTER INSERT ON public.submission_comments
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_submission_comments_update
    AFTER UPDATE ON public.submission_comments
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- submission_file_comments
DROP TRIGGER IF EXISTS audit_submission_file_comment_insert_update ON public.submission_file_comments;
CREATE TRIGGER audit_submission_file_comments_insert
    AFTER INSERT ON public.submission_file_comments
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_submission_file_comments_update
    AFTER UPDATE ON public.submission_file_comments
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- discussion_threads (already has statement-level triggers, but we'll replace with generic function)
DROP TRIGGER IF EXISTS audit_discussion_thread_insert ON public.discussion_threads;
DROP TRIGGER IF EXISTS audit_discussion_thread_update ON public.discussion_threads;
DROP TRIGGER IF EXISTS audit_discussion_thread_insert_update ON public.discussion_threads;
CREATE TRIGGER audit_discussion_threads_insert
    AFTER INSERT ON public.discussion_threads
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_discussion_threads_update
    AFTER UPDATE ON public.discussion_threads
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- rubric_criteria
DROP TRIGGER IF EXISTS audit_rubric_criteria_insert_update ON public.rubric_criteria;
CREATE TRIGGER audit_rubric_criteria_insert
    AFTER INSERT ON public.rubric_criteria
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_rubric_criteria_update
    AFTER UPDATE ON public.rubric_criteria
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_rubric_criteria_delete
    AFTER DELETE ON public.rubric_criteria
    REFERENCING OLD TABLE AS OLD_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- rubric_checks
DROP TRIGGER IF EXISTS audit_rubric_checks_insert_update ON public.rubric_checks;
CREATE TRIGGER audit_rubric_checks_insert
    AFTER INSERT ON public.rubric_checks
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_rubric_checks_update
    AFTER UPDATE ON public.rubric_checks
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_rubric_checks_delete
    AFTER DELETE ON public.rubric_checks
    REFERENCING OLD TABLE AS OLD_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- rubric_parts
DROP TRIGGER IF EXISTS audit_rubric_parts_insert_update ON public.rubric_parts;
CREATE TRIGGER audit_rubric_parts_insert
    AFTER INSERT ON public.rubric_parts
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_rubric_parts_update
    AFTER UPDATE ON public.rubric_parts
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_rubric_parts_delete
    AFTER DELETE ON public.rubric_parts
    REFERENCING OLD TABLE AS OLD_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- assignment_due_date_exceptions
DROP TRIGGER IF EXISTS audit_assignment_due_date_exceptions_insert_update ON public.assignment_due_date_exceptions;
CREATE TRIGGER audit_assignment_due_date_exceptions_insert
    AFTER INSERT ON public.assignment_due_date_exceptions
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_assignment_due_date_exceptions_update
    AFTER UPDATE ON public.assignment_due_date_exceptions
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_assignment_due_date_exceptions_delete
    AFTER DELETE ON public.assignment_due_date_exceptions
    REFERENCING OLD TABLE AS OLD_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- assignment_groups
DROP TRIGGER IF EXISTS audit_assignment_groups_insert_update ON public.assignment_groups;
CREATE TRIGGER audit_assignment_groups_insert
    AFTER INSERT ON public.assignment_groups
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_assignment_groups_update
    AFTER UPDATE ON public.assignment_groups
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- assignment_groups_members
DROP TRIGGER IF EXISTS audit_assignment_groups_members_insert_update_delete ON public.assignment_groups_members;
CREATE TRIGGER audit_assignment_groups_members_insert
    AFTER INSERT ON public.assignment_groups_members
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_assignment_groups_members_update
    AFTER UPDATE ON public.assignment_groups_members
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_assignment_groups_members_delete
    AFTER DELETE ON public.assignment_groups_members
    REFERENCING OLD TABLE AS OLD_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- profiles
DROP TRIGGER IF EXISTS profiles_audit_trigger ON public.profiles;
CREATE TRIGGER audit_profiles_insert
    AFTER INSERT ON public.profiles
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_profiles_update
    AFTER UPDATE ON public.profiles
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- lab_sections
DROP TRIGGER IF EXISTS audit_lab_sections_insert_update ON public.lab_sections;
CREATE TRIGGER audit_lab_sections_insert
    AFTER INSERT ON public.lab_sections
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_lab_sections_update
    AFTER UPDATE ON public.lab_sections
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- lab_section_meetings
DROP TRIGGER IF EXISTS audit_lab_section_meetings_insert_update_delete ON public.lab_section_meetings;
CREATE TRIGGER audit_lab_section_meetings_insert
    AFTER INSERT ON public.lab_section_meetings
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_lab_section_meetings_update
    AFTER UPDATE ON public.lab_section_meetings
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_lab_section_meetings_delete
    AFTER DELETE ON public.lab_section_meetings
    REFERENCING OLD TABLE AS OLD_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- tags
DROP TRIGGER IF EXISTS audit_profile_tags_insert_update_delete ON public.tags;
CREATE TRIGGER audit_tags_insert
    AFTER INSERT ON public.tags
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_tags_update
    AFTER UPDATE ON public.tags
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_tags_delete
    AFTER DELETE ON public.tags
    REFERENCING OLD TABLE AS OLD_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- gradebook_columns
DROP TRIGGER IF EXISTS audit_gradebook_columns_insert_update_delete ON public.gradebook_columns;
CREATE TRIGGER audit_gradebook_columns_insert
    AFTER INSERT ON public.gradebook_columns
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_gradebook_columns_update
    AFTER UPDATE ON public.gradebook_columns
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_gradebook_columns_delete
    AFTER DELETE ON public.gradebook_columns
    REFERENCING OLD TABLE AS OLD_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- gradebook_column_students
DROP TRIGGER IF EXISTS audit_gradebook_column_students_insert_update_delete ON public.gradebook_column_students;
CREATE TRIGGER audit_gradebook_column_students_insert
    AFTER INSERT ON public.gradebook_column_students
    REFERENCING NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_gradebook_column_students_update
    AFTER UPDATE ON public.gradebook_column_students
    REFERENCING OLD TABLE AS OLD_TABLE NEW TABLE AS NEW_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();
CREATE TRIGGER audit_gradebook_column_students_delete
    AFTER DELETE ON public.gradebook_column_students
    REFERENCING OLD TABLE AS OLD_TABLE
    FOR EACH STATEMENT EXECUTE FUNCTION public.audit_statement_trigger();

-- ============================================================================
-- Step 8: Drop old audit functions (no longer needed)
-- ============================================================================

DROP FUNCTION IF EXISTS public.audit_insert_and_update() CASCADE;
DROP FUNCTION IF EXISTS public.audit_insert_and_update_and_delete() CASCADE;
DROP FUNCTION IF EXISTS public.audit_discussion_threads_statement() CASCADE;

-- ============================================================================
-- Step 9: Create indexes on partitioned table
-- ============================================================================

-- Note: Indexes on partitioned tables are automatically created on all partitions
-- We'll create them on the parent table and they'll propagate to partitions
CREATE INDEX IF NOT EXISTS idx_audit_user_id ON public.audit (user_id);
CREATE INDEX IF NOT EXISTS idx_audit_class_id ON public.audit (class_id);
CREATE INDEX IF NOT EXISTS idx_audit_created_at ON public.audit (created_at);
CREATE INDEX IF NOT EXISTS idx_audit_table ON public.audit ("table");

-- ============================================================================
-- Step 10: Grant permissions (matching original audit table permissions)
-- ============================================================================

-- Grant permissions to authenticated and service_role (anon was revoked in later migration)
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES, TRIGGER, TRUNCATE ON TABLE public.audit TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES, TRIGGER, TRUNCATE ON TABLE public.audit TO service_role;

-- ============================================================================
-- Step 11: Add foreign key constraint (matching original)
-- ============================================================================

ALTER TABLE public.audit 
    ADD CONSTRAINT audit_user_id_fkey 
    FOREIGN KEY (user_id) 
    REFERENCES public.users(user_id);

-- ============================================================================
-- Step 12: Enable RLS on discussion digest tables
-- ============================================================================

ALTER TABLE public.discussion_digest_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.discussion_digest_send_times ENABLE ROW LEVEL SECURITY;

