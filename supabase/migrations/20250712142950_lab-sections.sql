-- Lab Sections Migration
-- This migration adds support for lab sections with the following features:
-- 1. Lab sections belong to a class and have a meeting schedule
-- 2. Students can be assigned to at most one lab section per class
-- 3. Assignments can have a due date offset based on lab section meetings
-- 4. Lab section meetings are tracked to compute dynamic due dates
ALTER TABLE "public"."classes"
    ALTER COLUMN "time_zone" SET NOT NULL;

-- Create enum for day of week
CREATE TYPE "public"."day_of_week" AS ENUM (
    'sunday',
    'monday',
    'tuesday',
    'wednesday',
    'thursday',
    'friday',
    'saturday'
);

ALTER TYPE "public"."day_of_week" OWNER TO "postgres";

-- Create lab_sections table
CREATE TABLE IF NOT EXISTS "public"."lab_sections" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "class_id" bigint NOT NULL,
    "name" text NOT NULL,
    "day_of_week" "public"."day_of_week" NOT NULL,
    "start_time" time NOT NULL,
    "end_time" time,
    "lab_leader_id" uuid NOT NULL,
    "description" text,
    CONSTRAINT "lab_sections_time_order_check" CHECK (end_time IS NULL OR start_time < end_time)
);

-- Create lab_section_meetings table to track actual meeting instances
CREATE TABLE IF NOT EXISTS "public"."lab_section_meetings" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "lab_section_id" bigint NOT NULL,
    "meeting_date" date NOT NULL,
    "class_id" bigint NOT NULL,
    "cancelled" boolean DEFAULT false NOT NULL,
    "notes" text,
    CONSTRAINT "lab_section_meetings_unique_section_date" UNIQUE ("lab_section_id", "meeting_date")
);

-- Add foreign key constraints for lab_sections
ALTER TABLE ONLY "public"."lab_sections"
    ADD CONSTRAINT "lab_sections_class_id_fkey" 
    FOREIGN KEY ("class_id") REFERENCES "public"."classes"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."lab_sections"
    ADD CONSTRAINT "lab_sections_lab_leader_id_fkey" 
    FOREIGN KEY ("lab_leader_id") REFERENCES "public"."profiles"("id") ON DELETE RESTRICT;

-- Add foreign key constraints for lab_section_meetings
ALTER TABLE ONLY "public"."lab_section_meetings"
    ADD CONSTRAINT "lab_section_meetings_lab_section_id_fkey" 
    FOREIGN KEY ("lab_section_id") REFERENCES "public"."lab_sections"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."lab_section_meetings"
    ADD CONSTRAINT "lab_section_meetings_class_id_fkey" 
    FOREIGN KEY ("class_id") REFERENCES "public"."classes"("id") ON DELETE CASCADE;

-- Add lab_section_id to user_roles table (students can be in at most one lab section)
ALTER TABLE "public"."user_roles" ADD COLUMN "lab_section_id" bigint;

-- Add foreign key constraint for lab_section_id in user_roles
ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_lab_section_id_fkey" 
    FOREIGN KEY ("lab_section_id") REFERENCES "public"."lab_sections"("id") ON DELETE SET NULL;

-- Add minutes_due_after_lab to assignments table
ALTER TABLE "public"."assignments" ADD COLUMN "minutes_due_after_lab" integer;

-- Add check constraint to ensure minutes_due_after_lab is non-negative if set
ALTER TABLE "public"."assignments" 
ADD CONSTRAINT "assignments_minutes_due_after_lab_check" 
CHECK (minutes_due_after_lab IS NULL OR minutes_due_after_lab >= 0);

-- Add start_date and end_date to classes table
ALTER TABLE "public"."classes" ADD COLUMN "start_date" date;
ALTER TABLE "public"."classes" ADD COLUMN "end_date" date;

-- Add check constraint to ensure start_date is before end_date
ALTER TABLE "public"."classes" 
ADD CONSTRAINT "classes_date_order_check" 
CHECK (end_date IS NULL OR start_date IS NULL OR start_date <= end_date);

-- Function to automatically create lab section meetings
CREATE OR REPLACE FUNCTION "public"."sync_lab_section_meetings"("lab_section_id_param" bigint) 
RETURNS void
LANGUAGE "plpgsql" SECURITY DEFINER
AS $$
DECLARE
    lab_section_record RECORD;
    class_record RECORD;
    target_day_num INTEGER;
    iter_date DATE;
    meeting_count INTEGER := 0;
BEGIN
    -- Get lab section details
    SELECT * INTO lab_section_record 
    FROM public.lab_sections 
    WHERE id = lab_section_id_param;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Lab section with id % not found', lab_section_id_param;
    END IF;
    
    -- Get class dates
    SELECT * INTO class_record 
    FROM public.classes 
    WHERE id = lab_section_record.class_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Class with id % not found', lab_section_record.class_id;
    END IF;
    
    -- Skip if class doesn't have start/end dates set
    IF class_record.start_date IS NULL OR class_record.end_date IS NULL THEN
        RAISE EXCEPTION 'Class with id % does not have start/end dates set. So, it can not yet have lab sections.', lab_section_record.class_id;
    END IF;
    
    -- Convert day_of_week enum to PostgreSQL day number (0=Sunday, 1=Monday, etc.)
    target_day_num := CASE lab_section_record.day_of_week
        WHEN 'sunday' THEN 0
        WHEN 'monday' THEN 1
        WHEN 'tuesday' THEN 2
        WHEN 'wednesday' THEN 3
        WHEN 'thursday' THEN 4
        WHEN 'friday' THEN 5
        WHEN 'saturday' THEN 6
    END;
    
    -- Find the first occurrence of the target day on or after start_date
    iter_date := class_record.start_date;
    WHILE EXTRACT(DOW FROM iter_date) != target_day_num LOOP
        iter_date := iter_date + INTERVAL '1 day';
    END LOOP;
    
    -- Create meetings for each occurrence of the target day
    WHILE iter_date <= class_record.end_date LOOP
        INSERT INTO public.lab_section_meetings (
            lab_section_id,
            meeting_date,
            class_id,
            cancelled
        ) VALUES (
            lab_section_id_param,
            iter_date,
            lab_section_record.class_id,
            false
        )
        ON CONFLICT (lab_section_id, meeting_date) DO NOTHING;
        
        meeting_count := meeting_count + 1;
        iter_date := iter_date + INTERVAL '7 days';
    END LOOP;
    
    RAISE NOTICE 'Created % lab section meetings for lab section %', meeting_count, lab_section_id_param;
END;
$$;

-- Function to handle lab section creation and sync meetings
CREATE OR REPLACE FUNCTION "public"."handle_lab_section_creation"() 
RETURNS trigger
LANGUAGE "plpgsql" SECURITY DEFINER
AS $$
BEGIN
    -- Sync meetings after creating the lab section
    PERFORM public.sync_lab_section_meetings(NEW.id);
    RETURN NEW;
END;
$$;

-- Create indexes for performance
CREATE INDEX "lab_sections_class_id_idx" ON "public"."lab_sections" USING btree ("class_id");
CREATE INDEX "lab_sections_lab_leader_id_idx" ON "public"."lab_sections" USING btree ("lab_leader_id");
CREATE INDEX "lab_section_meetings_lab_section_id_idx" ON "public"."lab_section_meetings" USING btree ("lab_section_id");
CREATE INDEX "lab_section_meetings_meeting_date_idx" ON "public"."lab_section_meetings" USING btree ("meeting_date");
CREATE INDEX "lab_section_meetings_class_id_meeting_date_idx" ON "public"."lab_section_meetings" USING btree ("class_id", "meeting_date");
CREATE INDEX "user_roles_lab_section_id_idx" ON "public"."user_roles" USING btree ("lab_section_id");

-- Enable Row Level Security
ALTER TABLE "public"."lab_sections" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."lab_section_meetings" ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for lab_sections
-- Instructors can manage lab sections in their classes
CREATE POLICY "instructors_manage_lab_sections" ON "public"."lab_sections"
    TO "authenticated"
    USING ("public"."authorizeforclassinstructor"("class_id"))
    WITH CHECK ("public"."authorizeforclassinstructor"("class_id"));

-- Students and instructors can view lab sections in their classes
CREATE POLICY "class_members_view_lab_sections" ON "public"."lab_sections"
    FOR SELECT
    TO "authenticated"
    USING ("public"."authorizeforclass"("class_id"));

-- Create RLS policies for lab_section_meetings
-- Instructors can manage lab section meetings in their classes
CREATE POLICY "instructors_manage_lab_meetings" ON "public"."lab_section_meetings"
    TO "authenticated"
    USING ("public"."authorizeforclassinstructor"("class_id"))
    WITH CHECK ("public"."authorizeforclassinstructor"("class_id"));

-- Students and instructors can view lab section meetings in their classes
CREATE POLICY "class_members_view_lab_meetings" ON "public"."lab_section_meetings"
    FOR SELECT
    TO "authenticated"
    USING ("public"."authorizeforclass"("class_id"));

-- Grant permissions
GRANT ALL ON TABLE "public"."lab_sections" TO "authenticated";
GRANT ALL ON TABLE "public"."lab_sections" TO "service_role";

GRANT ALL ON TABLE "public"."lab_section_meetings" TO "authenticated";
GRANT ALL ON TABLE "public"."lab_section_meetings" TO "service_role";

-- Central function to calculate effective due date for a student on an assignment
-- This handles both regular due dates and lab-based due dates
CREATE OR REPLACE FUNCTION "public"."calculate_effective_due_date"(
    "assignment_id_param" bigint, 
    "student_profile_id_param" uuid
) 
RETURNS timestamp with time zone
LANGUAGE "plpgsql" STABLE SECURITY DEFINER
AS $$
DECLARE
    assignment_record RECORD;
    student_lab_section_id bigint;
    most_recent_lab_meeting_date date;
    lab_section_record RECORD;
    course_record RECORD;
    lab_based_due_date timestamp with time zone;
    lab_meeting_timestamp timestamp with time zone;
BEGIN
    -- Get assignment details
    SELECT * INTO assignment_record 
    FROM public.assignments 
    WHERE id = assignment_id_param;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Assignment with id % not found', assignment_id_param;
    END IF;
    
    -- If assignment doesn't use lab-based scheduling, return original due date
    IF assignment_record.minutes_due_after_lab IS NULL THEN
        RETURN assignment_record.due_date;
    END IF;
    
    -- Get student's lab section for this class
    SELECT lab_section_id INTO student_lab_section_id
    FROM public.user_roles 
    WHERE private_profile_id = student_profile_id_param 
    AND class_id = assignment_record.class_id
    AND lab_section_id IS NOT NULL;
    
    -- If student is not in a lab section, fall back to original due date
    IF student_lab_section_id IS NULL THEN
        RETURN assignment_record.due_date;
    END IF;
    
    -- Get lab section details (for start_time)
    SELECT * INTO lab_section_record
    FROM public.lab_sections
    WHERE id = student_lab_section_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Lab section with id % not found', student_lab_section_id;
    END IF;
    
    -- Get course details (for time_zone)
    SELECT * INTO course_record
    FROM public.classes
    WHERE id = assignment_record.class_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Class with id % not found', assignment_record.class_id;
    END IF;
    
    -- Find the most recent lab section meeting before the assignment's original due date
    -- Convert meeting date + lab section end time to timestamp in course timezone
    SELECT meeting_date INTO most_recent_lab_meeting_date
    FROM public.lab_section_meetings lsm
    WHERE lsm.lab_section_id = student_lab_section_id
    AND (
        (lsm.meeting_date::text || ' ' || lab_section_record.end_time::text)::timestamp AT TIME ZONE course_record.time_zone
    ) <= assignment_record.due_date
    AND NOT lsm.cancelled
    ORDER BY lsm.meeting_date DESC
    LIMIT 1;
    
    -- If no lab meeting found before due date, fall back to original due date
    IF most_recent_lab_meeting_date IS NULL THEN
        RETURN assignment_record.due_date;
    END IF;
    
    -- Combine meeting date with lab section start time and apply course time zone
    lab_meeting_timestamp := (
        most_recent_lab_meeting_date::text || ' ' || lab_section_record.end_time::text
    )::timestamp AT TIME ZONE course_record.time_zone;
    
    -- Calculate lab-based due date
    lab_based_due_date := lab_meeting_timestamp 
                         + (assignment_record.minutes_due_after_lab * INTERVAL '1 minute');
    
    -- Return the lab-based due date
    RETURN lab_based_due_date;
END;
$$;

-- Function to calculate final due date including extensions
-- This is the complete due date calculation including lab scheduling + extensions
CREATE OR REPLACE FUNCTION "public"."calculate_final_due_date"(
    "assignment_id_param" bigint,
    "student_profile_id_param" uuid,
    "assignment_group_id_param" bigint DEFAULT NULL
) 
RETURNS timestamp with time zone
LANGUAGE "plpgsql" STABLE SECURITY DEFINER
AS $$
DECLARE
    effective_due_date timestamp with time zone;
    total_extension_hours integer := 0;
    total_extension_minutes integer := 0;
BEGIN
    -- Get the effective due date (lab-based or regular)
    effective_due_date := public.calculate_effective_due_date(assignment_id_param, student_profile_id_param);
    
    -- Calculate total extensions for this student/group
    SELECT 
        COALESCE(SUM(hours), 0),
        COALESCE(SUM(minutes), 0)
    INTO 
        total_extension_hours,
        total_extension_minutes
    FROM public.assignment_due_date_exceptions
    WHERE assignment_id = assignment_id_param
    AND (
        student_id = student_profile_id_param 
        OR (assignment_group_id_param IS NOT NULL AND assignment_group_id = assignment_group_id_param)
    );
    
    -- Apply extensions to the effective due date
    RETURN effective_due_date 
           + (total_extension_hours * INTERVAL '1 hour')
           + (total_extension_minutes * INTERVAL '1 minute');
END;
$$;

-- Grant permissions on functions
GRANT EXECUTE ON FUNCTION "public"."sync_lab_section_meetings"(bigint) TO "authenticated";
GRANT EXECUTE ON FUNCTION "public"."sync_lab_section_meetings"(bigint) TO "service_role";
GRANT EXECUTE ON FUNCTION "public"."handle_lab_section_creation"() TO "authenticated";
GRANT EXECUTE ON FUNCTION "public"."handle_lab_section_creation"() TO "service_role";
GRANT EXECUTE ON FUNCTION "public"."calculate_effective_due_date"(bigint, uuid) TO "authenticated";
GRANT EXECUTE ON FUNCTION "public"."calculate_effective_due_date"(bigint, uuid) TO "service_role";
GRANT EXECUTE ON FUNCTION "public"."calculate_final_due_date"(bigint, uuid, bigint) TO "authenticated";
GRANT EXECUTE ON FUNCTION "public"."calculate_final_due_date"(bigint, uuid, bigint) TO "service_role";

-- Add to realtime publication for real-time updates
ALTER PUBLICATION "supabase_realtime" ADD TABLE "public"."lab_sections";
ALTER PUBLICATION "supabase_realtime" ADD TABLE "public"."lab_section_meetings";

-- Add audit triggers for tracking changes
CREATE TRIGGER "audit_lab_sections_insert_update" 
    AFTER INSERT OR UPDATE ON "public"."lab_sections" 
    FOR EACH ROW EXECUTE FUNCTION "public"."audit_insert_and_update"();

CREATE TRIGGER "audit_lab_section_meetings_insert_update_delete" 
    AFTER INSERT OR UPDATE OR DELETE ON "public"."lab_section_meetings" 
    FOR EACH ROW EXECUTE FUNCTION "public"."audit_insert_and_update_and_delete"();

-- Trigger to automatically create lab section meetings after creating a lab section
CREATE TRIGGER "sync_lab_section_meetings_on_create" 
    AFTER INSERT ON "public"."lab_sections" 
    FOR EACH ROW EXECUTE FUNCTION "public"."handle_lab_section_creation"();

-- Comments for documentation
COMMENT ON TABLE "public"."lab_sections" IS 'Lab sections with recurring meeting schedules, associated with classes and led by instructors/TAs';
COMMENT ON TABLE "public"."lab_section_meetings" IS 'Individual meeting instances for lab sections, used to track actual meeting dates for dynamic due date calculations';
COMMENT ON COLUMN "public"."lab_sections"."day_of_week" IS 'Day of week enum: sunday, monday, tuesday, wednesday, thursday, friday, saturday';
COMMENT ON COLUMN "public"."assignments"."minutes_due_after_lab" IS 'If set, assignment due date is calculated as minutes after the most recent lab section meeting before the original due date';
COMMENT ON COLUMN "public"."user_roles"."lab_section_id" IS 'Lab section assignment for students (null for non-students or students not assigned to a lab section)';
COMMENT ON COLUMN "public"."classes"."start_date" IS 'First day of the class/semester - used to auto-generate lab section meetings';
COMMENT ON COLUMN "public"."classes"."end_date" IS 'Last day of the class/semester - used to auto-generate lab section meetings';
COMMENT ON FUNCTION "public"."sync_lab_section_meetings"(bigint) IS 'Automatically creates lab section meetings for all occurrences of the lab day between class start and end dates';
COMMENT ON FUNCTION "public"."calculate_effective_due_date"(bigint, uuid) IS 'Calculates the effective due date for a student on an assignment, considering lab-based scheduling if configured';
COMMENT ON FUNCTION "public"."calculate_final_due_date"(bigint, uuid, bigint) IS 'Calculates the final due date including both lab-based scheduling and due date extensions';
