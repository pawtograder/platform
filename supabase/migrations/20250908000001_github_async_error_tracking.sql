-- GitHub Async Worker Error Tracking
-- This migration adds error tracking for the GitHub async worker to implement
-- circuit breaker logic based on error thresholds

-- Create table to track GitHub async worker errors
create table if not exists public.github_async_errors (
  id bigint generated by default as identity primary key,
  org text not null,
  method text not null,
  error_data jsonb not null,
  created_at timestamptz not null default now()
);

-- Create indexes for efficient querying
create index if not exists idx_github_async_errors_org_created_at 
  on public.github_async_errors (org, created_at);
create index if not exists idx_github_async_errors_method 
  on public.github_async_errors (method);
create index if not exists idx_github_async_errors_created_at 
  on public.github_async_errors (created_at);

-- Enable RLS
alter table public.github_async_errors enable row level security;

-- Grant permissions to service_role
revoke all on table public.github_async_errors from anon, authenticated;
grant select, insert, update, delete on table public.github_async_errors to service_role;

-- Create RLS policies
drop policy if exists github_async_errors_srv_select on public.github_async_errors;
create policy github_async_errors_srv_select 
  on public.github_async_errors for select to service_role using (true);

drop policy if exists github_async_errors_srv_insert 
  on public.github_async_errors;
create policy github_async_errors_srv_insert 
  on public.github_async_errors for insert to service_role with check (true);

drop policy if exists github_async_errors_srv_update 
  on public.github_async_errors;
create policy github_async_errors_srv_update 
  on public.github_async_errors for update to service_role using (true) with check (true);

drop policy if exists github_async_errors_srv_delete 
  on public.github_async_errors;
create policy github_async_errors_srv_delete 
  on public.github_async_errors for delete to service_role using (true);

-- Function to record GitHub async errors
create or replace function public.record_github_async_error(
  p_org text,
  p_method text,
  p_error_data jsonb
) returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.github_async_errors (org, method, error_data)
  values (p_org, p_method, p_error_data);
end;
$$;

-- Grant execute permission to service_role
revoke all on function public.record_github_async_error(text, text, jsonb) from public;
grant execute on function public.record_github_async_error(text, text, jsonb) to service_role;

-- Function to check error threshold within a time window
create or replace function public.check_github_error_threshold(
  p_org text,
  p_threshold integer,
  p_window_minutes integer
) returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  v_error_count integer;
  v_window_start timestamptz;
begin
  -- Calculate the start of the time window
  v_window_start := now() - (p_window_minutes || ' minutes')::interval;
  
  -- Count errors for this org within the time window
  select count(*)
  into v_error_count
  from public.github_async_errors
  where org = p_org
    and created_at >= v_window_start;
  
  return v_error_count;
end;
$$;

-- Grant execute permission to service_role
revoke all on function public.check_github_error_threshold(text, integer, integer) from public;
grant execute on function public.check_github_error_threshold(text, integer, integer) to service_role;

-- Update the existing open_github_circuit function to handle error_threshold and immediate_error event types
create or replace function public.open_github_circuit(
  p_scope text,
  p_key text,
  p_event text, -- 'primary' | 'secondary' | 'extreme' | 'error_threshold' | 'immediate_error'
  p_retry_after_seconds integer default null,
  p_reason text default null
) returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  v_row public.github_circuit_breakers%rowtype;
  v_base_seconds integer;
  v_trip_count integer;
begin
  select * into v_row from public.github_circuit_breakers where scope = p_scope and key = p_key for update;

  -- Determine base seconds by event type
  if p_event = 'extreme' then
    v_base_seconds := 43200; -- 12h
  elsif p_event = 'secondary' then
    v_base_seconds := 180; -- 3m
  elsif p_event = 'primary' then
    v_base_seconds := 60; -- 1m
  elsif p_event = 'error_threshold' then
    v_base_seconds := coalesce(p_retry_after_seconds, 28800); -- 8h default for error threshold
  elsif p_event = 'immediate_error' then
    v_base_seconds := coalesce(p_retry_after_seconds, 30); -- 30s default for immediate errors
  else
    v_base_seconds := coalesce(p_retry_after_seconds, 60);
  end if;

  if not found then
    insert into public.github_circuit_breakers(scope, key, state, open_until, last_reason, updated_at, trip_count)
    values (p_scope, p_key, 'open', now() + make_interval(secs => v_base_seconds), p_reason, now(), 1);
    v_trip_count := 1;
  else
    if v_row.state = 'open' and (v_row.open_until is null or v_row.open_until > now()) then
      -- Already OPEN: do not count as another trip; optionally extend window modestly
      v_trip_count := v_row.trip_count; -- unchanged
      -- For error_threshold and immediate_error events, don't extend the window with exponential backoff
      if p_event in ('error_threshold', 'immediate_error') then
        v_base_seconds := coalesce(p_retry_after_seconds, 
          case when p_event = 'error_threshold' then 28800 else 30 end); -- Keep original duration
        -- For immediate_error, only extend if current window is shorter
        if p_event = 'immediate_error' then
          v_row.open_until := greatest(v_row.open_until, now() + make_interval(secs => v_base_seconds));
        else
          -- For error_threshold, extend the window
          v_row.open_until := greatest(v_row.open_until, now() + make_interval(secs => v_base_seconds));
        end if;
      else
        v_base_seconds := least(43200, cast(v_base_seconds * power(2, v_trip_count - 1) as integer)); -- extend window but don't escalate count
        v_row.open_until := greatest(v_row.open_until, now() + make_interval(secs => v_base_seconds));
      end if;
      update public.github_circuit_breakers
        set open_until = v_row.open_until,
            last_reason = coalesce(p_reason, v_row.last_reason),
            updated_at = now()
        where scope = p_scope and key = p_key;
      -- Do NOT insert an event when already open
      return v_trip_count;
    else
      -- Transition CLOSED/expired -> OPEN: this is a new trip
      -- For immediate_error events, don't increment trip count as they are temporary
      if p_event = 'immediate_error' then
        v_trip_count := v_row.trip_count; -- Don't increment for immediate errors
      else
        v_trip_count := v_row.trip_count + 1;
      end if;
      
      if v_trip_count >= 3 and p_event not in ('error_threshold', 'immediate_error') then
        v_row.open_until := now() + interval '24 hours';
      else
        -- For error_threshold and immediate_error, use the specified duration without exponential backoff
        if p_event in ('error_threshold', 'immediate_error') then
          v_base_seconds := coalesce(p_retry_after_seconds, 
            case when p_event = 'error_threshold' then 28800 else 30 end); -- 8h or 30s
        else
          v_base_seconds := least(43200, cast(v_base_seconds * power(2, v_trip_count - 1) as integer));
        end if;
        v_row.open_until := now() + make_interval(secs => v_base_seconds);
      end if;
      v_row.state := 'open';
      update public.github_circuit_breakers
        set state = v_row.state,
            open_until = v_row.open_until,
            last_reason = coalesce(p_reason, v_row.last_reason),
            updated_at = now(),
            trip_count = v_trip_count
        where scope = p_scope and key = p_key;
    end if;
  end if;

  -- Log event only on new trip
  insert into public.github_circuit_breaker_events(scope, key, reason)
  values (p_scope, p_key, coalesce(p_reason, 'unspecified'));

  return (select trip_count from public.github_circuit_breakers where scope = p_scope and key = p_key);
end;
$$;

-- Grant execute permission to service_role
revoke all on function public.open_github_circuit(text, text, text, integer, text) from public;
grant execute on function public.open_github_circuit(text, text, text, integer, text) to service_role;

-- Add cleanup job to remove old error records (keep last 7 days)
-- This prevents the table from growing indefinitely
create or replace function public.cleanup_github_async_errors()
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  delete from public.github_async_errors
  where created_at < now() - interval '7 days';
end;
$$;

-- Grant execute permission to service_role
revoke all on function public.cleanup_github_async_errors() from public;
grant execute on function public.cleanup_github_async_errors() to service_role;

-- Schedule cleanup job to run daily at 2 AM
select cron.unschedule('cleanup-github-async-errors-daily')
where exists (select 1 from cron.job where jobname = 'cleanup-github-async-errors-daily');

select cron.schedule(
  'cleanup-github-async-errors-daily',
  '0 2 * * *', -- Daily at 2 AM
  'select public.cleanup_github_async_errors();'
);
