-- Invitation System Implementation
-- This migration adds support for course invitations where users can be pre-invited
-- before they have accounts, and matched via their SIS ID when they log in

-- 1. Add sis_user_id column to users table
ALTER TABLE "public"."users" 
ADD COLUMN "sis_user_id" text UNIQUE;
ALTER TABLE "public"."profiles" 
DROP COLUMN "sis_user_id";

-- Add index for faster lookups
CREATE INDEX IF NOT EXISTS idx_users_sis_user_id ON "public"."users" ("sis_user_id");

-- 2. Create invitations table
CREATE TABLE IF NOT EXISTS "public"."invitations" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT now() NOT NULL,
    "class_id" bigint NOT NULL,
    "role" public.app_role NOT NULL,
    "sis_user_id" text NOT NULL,
    "email" text,
    "name" text,
    "public_profile_id" uuid NOT NULL,
    "private_profile_id" uuid NOT NULL,
    "status" text DEFAULT 'pending' NOT NULL CHECK (status IN ('pending', 'accepted', 'expired', 'cancelled')),
    "invited_by" uuid,
    "accepted_at" timestamp with time zone,
    "expires_at" timestamp with time zone DEFAULT (now() + interval '30 days'),
    "class_section_id" bigint,
    "lab_section_id" bigint,
    
    CONSTRAINT fk_invitations_class_id FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE,
    CONSTRAINT fk_invitations_public_profile_id FOREIGN KEY (public_profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE,
    CONSTRAINT fk_invitations_private_profile_id FOREIGN KEY (private_profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE,
    CONSTRAINT fk_invitations_invited_by FOREIGN KEY (invited_by) REFERENCES public.users(user_id) ON DELETE SET NULL,
    CONSTRAINT fk_invitations_class_section_id FOREIGN KEY (class_section_id) REFERENCES public.class_sections(id) ON DELETE SET NULL,
    CONSTRAINT fk_invitations_lab_section_id FOREIGN KEY (lab_section_id) REFERENCES public.lab_sections(id) ON DELETE SET NULL,
    
    -- Ensure one invitation per sis_user_id per class
    UNIQUE (class_id, sis_user_id)
);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_invitations_class_id ON "public"."invitations" ("class_id");
CREATE INDEX IF NOT EXISTS idx_invitations_sis_user_id ON "public"."invitations" ("sis_user_id");
CREATE INDEX IF NOT EXISTS idx_invitations_status ON "public"."invitations" ("status");
CREATE INDEX IF NOT EXISTS idx_invitations_expires_at ON "public"."invitations" ("expires_at");
CREATE INDEX IF NOT EXISTS idx_invitations_class_section_id ON "public"."invitations" ("class_section_id");
CREATE INDEX IF NOT EXISTS idx_invitations_lab_section_id ON "public"."invitations" ("lab_section_id");

-- Enable RLS on invitations table
ALTER TABLE "public"."invitations" ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for invitations table
CREATE POLICY "Users can view invitations for classes they belong to" ON "public"."invitations"
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.user_roles ur
      WHERE ur.user_id = auth.uid()
        AND ur.class_id = invitations.class_id
        AND ur.role IN ('instructor', 'grader')
    )
  );

CREATE POLICY "Instructors can manage invitations for their classes" ON "public"."invitations"
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.user_roles ur
      WHERE ur.user_id = auth.uid()
        AND ur.class_id = invitations.class_id
        AND ur.role = 'instructor'
    )
  );

-- 3. Add invitation_id column to user_roles to track which invitation was used
ALTER TABLE "public"."user_roles" 
ADD COLUMN "invitation_id" bigint,
ADD CONSTRAINT fk_user_roles_invitation_id FOREIGN KEY (invitation_id) REFERENCES public.invitations(id) ON DELETE SET NULL;

CREATE INDEX IF NOT EXISTS idx_user_roles_invitation_id ON "public"."user_roles" ("invitation_id");

-- 4. Create function to handle invitation acceptance when sis_user_id is set
CREATE OR REPLACE FUNCTION handle_user_sis_id_update()
RETURNS TRIGGER AS $$
BEGIN
    -- Only proceed if sis_user_id was just set (was NULL, now has value)
    IF OLD.sis_user_id IS NULL AND NEW.sis_user_id IS NOT NULL THEN
        -- Find any pending invitations for this sis_user_id
        INSERT INTO public.user_roles (
            user_id,
            class_id,
            role,
            public_profile_id,
            private_profile_id,
            invitation_id,
            class_section_id,
            lab_section_id
        )
        SELECT 
            NEW.user_id,
            i.class_id,
            i.role,
            i.public_profile_id,
            i.private_profile_id,
            i.id,
            i.class_section_id,
            i.lab_section_id
        FROM public.invitations i
        WHERE i.sis_user_id = NEW.sis_user_id 
          AND i.status = 'pending'
          AND (i.expires_at IS NULL OR i.expires_at > NOW())
        ON CONFLICT (user_id, class_id) DO UPDATE SET
            role = CASE 
                WHEN EXCLUDED.role = 'instructor' THEN 'instructor'
                WHEN EXCLUDED.role = 'grader' AND user_roles.role != 'instructor' THEN 'grader'
                ELSE user_roles.role
            END,
            invitation_id = EXCLUDED.invitation_id,
            class_section_id = EXCLUDED.class_section_id,
            lab_section_id = EXCLUDED.lab_section_id;

        -- Mark invitations as accepted
        UPDATE public.invitations 
        SET status = 'accepted', 
            accepted_at = NOW(),
            updated_at = NOW()
        WHERE sis_user_id = NEW.sis_user_id 
          AND status = 'pending'
          AND (expires_at IS NULL OR expires_at > NOW());
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger on users table
DROP TRIGGER IF EXISTS trigger_user_sis_id_update ON public.users;
CREATE TRIGGER trigger_user_sis_id_update
    AFTER UPDATE ON public.users
    FOR EACH ROW
    WHEN (OLD.sis_user_id IS DISTINCT FROM NEW.sis_user_id)
    EXECUTE FUNCTION handle_user_sis_id_update();

-- 5. Create function to create invitations with pre-created profiles
CREATE OR REPLACE FUNCTION create_invitation(
    p_class_id bigint,
    p_role public.app_role,
    p_sis_user_id text,
    p_email text DEFAULT NULL,
    p_name text DEFAULT NULL,
    p_invited_by uuid DEFAULT auth.uid(),
    p_class_section_id bigint DEFAULT NULL,
    p_lab_section_id bigint DEFAULT NULL
)
RETURNS bigint AS $$
DECLARE
    v_public_profile_id uuid;
    v_private_profile_id uuid;
    v_invitation_id bigint;
    v_display_name text;
BEGIN
    -- Validate that the calling user is an instructor for this class or admin
    -- This function checks instructor role OR admin role globally, and respects disabled status
    IF NOT (authorizeforclassinstructor(p_class_id) OR authorize_for_admin()) THEN
        RAISE EXCEPTION 'Only instructors or admins can create invitations for this class';
    END IF;

    -- Check if invitation already exists
    IF EXISTS (
        SELECT 1 FROM public.invitations
        WHERE class_id = p_class_id AND sis_user_id = p_sis_user_id AND status = 'pending'
    ) THEN
        RAISE EXCEPTION 'Invitation already exists for this user in this class';
    END IF;

    -- Set display name (use provided name or email prefix)
    v_display_name := COALESCE(p_name, split_part(p_email, '@', 1), p_sis_user_id);

    -- Create public profile
    INSERT INTO public.profiles (
        name,
        class_id,
        is_private_profile
    ) VALUES (
        v_display_name,
        p_class_id,
        false
    ) RETURNING id INTO v_public_profile_id;

    -- Create private profile
    INSERT INTO public.profiles (
        name,
        class_id,
        is_private_profile
    ) VALUES (
        v_display_name,
        p_class_id,
        true
    ) RETURNING id INTO v_private_profile_id;

    -- Create invitation
    INSERT INTO public.invitations (
        class_id,
        role,
        sis_user_id,
        email,
        name,
        public_profile_id,
        private_profile_id,
        invited_by,
        class_section_id,
        lab_section_id
    ) VALUES (
        p_class_id,
        p_role,
        p_sis_user_id,
        p_email,
        p_name,
        v_public_profile_id,
        v_private_profile_id,
        p_invited_by,
        p_class_section_id,
        p_lab_section_id
    ) RETURNING id INTO v_invitation_id;

    RETURN v_invitation_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6. Grant appropriate permissions

-- Update updated_at column automatically
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_invitations_updated_at 
    BEFORE UPDATE ON public.invitations 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- Add comment for documentation
COMMENT ON TABLE public.invitations IS 'Stores course invitations for users who don''t have accounts yet. Users are matched by sis_user_id when they log in.';
COMMENT ON COLUMN public.invitations.sis_user_id IS 'Student Information System user ID used to match users when they log in';
COMMENT ON COLUMN public.invitations.status IS 'Status of invitation: pending, accepted, expired, or cancelled';
COMMENT ON FUNCTION create_invitation IS 'Creates a course invitation with pre-created profiles for a user identified by sis_user_id';
COMMENT ON FUNCTION handle_user_sis_id_update IS 'Automatically converts pending invitations to enrollments when a user''s sis_user_id is set';
