create type "public"."discord_channel_type" as enum ('general', 'assignment', 'lab', 'office_hours', 'regrades', 'scheduling', 'operations');

create type "public"."discord_resource_type" as enum ('help_request', 'regrade_request');

create table "public"."calendar_events" (
    "id" bigint generated by default as identity not null,
    "class_id" bigint not null,
    "calendar_type" text not null,
    "uid" text not null,
    "title" text not null,
    "description" text,
    "start_time" timestamp with time zone not null,
    "end_time" timestamp with time zone not null,
    "location" text,
    "queue_name" text,
    "organizer_name" text,
    "raw_ics_data" jsonb,
    "start_announced_at" timestamp with time zone,
    "end_announced_at" timestamp with time zone,
    "change_announced_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."calendar_events" enable row level security;

create table "public"."calendar_sync_state" (
    "id" bigint generated by default as identity not null,
    "class_id" bigint not null,
    "calendar_type" text not null,
    "last_sync_at" timestamp with time zone,
    "last_etag" text,
    "last_hash" text,
    "sync_error" text,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."calendar_sync_state" enable row level security;

create table "public"."class_staff_settings" (
    "id" bigint generated by default as identity not null,
    "class_id" bigint not null,
    "setting_key" text not null,
    "setting_value" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."class_staff_settings" enable row level security;

create table "public"."discord_async_worker_dlq_messages" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "original_msg_id" bigint,
    "method" text not null,
    "envelope" jsonb not null,
    "error_message" text,
    "error_type" text,
    "retry_count" integer not null,
    "last_error_context" jsonb,
    "class_id" bigint,
    "debug_id" text,
    "log_id" bigint
);


alter table "public"."discord_async_worker_dlq_messages" enable row level security;

create table "public"."discord_channels" (
    "id" bigint generated by default as identity not null,
    "class_id" bigint not null,
    "discord_channel_id" text not null,
    "channel_type" discord_channel_type not null,
    "resource_id" bigint,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."discord_channels" enable row level security;

create table "public"."discord_invites" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "class_id" bigint not null,
    "guild_id" text not null,
    "invite_code" text not null,
    "invite_url" text not null,
    "expires_at" timestamp with time zone not null,
    "used" boolean not null default false,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."discord_invites" enable row level security;

create table "public"."discord_messages" (
    "id" bigint generated by default as identity not null,
    "class_id" bigint not null,
    "discord_message_id" text not null,
    "discord_channel_id" text not null,
    "resource_type" discord_resource_type not null,
    "resource_id" bigint not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."discord_messages" enable row level security;

create table "public"."discord_roles" (
    "id" bigint generated by default as identity not null,
    "class_id" bigint not null,
    "discord_role_id" text not null,
    "role_type" text not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."discord_roles" enable row level security;

alter table "public"."classes" add column "discord_channel_group_id" text;

alter table "public"."classes" add column "discord_server_id" text;

alter table "public"."classes" add column "events_ics_url" text;

alter table "public"."classes" add column "office_hours_ics_url" text;

alter table "public"."notification_preferences" add column "regrade_request_notification" help_request_creation_notification not null default 'all'::help_request_creation_notification;

alter table "public"."users" add column "discord_id" text;

alter table "public"."users" add column "discord_username" text;

CREATE UNIQUE INDEX calendar_events_class_id_calendar_type_uid_key ON public.calendar_events USING btree (class_id, calendar_type, uid);

CREATE UNIQUE INDEX calendar_events_pkey ON public.calendar_events USING btree (id);

CREATE UNIQUE INDEX calendar_sync_state_class_id_calendar_type_key ON public.calendar_sync_state USING btree (class_id, calendar_type);

CREATE UNIQUE INDEX calendar_sync_state_pkey ON public.calendar_sync_state USING btree (id);

CREATE UNIQUE INDEX class_staff_settings_class_id_setting_key_key ON public.class_staff_settings USING btree (class_id, setting_key);

CREATE UNIQUE INDEX class_staff_settings_pkey ON public.class_staff_settings USING btree (id);

CREATE INDEX discord_async_worker_dlq_messages_class_id_idx ON public.discord_async_worker_dlq_messages USING btree (class_id);

CREATE INDEX discord_async_worker_dlq_messages_created_at_idx ON public.discord_async_worker_dlq_messages USING btree (created_at DESC);

CREATE INDEX discord_async_worker_dlq_messages_method_idx ON public.discord_async_worker_dlq_messages USING btree (method);

CREATE UNIQUE INDEX discord_async_worker_dlq_messages_pkey ON public.discord_async_worker_dlq_messages USING btree (id);

CREATE UNIQUE INDEX discord_channels_class_id_channel_type_resource_id_key ON public.discord_channels USING btree (class_id, channel_type, resource_id);

CREATE UNIQUE INDEX discord_channels_class_id_discord_channel_id_key ON public.discord_channels USING btree (class_id, discord_channel_id);

CREATE UNIQUE INDEX discord_channels_pkey ON public.discord_channels USING btree (id);

CREATE UNIQUE INDEX discord_invites_pkey ON public.discord_invites USING btree (id);

CREATE UNIQUE INDEX discord_invites_user_id_class_id_guild_id_key ON public.discord_invites USING btree (user_id, class_id, guild_id);

CREATE UNIQUE INDEX discord_messages_class_id_discord_message_id_key ON public.discord_messages USING btree (class_id, discord_message_id);

CREATE UNIQUE INDEX discord_messages_class_id_resource_type_resource_id_key ON public.discord_messages USING btree (class_id, resource_type, resource_id);

CREATE UNIQUE INDEX discord_messages_pkey ON public.discord_messages USING btree (id);

CREATE UNIQUE INDEX discord_roles_class_id_role_type_key ON public.discord_roles USING btree (class_id, role_type);

CREATE UNIQUE INDEX discord_roles_pkey ON public.discord_roles USING btree (id);

CREATE INDEX idx_calendar_events_class_type ON public.calendar_events USING btree (class_id, calendar_type);

CREATE INDEX idx_calendar_events_end_time ON public.calendar_events USING btree (end_time);

CREATE INDEX idx_calendar_events_start_time ON public.calendar_events USING btree (start_time);

CREATE INDEX idx_calendar_events_unannounced_end ON public.calendar_events USING btree (class_id, end_time) WHERE (end_announced_at IS NULL);

CREATE INDEX idx_calendar_events_unannounced_start ON public.calendar_events USING btree (class_id, start_time) WHERE (start_announced_at IS NULL);

CREATE INDEX idx_calendar_sync_state_class ON public.calendar_sync_state USING btree (class_id);

CREATE INDEX idx_class_staff_settings_class ON public.class_staff_settings USING btree (class_id);

CREATE INDEX idx_class_staff_settings_key ON public.class_staff_settings USING btree (class_id, setting_key);

CREATE INDEX idx_discord_channels_class_id ON public.discord_channels USING btree (class_id);

CREATE INDEX idx_discord_channels_type_resource ON public.discord_channels USING btree (channel_type, resource_id);

CREATE INDEX idx_discord_invites_active ON public.discord_invites USING btree (user_id, class_id, used, expires_at) WHERE (used = false);

CREATE INDEX idx_discord_invites_class_id ON public.discord_invites USING btree (class_id);

CREATE INDEX idx_discord_invites_user_id ON public.discord_invites USING btree (user_id);

CREATE INDEX idx_discord_messages_channel ON public.discord_messages USING btree (discord_channel_id);

CREATE INDEX idx_discord_messages_class_resource ON public.discord_messages USING btree (class_id, resource_type, resource_id);

CREATE INDEX idx_discord_roles_class_id ON public.discord_roles USING btree (class_id);

CREATE INDEX idx_discord_roles_type ON public.discord_roles USING btree (class_id, role_type);

alter table "public"."calendar_events" add constraint "calendar_events_pkey" PRIMARY KEY using index "calendar_events_pkey";

alter table "public"."calendar_sync_state" add constraint "calendar_sync_state_pkey" PRIMARY KEY using index "calendar_sync_state_pkey";

alter table "public"."class_staff_settings" add constraint "class_staff_settings_pkey" PRIMARY KEY using index "class_staff_settings_pkey";

alter table "public"."discord_async_worker_dlq_messages" add constraint "discord_async_worker_dlq_messages_pkey" PRIMARY KEY using index "discord_async_worker_dlq_messages_pkey";

alter table "public"."discord_channels" add constraint "discord_channels_pkey" PRIMARY KEY using index "discord_channels_pkey";

alter table "public"."discord_invites" add constraint "discord_invites_pkey" PRIMARY KEY using index "discord_invites_pkey";

alter table "public"."discord_messages" add constraint "discord_messages_pkey" PRIMARY KEY using index "discord_messages_pkey";

alter table "public"."discord_roles" add constraint "discord_roles_pkey" PRIMARY KEY using index "discord_roles_pkey";

alter table "public"."calendar_events" add constraint "calendar_events_calendar_type_check" CHECK ((calendar_type = ANY (ARRAY['office_hours'::text, 'events'::text]))) not valid;

alter table "public"."calendar_events" validate constraint "calendar_events_calendar_type_check";

alter table "public"."calendar_events" add constraint "calendar_events_class_id_calendar_type_uid_key" UNIQUE using index "calendar_events_class_id_calendar_type_uid_key";

alter table "public"."calendar_events" add constraint "calendar_events_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON DELETE CASCADE not valid;

alter table "public"."calendar_events" validate constraint "calendar_events_class_id_fkey";

alter table "public"."calendar_sync_state" add constraint "calendar_sync_state_calendar_type_check" CHECK ((calendar_type = ANY (ARRAY['office_hours'::text, 'events'::text]))) not valid;

alter table "public"."calendar_sync_state" validate constraint "calendar_sync_state_calendar_type_check";

alter table "public"."calendar_sync_state" add constraint "calendar_sync_state_class_id_calendar_type_key" UNIQUE using index "calendar_sync_state_class_id_calendar_type_key";

alter table "public"."calendar_sync_state" add constraint "calendar_sync_state_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON DELETE CASCADE not valid;

alter table "public"."calendar_sync_state" validate constraint "calendar_sync_state_class_id_fkey";

alter table "public"."class_staff_settings" add constraint "class_staff_settings_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON DELETE CASCADE not valid;

alter table "public"."class_staff_settings" validate constraint "class_staff_settings_class_id_fkey";

alter table "public"."class_staff_settings" add constraint "class_staff_settings_class_id_setting_key_key" UNIQUE using index "class_staff_settings_class_id_setting_key_key";

alter table "public"."discord_async_worker_dlq_messages" add constraint "discord_async_worker_dlq_messages_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON DELETE SET NULL not valid;

alter table "public"."discord_async_worker_dlq_messages" validate constraint "discord_async_worker_dlq_messages_class_id_fkey";

alter table "public"."discord_channels" add constraint "discord_channels_class_id_channel_type_resource_id_key" UNIQUE using index "discord_channels_class_id_channel_type_resource_id_key";

alter table "public"."discord_channels" add constraint "discord_channels_class_id_discord_channel_id_key" UNIQUE using index "discord_channels_class_id_discord_channel_id_key";

alter table "public"."discord_channels" add constraint "discord_channels_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON DELETE CASCADE not valid;

alter table "public"."discord_channels" validate constraint "discord_channels_class_id_fkey";

alter table "public"."discord_invites" add constraint "discord_invites_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON DELETE CASCADE not valid;

alter table "public"."discord_invites" validate constraint "discord_invites_class_id_fkey";

alter table "public"."discord_invites" add constraint "discord_invites_user_id_class_id_guild_id_key" UNIQUE using index "discord_invites_user_id_class_id_guild_id_key";

alter table "public"."discord_invites" add constraint "discord_invites_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE not valid;

alter table "public"."discord_invites" validate constraint "discord_invites_user_id_fkey";

alter table "public"."discord_messages" add constraint "discord_messages_class_id_discord_message_id_key" UNIQUE using index "discord_messages_class_id_discord_message_id_key";

alter table "public"."discord_messages" add constraint "discord_messages_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON DELETE CASCADE not valid;

alter table "public"."discord_messages" validate constraint "discord_messages_class_id_fkey";

alter table "public"."discord_messages" add constraint "discord_messages_class_id_resource_type_resource_id_key" UNIQUE using index "discord_messages_class_id_resource_type_resource_id_key";

alter table "public"."discord_roles" add constraint "discord_roles_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON DELETE CASCADE not valid;

alter table "public"."discord_roles" validate constraint "discord_roles_class_id_fkey";

alter table "public"."discord_roles" add constraint "discord_roles_class_id_role_type_key" UNIQUE using index "discord_roles_class_id_role_type_key";

alter table "public"."discord_roles" add constraint "discord_roles_role_type_check" CHECK ((role_type = ANY (ARRAY['student'::text, 'grader'::text, 'instructor'::text]))) not valid;

alter table "public"."discord_roles" validate constraint "discord_roles_role_type_check";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.broadcast_calendar_events_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  class_id_value bigint;
  calendar_type_value text;
  payload jsonb;
BEGIN
  IF TG_OP = 'DELETE' THEN
    class_id_value := OLD.class_id;
    calendar_type_value := OLD.calendar_type;
  ELSE
    class_id_value := NEW.class_id;
    calendar_type_value := NEW.calendar_type;
  END IF;

  -- Standard table_change payload format
  payload := jsonb_build_object(
    'type', 'table_change',
    'operation', TG_OP,
    'table', TG_TABLE_NAME,
    'data', CASE WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE to_jsonb(NEW) END,
    'class_id', class_id_value,
    'timestamp', NOW()
  );

  -- office_hours ‚Üí students channel (+ staff)
  IF calendar_type_value = 'office_hours' THEN
    PERFORM public.safe_broadcast(payload, 'broadcast', format('class:%s:students', class_id_value), true);
  END IF;
  
  -- Always send to staff (they see both calendar types)
  PERFORM public.safe_broadcast(payload, 'broadcast', format('class:%s:staff', class_id_value), true);

  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.broadcast_discord_channel_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_class_id bigint;
  v_row_id bigint;
  v_operation text;
  v_data jsonb;
BEGIN
  -- Determine the operation and get relevant data
  IF TG_OP = 'DELETE' THEN
    v_class_id := OLD.class_id;
    v_row_id := OLD.id;
    v_operation := 'DELETE';
    v_data := row_to_json(OLD)::jsonb;
  ELSE
    v_class_id := NEW.class_id;
    v_row_id := NEW.id;
    v_operation := TG_OP;
    v_data := row_to_json(NEW)::jsonb;
  END IF;

  -- Broadcast to staff channel
  PERFORM realtime.broadcast(
    'class:' || v_class_id || ':staff',
    'broadcast',
    jsonb_build_object(
      'type', 'table_change',
      'table', 'discord_channels',
      'operation', v_operation,
      'row_id', v_row_id,
      'class_id', v_class_id,
      'data', v_data,
      'timestamp', now()::text
    )
  );

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.broadcast_discord_message_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_class_id bigint;
  v_row_id bigint;
  v_operation text;
  v_data jsonb;
BEGIN
  -- Determine the operation and get relevant data
  IF TG_OP = 'DELETE' THEN
    v_class_id := OLD.class_id;
    v_row_id := OLD.id;
    v_operation := 'DELETE';
    v_data := row_to_json(OLD)::jsonb;
  ELSE
    v_class_id := NEW.class_id;
    v_row_id := NEW.id;
    v_operation := TG_OP;
    v_data := row_to_json(NEW)::jsonb;
  END IF;

  -- Broadcast to staff channel
  PERFORM realtime.broadcast(
    'class:' || v_class_id || ':staff',
    'broadcast',
    jsonb_build_object(
      'type', 'table_change',
      'table', 'discord_messages',
      'operation', v_operation,
      'row_id', v_row_id,
      'class_id', v_class_id,
      'data', v_data,
      'timestamp', now()::text
    )
  );

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_discord_role_sync_after_link(p_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_role RECORD;
BEGIN
  -- Get all active roles for this user in classes with Discord servers
  FOR v_user_role IN
    SELECT ur.user_id, ur.class_id, ur.role
    FROM public.user_roles ur
    INNER JOIN public.classes c ON c.id = ur.class_id
    WHERE ur.user_id = p_user_id
      AND ur.disabled = false
      AND c.discord_server_id IS NOT NULL
  LOOP
    -- Enqueue role sync for each role
    -- This will check if user is in server and create invite if needed
    PERFORM public.enqueue_discord_role_sync(
      v_user_role.user_id,
      v_user_role.class_id,
      v_user_role.role,
      'add'
    );
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enqueue_discord_batch_role_sync()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Enqueue batch_role_sync message to the discord async worker
  PERFORM pgmq_public.send(
    queue_name := 'discord_async_calls',
    message := jsonb_build_object(
      'method', 'batch_role_sync',
      'args', '{}'::jsonb
    )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enqueue_discord_channel_creation(p_class_id bigint, p_channel_type discord_channel_type, p_resource_id bigint DEFAULT NULL::bigint, p_channel_name text DEFAULT NULL::text, p_guild_id text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_guild_id text;
  v_channel_group_id text;
  v_class_slug text;
  v_channel_name text;
BEGIN
  -- Get Discord server info from class
  SELECT c.discord_server_id, c.discord_channel_group_id, c.slug
  INTO v_guild_id, v_channel_group_id, v_class_slug
  FROM public.classes c
  WHERE c.id = p_class_id;

  -- Use provided guild_id or fall back to class's discord_server_id
  v_guild_id := COALESCE(p_guild_id, v_guild_id);

  -- Skip if no Discord server configured
  IF v_guild_id IS NULL THEN
    RETURN;
  END IF;

  -- Determine channel name if not provided
  IF p_channel_name IS NULL THEN
    CASE p_channel_type
      WHEN 'general' THEN
        v_channel_name := COALESCE(v_class_slug, 'general');
      WHEN 'assignment' THEN
        SELECT a.title INTO v_channel_name
        FROM public.assignments a
        WHERE a.id = p_resource_id;
        v_channel_name := COALESCE(v_channel_name, 'assignment-' || p_resource_id);
        v_channel_name := 'HW: ' || v_channel_name;
      WHEN 'lab' THEN
        SELECT ls.name INTO v_channel_name
        FROM public.lab_sections ls
        WHERE ls.id = p_resource_id;
        v_channel_name := COALESCE(v_channel_name, 'lab-' || p_resource_id);
        v_channel_name := 'Lab: ' || v_channel_name;
      WHEN 'office_hours' THEN
        SELECT hq.name INTO v_channel_name
        FROM public.help_queues hq
        WHERE hq.id = p_resource_id;
        v_channel_name := COALESCE(v_channel_name, 'office-hours-' || p_resource_id);
        v_channel_name := 'OH: ' || v_channel_name;
      WHEN 'regrades' THEN
        v_channel_name := 'Regrades';
      WHEN 'scheduling' THEN
        v_channel_name := 'scheduling';
      WHEN 'operations' THEN
        v_channel_name := 'operations';
      ELSE
        v_channel_name := 'channel';
    END CASE;
  ELSE
    v_channel_name := p_channel_name;
    -- Add prefix based on channel type if not already present
    IF p_channel_type = 'assignment' AND NOT v_channel_name LIKE 'HW:%' THEN
      v_channel_name := 'HW: ' || v_channel_name;
    ELSIF p_channel_type = 'lab' AND NOT v_channel_name LIKE 'Lab:%' THEN
      v_channel_name := 'Lab: ' || v_channel_name;
    ELSIF p_channel_type = 'office_hours' AND NOT v_channel_name LIKE 'OH:%' THEN
      v_channel_name := 'OH: ' || v_channel_name;
    END IF;
  END IF;

  -- Enqueue channel creation
  PERFORM pgmq_public.send(
    queue_name := 'discord_async_calls',
    message := jsonb_build_object(
      'method', 'create_channel',
      'args', jsonb_build_object(
        'guild_id', v_guild_id,
        'name', v_channel_name,
        'type', 0, -- Text channel
        'parent_id', v_channel_group_id
      ),
      'class_id', p_class_id,
      'channel_type', p_channel_type,
      'resource_id', p_resource_id
    )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enqueue_discord_help_request_message(p_help_request_id bigint, p_action text DEFAULT 'created'::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_help_request RECORD;
  v_class RECORD;
  v_discord_channel_id text;
  v_student_names text;
  v_message_content text;
  v_embed jsonb;
  v_status_color integer;
  v_status_emoji text;
  v_feedback RECORD;
  v_feedback_emoji text;
BEGIN
  -- Get help request details
  SELECT 
    hr.id,
    hr.class_id,
    hr.help_queue,
    hr.status,
    hr.request,
    hr.created_at,
    hr.created_by
  INTO v_help_request
  FROM public.help_requests hr
  WHERE hr.id = p_help_request_id;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  -- Get class Discord info
  SELECT c.discord_server_id, c.slug
  INTO v_class
  FROM public.classes c
  WHERE c.id = v_help_request.class_id;

  -- Skip if no Discord server configured
  IF v_class.discord_server_id IS NULL THEN
    RETURN;
  END IF;

  -- Get Discord channel for this queue
  SELECT dc.discord_channel_id
  INTO v_discord_channel_id
  FROM public.discord_channels dc
  WHERE dc.class_id = v_help_request.class_id
    AND dc.channel_type = 'office_hours'
    AND dc.resource_id = v_help_request.help_queue;

  -- Create channel if it doesn't exist
  IF v_discord_channel_id IS NULL THEN
    PERFORM public.enqueue_discord_channel_creation(
      v_help_request.class_id,
      'office_hours',
      v_help_request.help_queue,
      (SELECT name FROM public.help_queues WHERE id = v_help_request.help_queue),
      v_class.discord_server_id
    );
    -- Wait a bit for channel creation, then retry (or skip for now)
    RETURN;
  END IF;

  -- Get student names (may be empty if students haven't been added yet)
  SELECT string_agg(p.name, ', ')
  INTO v_student_names
  FROM public.help_request_students hrs
  JOIN public.profiles p ON p.id = hrs.profile_id
  WHERE hrs.help_request_id = p_help_request_id;

  -- Fall back to creator's name if no students found yet
  IF v_student_names IS NULL THEN
    SELECT p.name INTO v_student_names
    FROM public.profiles p
    WHERE p.id = v_help_request.created_by;
  END IF;

  -- Determine status color and emoji
  CASE v_help_request.status
    WHEN 'open' THEN
      v_status_color := 3447003; -- Blue
      v_status_emoji := 'üîµ';
    WHEN 'in_progress' THEN
      v_status_color := 15105570; -- Orange
      v_status_emoji := 'üü†';
    WHEN 'resolved' THEN
      v_status_color := 3066993; -- Green
      v_status_emoji := '‚úÖ';
    WHEN 'cancelled' THEN
      v_status_color := 9807270; -- Grey
      v_status_emoji := '‚ö™';
    ELSE
      v_status_color := 9807270;
      v_status_emoji := '‚ö™';
  END CASE;

  -- Build message content
  IF p_action = 'created' THEN
    v_message_content := '**New Help Request**';
  ELSIF p_action = 'feedback' THEN
    v_message_content := '**Help Request Feedback Received**';
  ELSE
    v_message_content := format('**Help Request %s**', UPPER(p_action));
  END IF;

  -- Build embed
  v_embed := jsonb_build_object(
    'title', format('Help Request #%s', v_help_request.id),
    'description', LEFT(COALESCE(v_help_request.request, 'No description'), 200),
    'color', v_status_color,
    'fields', jsonb_build_array(
      jsonb_build_object('name', 'Student(s)', 'value', COALESCE(v_student_names, 'Unknown'), 'inline', true),
      jsonb_build_object('name', 'Status', 'value', format('%s %s', v_status_emoji, UPPER(v_help_request.status::text)), 'inline', true)
    ),
    'footer', jsonb_build_object('text', format('Request ID: %s', v_help_request.id)),
    'timestamp', NOW()::text
  );

  -- Get feedback if exists (most recent feedback from any student)
  SELECT hrf.thumbs_up, hrf.comment
  INTO v_feedback
  FROM public.help_request_feedback hrf
  WHERE hrf.help_request_id = p_help_request_id
  ORDER BY hrf.created_at DESC
  LIMIT 1;

  -- Add feedback to embed if exists
  IF v_feedback.thumbs_up IS NOT NULL THEN
    IF v_feedback.thumbs_up THEN
      v_feedback_emoji := 'üëç';
    ELSE
      v_feedback_emoji := 'üëé';
    END IF;
    
    v_embed := jsonb_set(
      v_embed,
      '{fields}',
      (v_embed->'fields') || jsonb_build_object(
        'name', 'Feedback', 
        'value', v_feedback_emoji || COALESCE(' - ' || LEFT(v_feedback.comment, 100), ''), 
        'inline', false
      )
    );
  END IF;

  -- Always check if message already exists first (handles race conditions and updates)
  DECLARE
    v_existing_message_id text;
  BEGIN
    SELECT dm.discord_message_id
    INTO v_existing_message_id
    FROM public.discord_messages dm
    WHERE dm.class_id = v_help_request.class_id
      AND dm.resource_type = 'help_request'
      AND dm.resource_id = p_help_request_id;

    IF v_existing_message_id IS NOT NULL THEN
      -- Update existing message
      PERFORM pgmq_public.send(
        queue_name := 'discord_async_calls',
        message := jsonb_build_object(
          'method', 'update_message',
          'args', jsonb_build_object(
            'channel_id', v_discord_channel_id,
            'message_id', v_existing_message_id,
            'content', v_message_content,
            'embeds', jsonb_build_array(v_embed)
          ),
          'class_id', v_help_request.class_id
        )
      );
      RETURN;
    END IF;
  END;

  -- Send new message (only if no existing message was found)
  PERFORM pgmq_public.send(
    queue_name := 'discord_async_calls',
    message := jsonb_build_object(
      'method', 'send_message',
      'args', jsonb_build_object(
        'channel_id', v_discord_channel_id,
        'content', v_message_content,
        'embeds', jsonb_build_array(v_embed)
      ),
      'class_id', v_help_request.class_id,
      'resource_type', 'help_request',
      'resource_id', p_help_request_id
    )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enqueue_discord_invites_for_existing_users(p_class_id bigint, p_guild_id text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_role RECORD;
  v_discord_role_id text;
BEGIN
  -- For each user who:
  -- 1. Has a role in this class
  -- 2. Has Discord linked
  -- 3. Doesn't already have an active invite
  -- 4. Is active (not disabled)
  FOR v_user_role IN
    SELECT DISTINCT ur.user_id, ur.role, u.discord_id
    FROM public.user_roles ur
    INNER JOIN public.users u ON u.user_id = ur.user_id
    LEFT JOIN public.discord_invites di ON di.user_id = ur.user_id 
      AND di.class_id = ur.class_id 
      AND di.guild_id = p_guild_id
      AND di.used = false
      AND di.expires_at > now()
    WHERE ur.class_id = p_class_id
      AND ur.disabled = false
      AND u.discord_id IS NOT NULL
      AND di.id IS NULL -- No active invite exists
  LOOP
    -- Try to get the Discord role ID for this user's role
    SELECT dr.discord_role_id INTO v_discord_role_id
    FROM public.discord_roles dr
    WHERE dr.class_id = p_class_id
      AND dr.role_type = v_user_role.role::text
    LIMIT 1;
    
    -- If role exists, enqueue role sync (which will create invite if user not in server)
    IF v_discord_role_id IS NOT NULL THEN
      PERFORM public.enqueue_discord_role_sync(
        v_user_role.user_id,
        p_class_id,
        v_user_role.role,
        'add'
      );
    END IF;
    -- If role doesn't exist yet, we'll skip for now
    -- The sync_existing_users_after_roles_created function will handle invites
    -- when roles are created. This ensures we don't enqueue operations with invalid role_ids.
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enqueue_discord_queue_assignment_message(p_queue_assignment_id bigint, p_action text DEFAULT 'started'::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_assignment RECORD;
  v_queue RECORD;
  v_class RECORD;
  v_discord_channel_id text;
  v_ta_name text;
  v_message_content text;
  v_embed jsonb;
BEGIN
  -- Get queue assignment details
  SELECT 
    hqa.id,
    hqa.class_id,
    hqa.help_queue_id,
    hqa.ta_profile_id,
    hqa.is_active,
    hqa.started_at,
    hqa.ended_at
  INTO v_assignment
  FROM public.help_queue_assignments hqa
  WHERE hqa.id = p_queue_assignment_id;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  -- Get class Discord info
  SELECT c.discord_server_id, c.slug
  INTO v_class
  FROM public.classes c
  WHERE c.id = v_assignment.class_id;

  -- Skip if no Discord server configured
  IF v_class.discord_server_id IS NULL THEN
    RETURN;
  END IF;

  -- Get queue info
  SELECT hq.name, hq.id
  INTO v_queue
  FROM public.help_queues hq
  WHERE hq.id = v_assignment.help_queue_id;

  -- Get Discord channel for this queue
  SELECT dc.discord_channel_id
  INTO v_discord_channel_id
  FROM public.discord_channels dc
  WHERE dc.class_id = v_assignment.class_id
    AND dc.channel_type = 'office_hours'
    AND dc.resource_id = v_assignment.help_queue_id;

  -- Skip if no channel found
  IF v_discord_channel_id IS NULL THEN
    RETURN;
  END IF;

  -- Get TA name
  SELECT p.name INTO v_ta_name
  FROM public.profiles p
  WHERE p.id = v_assignment.ta_profile_id;

  v_ta_name := COALESCE(v_ta_name, 'Unknown TA');

  -- Build message content
  IF p_action = 'started' THEN
    v_message_content := format('**%s started working** on %s', v_ta_name, COALESCE(v_queue.name, 'Office Hours'));
    v_embed := jsonb_build_object(
      'title', format('TA Started Working'),
      'description', format('%s is now available to help students', v_ta_name),
      'color', 3066993, -- Green
      'fields', jsonb_build_array(
        jsonb_build_object('name', 'Queue', 'value', COALESCE(v_queue.name, 'Office Hours'), 'inline', true),
        jsonb_build_object('name', 'Started At', 'value', to_char(v_assignment.started_at, 'HH24:MI'), 'inline', true)
      ),
      'timestamp', v_assignment.started_at::text
    );
  ELSIF p_action = 'stopped' THEN
    v_message_content := format('**%s stopped working** on %s', v_ta_name, COALESCE(v_queue.name, 'Office Hours'));
    v_embed := jsonb_build_object(
      'title', format('TA Stopped Working'),
      'description', format('%s is no longer available', v_ta_name),
      'color', 9807270, -- Grey
      'fields', jsonb_build_array(
        jsonb_build_object('name', 'Queue', 'value', COALESCE(v_queue.name, 'Office Hours'), 'inline', true),
        jsonb_build_object('name', 'Ended At', 'value', COALESCE(to_char(v_assignment.ended_at, 'HH24:MI'), 'Now'), 'inline', true)
      ),
      'timestamp', COALESCE(v_assignment.ended_at, NOW())::text
    );
  ELSE
    RETURN;
  END IF;

  -- Enqueue message
  PERFORM pgmq_public.send(
    queue_name := 'discord_async_calls',
    message := jsonb_build_object(
      'method', 'send_message',
      'args', jsonb_build_object(
        'channel_id', v_discord_channel_id,
        'content', v_message_content,
        'embeds', jsonb_build_array(v_embed)
      ),
      'class_id', v_assignment.class_id
    )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enqueue_discord_register_commands()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Enqueue register_commands message to the discord async worker
  PERFORM pgmq_public.send(
    queue_name := 'discord_async_calls',
    message := jsonb_build_object(
      'method', 'register_commands',
      'args', '{}'::jsonb
    )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enqueue_discord_regrade_request_message(p_regrade_request_id bigint, p_action text DEFAULT 'created'::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_regrade_request RECORD;
  v_class RECORD;
  v_discord_channel_id text;
  v_student_name text;
  v_grader_name text;
  v_message_content text;
  v_embed jsonb;
  v_status_color integer;
  v_status_emoji text;
  v_mention_user_id text;
  v_instructor_role_id text;
  v_allowed_mentions jsonb;
BEGIN
  -- Get regrade request details
  SELECT 
    srr.id,
    srr.class_id,
    srr.assignment_id,
    srr.submission_id,
    srr.status,
    srr.assignee,
    srr.created_by,
    srr.escalated_by,
    srr.resolved_by,
    srr.initial_points,
    srr.resolved_points,
    srr.closed_points
  INTO v_regrade_request
  FROM public.submission_regrade_requests srr
  WHERE srr.id = p_regrade_request_id;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  -- Get class Discord info
  SELECT c.discord_server_id, c.slug
  INTO v_class
  FROM public.classes c
  WHERE c.id = v_regrade_request.class_id;

  -- Skip if no Discord server configured
  IF v_class.discord_server_id IS NULL THEN
    RETURN;
  END IF;

  -- Get Discord channel for regrades
  SELECT dc.discord_channel_id
  INTO v_discord_channel_id
  FROM public.discord_channels dc
  WHERE dc.class_id = v_regrade_request.class_id
    AND dc.channel_type = 'regrades';

  -- Create regrades channel if it doesn't exist
  IF v_discord_channel_id IS NULL THEN
    PERFORM public.enqueue_discord_channel_creation(
      v_regrade_request.class_id,
      'regrades',
      NULL,
      'regrades',
      v_class.discord_server_id
    );
    -- Wait a bit for channel creation, then retry (or skip for now)
    RETURN;
  END IF;

  -- Get student name
  SELECT p.name INTO v_student_name
  FROM public.profiles p
  WHERE p.id = v_regrade_request.created_by;

  -- Get grader name
  SELECT p.name INTO v_grader_name
  FROM public.profiles p
  WHERE p.id = v_regrade_request.assignee;

  -- Get Discord user ID for mention
  SELECT u.discord_id INTO v_mention_user_id
  FROM public.users u
  JOIN public.user_roles ur ON ur.user_id = u.user_id
  JOIN public.profiles p ON p.id = v_regrade_request.assignee
  WHERE ur.private_profile_id = v_regrade_request.assignee
    AND ur.class_id = v_regrade_request.class_id
    AND u.discord_id IS NOT NULL
  LIMIT 1;

  -- Get instructor Discord role ID for escalation mentions
  SELECT dr.discord_role_id INTO v_instructor_role_id
  FROM public.discord_roles dr
  WHERE dr.class_id = v_regrade_request.class_id
    AND dr.role_type = 'instructor';

  -- Determine status color and emoji
  CASE v_regrade_request.status
    WHEN 'draft' THEN
      v_status_color := 9807270; -- Grey
      v_status_emoji := 'üìù';
    WHEN 'opened' THEN
      v_status_color := 3447003; -- Blue
      v_status_emoji := 'üîµ';
    WHEN 'resolved' THEN
      v_status_color := 3066993; -- Green
      v_status_emoji := '‚úÖ';
    WHEN 'escalated' THEN
      v_status_color := 15158332; -- Red
      v_status_emoji := 'üö®';
    WHEN 'closed' THEN
      v_status_color := 9807270; -- Grey
      v_status_emoji := 'üîí';
    ELSE
      v_status_color := 9807270;
      v_status_emoji := '‚ö™';
  END CASE;

  -- Initialize allowed_mentions
  v_allowed_mentions := jsonb_build_object('users', '[]'::jsonb, 'roles', '[]'::jsonb);

  -- Build message content with mention
  IF p_action = 'created' OR p_action = 'updated' THEN
    IF v_mention_user_id IS NOT NULL THEN
      v_message_content := format('**New Regrade Request** <@%s>', v_mention_user_id);
      v_allowed_mentions := jsonb_set(v_allowed_mentions, '{users}', jsonb_build_array(v_mention_user_id));
    ELSE
      v_message_content := format('**New Regrade Request** (Grader: %s)', COALESCE(v_grader_name, 'Unknown'));
    END IF;
  ELSIF p_action = 'escalated' THEN
    -- Use proper Discord role mention format: <@&ROLE_ID>
    IF v_instructor_role_id IS NOT NULL THEN
      v_message_content := format('**Regrade Request Escalated** <@&%s>', v_instructor_role_id);
      v_allowed_mentions := jsonb_set(v_allowed_mentions, '{roles}', jsonb_build_array(v_instructor_role_id));
    ELSE
      -- Fallback if instructor role doesn't exist yet
      v_message_content := '**Regrade Request Escalated** (Instructors notified)';
    END IF;
  ELSE
    v_message_content := format('**Regrade Request %s**', UPPER(p_action));
  END IF;

  -- Build embed
  v_embed := jsonb_build_object(
    'title', format('Regrade Request #%s', v_regrade_request.id),
    'color', v_status_color,
    'fields', jsonb_build_array(
      jsonb_build_object('name', 'Student', 'value', COALESCE(v_student_name, 'Unknown'), 'inline', true),
      jsonb_build_object('name', 'Status', 'value', format('%s %s', v_status_emoji, UPPER(v_regrade_request.status::text)), 'inline', true),
      jsonb_build_object('name', 'Grader', 'value', COALESCE(v_grader_name, 'Unknown'), 'inline', true)
    ),
    'footer', jsonb_build_object('text', format('Request ID: %s', v_regrade_request.id)),
    'timestamp', NOW()::text
  );

  -- Add points info
  IF v_regrade_request.initial_points IS NOT NULL THEN
    v_embed := jsonb_set(
      v_embed,
      '{fields}',
      (v_embed->'fields') || jsonb_build_object('name', 'Initial Points', 'value', v_regrade_request.initial_points::text, 'inline', true)
    );
  END IF;

  IF v_regrade_request.resolved_points IS NOT NULL THEN
    v_embed := jsonb_set(
      v_embed,
      '{fields}',
      (v_embed->'fields') || jsonb_build_object('name', 'Resolved Points', 'value', v_regrade_request.resolved_points::text, 'inline', true)
    );
  END IF;

  -- Always check if message already exists first (handles race conditions and updates)
  DECLARE
    v_existing_message_id text;
  BEGIN
    SELECT dm.discord_message_id
    INTO v_existing_message_id
    FROM public.discord_messages dm
    WHERE dm.class_id = v_regrade_request.class_id
      AND dm.resource_type = 'regrade_request'
      AND dm.resource_id = p_regrade_request_id;

    IF v_existing_message_id IS NOT NULL THEN
      -- Update existing message
      PERFORM pgmq_public.send(
        queue_name := 'discord_async_calls',
        message := jsonb_build_object(
          'method', 'update_message',
          'args', jsonb_build_object(
            'channel_id', v_discord_channel_id,
            'message_id', v_existing_message_id,
            'content', v_message_content,
            'embeds', jsonb_build_array(v_embed),
            'allowed_mentions', v_allowed_mentions
          ),
          'class_id', v_regrade_request.class_id
        )
      );
      RETURN;
    END IF;
  END;

  -- Send new message (only if no existing message was found)
  PERFORM pgmq_public.send(
    queue_name := 'discord_async_calls',
    message := jsonb_build_object(
      'method', 'send_message',
      'args', jsonb_build_object(
        'channel_id', v_discord_channel_id,
        'content', v_message_content,
        'embeds', jsonb_build_array(v_embed),
        'allowed_mentions', v_allowed_mentions
      ),
      'class_id', v_regrade_request.class_id,
      'resource_type', 'regrade_request',
      'resource_id', p_regrade_request_id
    )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enqueue_discord_role_creation(p_class_id bigint, p_role_type text, p_guild_id text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_guild_id text;
  v_class_slug text;
  v_term integer;
  v_role_name text;
  v_term_text text;
  v_year integer;
  v_term_code integer;
BEGIN
  -- Get Discord server info, class slug, and term from class
  SELECT c.discord_server_id, c.slug, c.term
  INTO v_guild_id, v_class_slug, v_term
  FROM public.classes c
  WHERE c.id = p_class_id;

  -- Use provided guild_id or fall back to class's discord_server_id
  v_guild_id := COALESCE(p_guild_id, v_guild_id);

  -- Skip if no Discord server configured
  IF v_guild_id IS NULL THEN
    RETURN;
  END IF;

  -- Parse term to get semester/year text
  IF v_term IS NOT NULL THEN
    v_year := FLOOR(v_term / 100);
    v_term_code := v_term % 100;
    
    -- Handle Fall term (Banner uses next year for Fall)
    IF v_term_code = 10 THEN
      v_year := v_year - 1;
    END IF;
    
    -- Map term codes to semester names
    CASE v_term_code
      WHEN 10 THEN v_term_text := format('Fall %s', v_year);
      WHEN 30 THEN v_term_text := format('Spring %s', v_year);
      WHEN 40 THEN v_term_text := format('Summer 1 %s', v_year);
      WHEN 50 THEN v_term_text := format('Summer Full %s', v_year);
      WHEN 60 THEN v_term_text := format('Summer 2 %s', v_year);
      ELSE v_term_text := format('Term %s %s', v_term_code, v_year);
    END CASE;
  ELSE
    v_term_text := NULL;
  END IF;

  -- Determine role name: {semester/year} {class_slug} - {Role Type} ({class_id})
  -- Format: "Fall 2024 CS2500 - Student (123)" or "CS2500 - Student (123)" if no term
  v_role_name := format('%s - %s (%s)',
    (CASE WHEN v_term_text IS NOT NULL THEN v_term_text || ' ' ELSE '' END || COALESCE(INITCAP(v_class_slug), 'Class')),
    CASE p_role_type
      WHEN 'student' THEN 'Student'
      WHEN 'grader' THEN 'Grader'
      WHEN 'instructor' THEN 'Instructor'
      ELSE INITCAP(p_role_type)
    END,
    p_class_id::text
  );

  -- Enqueue role creation
  PERFORM pgmq_public.send(
    queue_name := 'discord_async_calls',
    message := jsonb_build_object(
      'method', 'create_role',
      'args', jsonb_build_object(
        'guild_id', v_guild_id,
        'name', v_role_name,
        'mentionable', true -- Allow @mentions for these roles
      ),
      'class_id', p_class_id,
      'role_type', p_role_type
    )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enqueue_discord_role_sync(p_user_id uuid, p_class_id bigint, p_role app_role, p_action text DEFAULT 'add'::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_guild_id text;
  v_discord_user_id text;
  v_discord_role_id text;
  v_class_slug text;
BEGIN
  -- Get Discord server info from class
  SELECT c.discord_server_id, c.slug
  INTO v_guild_id, v_class_slug
  FROM public.classes c
  WHERE c.id = p_class_id;

  -- Skip if no Discord server configured
  IF v_guild_id IS NULL THEN
    RETURN;
  END IF;

  -- Get user's Discord ID
  SELECT u.discord_id INTO v_discord_user_id
  FROM public.users u
  WHERE u.user_id = p_user_id;

  -- Skip if user doesn't have Discord linked
  IF v_discord_user_id IS NULL THEN
    RETURN;
  END IF;

  -- Note: We don't check if user is in server here - the async worker will handle that
  -- and create an invite if needed. This allows the role sync to be queued even if
  -- the user isn't in the server yet.

  -- Get Discord role ID for this class and role type
  SELECT dr.discord_role_id INTO v_discord_role_id
  FROM public.discord_roles dr
  WHERE dr.class_id = p_class_id
    AND dr.role_type = p_role::text;

  -- Skip if role doesn't exist yet (will be created when server is connected)
  IF v_discord_role_id IS NULL THEN
    RETURN;
  END IF;

  -- Enqueue role add/remove operation
  IF p_action = 'add' THEN
    PERFORM pgmq_public.send(
      queue_name := 'discord_async_calls',
      message := jsonb_build_object(
        'method', 'add_member_role',
        'args', jsonb_build_object(
          'guild_id', v_guild_id,
          'user_id', v_discord_user_id,
          'role_id', v_discord_role_id
        ),
        'class_id', p_class_id
      )
    );
  ELSIF p_action = 'remove' THEN
    PERFORM pgmq_public.send(
      queue_name := 'discord_async_calls',
      message := jsonb_build_object(
        'method', 'remove_member_role',
        'args', jsonb_build_object(
          'guild_id', v_guild_id,
          'user_id', v_discord_user_id,
          'role_id', v_discord_role_id
        ),
        'class_id', p_class_id
      )
    );
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enqueue_discord_roles_creation(p_class_id bigint, p_guild_id text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Create all three role types
  PERFORM public.enqueue_discord_role_creation(p_class_id, 'student', p_guild_id);
  PERFORM public.enqueue_discord_role_creation(p_class_id, 'grader', p_guild_id);
  PERFORM public.enqueue_discord_role_creation(p_class_id, 'instructor', p_guild_id);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_discord_message(p_class_id bigint, p_discord_message_id text, p_discord_channel_id text, p_resource_type text, p_resource_id bigint)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  INSERT INTO public.discord_messages (
    class_id,
    discord_message_id,
    discord_channel_id,
    resource_type,
    resource_id
  ) VALUES (
    p_class_id,
    p_discord_message_id,
    p_discord_channel_id,
    p_resource_type::public.discord_resource_type,
    p_resource_id
  )
  ON CONFLICT (class_id, resource_type, resource_id) 
  DO UPDATE SET
    discord_message_id = EXCLUDED.discord_message_id,
    discord_channel_id = EXCLUDED.discord_channel_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.invoke_calendar_sync_background_task()
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
  PERFORM public.call_edge_function_internal(
    '/functions/v1/calendar-sync',
    'POST',
    '{"Content-type":"application/json","x-supabase-webhook-source":"calendar-sync"}'::jsonb,
    '{}'::jsonb,
    30000,
    null, null, null, null, null
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.invoke_discord_async_worker_background_task()
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
DECLARE
  i integer;
BEGIN
  -- Spawn exactly 2 workers (matching github-async-worker pattern)
  FOR i IN 1..2 LOOP
    PERFORM public.call_edge_function_internal(
      '/functions/v1/discord-async-worker',
      'POST',
      '{"Content-type":"application/json","x-supabase-webhook-source":"discord-async-worker"}'::jsonb,
      '{}'::jsonb,
      3000,
      null, null, null, null, null
    );
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.mark_discord_invite_used(p_user_id uuid, p_guild_id text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  UPDATE public.discord_invites
  SET used = true
  WHERE user_id = p_user_id
    AND guild_id = p_guild_id
    AND used = false;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.only_calendar_or_discord_ids_changed(new_row classes)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT COALESCE(
    (
      SELECT COALESCE(
        (
          SELECT bool_and(changed.key = ANY(ARRAY[
            'discord_server_id',
            'discord_channel_group_id',
            'office_hours_ics_url',
            'events_ics_url',
            'updated_at'
          ]))
          FROM (
            SELECT t.key
            FROM jsonb_each(to_jsonb(new_row)) AS t(key, value)
            WHERE (to_jsonb(old_row)->t.key) IS DISTINCT FROM t.value
          ) AS changed
        ),
        true  -- no differences -> allow
      )
      FROM public.classes old_row
      WHERE old_row.id = new_row.id
    ),
    false -- no matching row found
  );
$function$
;

CREATE OR REPLACE FUNCTION public.only_discord_ids_changed(new_row classes)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT COALESCE(
    (
      SELECT COALESCE(
        (
          SELECT bool_and(changed.key = ANY(ARRAY[
            'discord_server_id',
            'discord_channel_group_id',
            'updated_at' -- allow automatic timestamp touches if present
          ]))
          FROM (
            SELECT t.key
            FROM jsonb_each(to_jsonb(new_row)) AS t(key, value)
            WHERE (to_jsonb(old_row)->t.key) IS DISTINCT FROM t.value
          ) AS changed
        ),
        true  -- no differences -> allow
      )
      FROM public.classes old_row
      WHERE old_row.id = new_row.id
    ),
    false -- no matching row found
  );
$function$
;

CREATE OR REPLACE FUNCTION public.process_calendar_announcements()
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_now timestamptz := NOW();
  v_messages jsonb[] := '{}';
  v_event RECORD;
  v_channel_id text;
  v_message jsonb;
  v_has_multiple_queues boolean;
  v_queue_name text;
  v_display_name text;
  v_date_str text;
  v_time_str text;
  v_emoji text;
  v_action text;
  v_changed_ids bigint[] := '{}';
  v_started_ids bigint[] := '{}';
  v_ended_ids bigint[] := '{}';
  v_processed_count int := 0;
BEGIN
  -- 1. Process schedule change announcements (new/changed events not yet announced)
  FOR v_event IN
    SELECT 
      ce.id,
      ce.class_id,
      ce.calendar_type,
      ce.title,
      ce.start_time,
      ce.end_time,
      ce.organizer_name,
      ce.queue_name,
      dc.discord_channel_id,
      c.time_zone
    FROM public.calendar_events ce
    INNER JOIN public.classes c ON c.id = ce.class_id AND c.discord_server_id IS NOT NULL
    LEFT JOIN public.discord_channels dc ON dc.class_id = ce.class_id AND dc.channel_type = 'scheduling'
    WHERE ce.change_announced_at IS NULL
      AND ce.end_time >= v_now
    LIMIT 500
  LOOP
    IF v_event.discord_channel_id IS NOT NULL THEN
      v_date_str := to_char(v_event.start_time AT TIME ZONE v_event.time_zone, 'Dy, Mon DD');
      v_time_str := to_char(v_event.start_time AT TIME ZONE v_event.time_zone, 'HH12:MI AM') || ' - ' || 
                   to_char(v_event.end_time AT TIME ZONE v_event.time_zone, 'HH12:MI AM');
      
      v_message := jsonb_build_object(
        'method', 'send_message',
        'args', jsonb_build_object(
          'channel_id', v_event.discord_channel_id,
          'content', 'üìÖ **' || v_event.title || '** has been added to the schedule',
          'embeds', jsonb_build_array(jsonb_build_object(
            'description', 'üìÜ ' || v_date_str || E'\n‚è∞ ' || v_time_str,
            'color', 65280 -- green
          ))
        ),
        'class_id', v_event.class_id
      );
      v_messages := array_append(v_messages, v_message);
    END IF;
    v_changed_ids := array_append(v_changed_ids, v_event.id);
  END LOOP;

  -- 2. Process start announcements (office hours and events that have started)
  FOR v_event IN
    SELECT 
      ce.id,
      ce.class_id,
      ce.calendar_type,
      ce.title,
      ce.organizer_name,
      ce.queue_name,
      c.discord_server_id,
      -- Get office hours channel (match by queue name if multiple queues)
      CASE 
        WHEN ce.calendar_type = 'office_hours' THEN (
          SELECT dc.discord_channel_id 
          FROM public.discord_channels dc
          LEFT JOIN public.help_queues hq ON hq.id = dc.resource_id AND dc.channel_type = 'office_hours'
          WHERE dc.class_id = ce.class_id 
            AND dc.channel_type = 'office_hours'
            AND (ce.queue_name IS NULL OR hq.name ILIKE ce.queue_name OR dc.resource_id IS NULL)
          LIMIT 1
        )
        ELSE (
          SELECT dc.discord_channel_id 
          FROM public.discord_channels dc
          WHERE dc.class_id = ce.class_id AND dc.channel_type = 'operations'
          LIMIT 1
        )
      END as discord_channel_id,
      (SELECT COUNT(*) > 1 FROM public.help_queues WHERE class_id = ce.class_id) as has_multiple_queues
    FROM public.calendar_events ce
    INNER JOIN public.classes c ON c.id = ce.class_id AND c.discord_server_id IS NOT NULL
    WHERE ce.start_announced_at IS NULL
      AND ce.start_time <= v_now
    LIMIT 500
  LOOP
    IF v_event.discord_channel_id IS NOT NULL THEN
      IF v_event.calendar_type = 'office_hours' THEN
        v_display_name := COALESCE(v_event.organizer_name, v_event.title);
        IF v_event.has_multiple_queues AND v_event.queue_name IS NOT NULL THEN
          v_display_name := v_display_name || ' (' || v_event.queue_name || ')';
        END IF;
        v_message := jsonb_build_object(
          'method', 'send_message',
          'args', jsonb_build_object(
            'channel_id', v_event.discord_channel_id,
            'content', 'üü¢ **' || v_display_name || '** is now on duty'
          ),
          'class_id', v_event.class_id
        );
      ELSE
        v_message := jsonb_build_object(
          'method', 'send_message',
          'args', jsonb_build_object(
            'channel_id', v_event.discord_channel_id,
            'content', 'üöÄ **' || v_event.title || '** is starting now'
          ),
          'class_id', v_event.class_id
        );
      END IF;
      v_messages := array_append(v_messages, v_message);
    END IF;
    v_started_ids := array_append(v_started_ids, v_event.id);
  END LOOP;

  -- 3. Process end announcements (office hours and events that have ended)
  FOR v_event IN
    SELECT 
      ce.id,
      ce.class_id,
      ce.calendar_type,
      ce.title,
      ce.organizer_name,
      ce.queue_name,
      c.discord_server_id,
      CASE 
        WHEN ce.calendar_type = 'office_hours' THEN (
          SELECT dc.discord_channel_id 
          FROM public.discord_channels dc
          LEFT JOIN public.help_queues hq ON hq.id = dc.resource_id AND dc.channel_type = 'office_hours'
          WHERE dc.class_id = ce.class_id 
            AND dc.channel_type = 'office_hours'
            AND (ce.queue_name IS NULL OR hq.name ILIKE ce.queue_name OR dc.resource_id IS NULL)
          LIMIT 1
        )
        ELSE (
          SELECT dc.discord_channel_id 
          FROM public.discord_channels dc
          WHERE dc.class_id = ce.class_id AND dc.channel_type = 'operations'
          LIMIT 1
        )
      END as discord_channel_id,
      (SELECT COUNT(*) > 1 FROM public.help_queues WHERE class_id = ce.class_id) as has_multiple_queues
    FROM public.calendar_events ce
    INNER JOIN public.classes c ON c.id = ce.class_id AND c.discord_server_id IS NOT NULL
    WHERE ce.end_announced_at IS NULL
      AND ce.end_time <= v_now
    LIMIT 500
  LOOP
    IF v_event.discord_channel_id IS NOT NULL THEN
      IF v_event.calendar_type = 'office_hours' THEN
        v_display_name := COALESCE(v_event.organizer_name, v_event.title);
        IF v_event.has_multiple_queues AND v_event.queue_name IS NOT NULL THEN
          v_display_name := v_display_name || ' (' || v_event.queue_name || ')';
        END IF;
        v_message := jsonb_build_object(
          'method', 'send_message',
          'args', jsonb_build_object(
            'channel_id', v_event.discord_channel_id,
            'content', 'üî¥ **' || v_display_name || '** is now off duty'
          ),
          'class_id', v_event.class_id
        );
      ELSE
        v_message := jsonb_build_object(
          'method', 'send_message',
          'args', jsonb_build_object(
            'channel_id', v_event.discord_channel_id,
            'content', '‚úÖ **' || v_event.title || '** has ended'
          ),
          'class_id', v_event.class_id
        );
      END IF;
      v_messages := array_append(v_messages, v_message);
    END IF;
    v_ended_ids := array_append(v_ended_ids, v_event.id);
  END LOOP;

  -- 4. Batch insert all messages into pgmq
  IF array_length(v_messages, 1) > 0 THEN
    PERFORM pgmq_public.send_batch(
      queue_name := 'discord_async_calls',
      messages := v_messages
    );
  END IF;

  -- 5. Batch update announcement timestamps
  IF array_length(v_changed_ids, 1) > 0 THEN
    UPDATE public.calendar_events
    SET change_announced_at = v_now
    WHERE id = ANY(v_changed_ids);
  END IF;

  IF array_length(v_started_ids, 1) > 0 THEN
    UPDATE public.calendar_events
    SET start_announced_at = v_now
    WHERE id = ANY(v_started_ids);
  END IF;

  IF array_length(v_ended_ids, 1) > 0 THEN
    UPDATE public.calendar_events
    SET end_announced_at = v_now
    WHERE id = ANY(v_ended_ids);
  END IF;

  v_processed_count := COALESCE(array_length(v_changed_ids, 1), 0) + 
                       COALESCE(array_length(v_started_ids, 1), 0) + 
                       COALESCE(array_length(v_ended_ids, 1), 0);

  RETURN jsonb_build_object(
    'success', true,
    'processed_count', v_processed_count,
    'messages_queued', COALESCE(array_length(v_messages, 1), 0),
    'change_announcements', COALESCE(array_length(v_changed_ids, 1), 0),
    'start_announcements', COALESCE(array_length(v_started_ids, 1), 0),
    'end_announcements', COALESCE(array_length(v_ended_ids, 1), 0)
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_existing_users_after_roles_created(p_class_id bigint)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_role RECORD;
BEGIN
  -- Enqueue role sync for all users who:
  -- 1. Have a role in this class (user_roles)
  -- 2. Have Discord linked (users.discord_id is not null)
  -- 3. Are active (not disabled)
  FOR v_user_role IN
    SELECT ur.user_id, ur.class_id, ur.role
    FROM public.user_roles ur
    INNER JOIN public.users u ON u.user_id = ur.user_id
    WHERE ur.class_id = p_class_id
      AND ur.disabled = false
      AND u.discord_id IS NOT NULL
  LOOP
    -- Enqueue role sync for each user
    -- The async worker will check if user is in server and assign role or create invite
    PERFORM public.enqueue_discord_role_sync(
      v_user_role.user_id,
      v_user_role.class_id,
      v_user_role.role,
      'add'
    );
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_discord_channel_creation()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  IF TG_TABLE_NAME = 'assignments' THEN
    PERFORM public.enqueue_discord_channel_creation(
      NEW.class_id,
      'assignment',
      NEW.id,
      NULL,
      NULL
    );
  ELSIF TG_TABLE_NAME = 'lab_sections' THEN
    PERFORM public.enqueue_discord_channel_creation(
      NEW.class_id,
      'lab',
      NEW.id,
      NULL,
      NULL
    );
  ELSIF TG_TABLE_NAME = 'help_queues' THEN
    PERFORM public.enqueue_discord_channel_creation(
      NEW.class_id,
      'office_hours',
      NEW.id,
      NULL,
      NULL
    );
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_discord_create_roles_on_server_connect()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_roles_exist boolean;
BEGIN
  -- When discord_server_id is set (and wasn't set before), create roles and channels
  IF NEW.discord_server_id IS NOT NULL 
     AND (OLD.discord_server_id IS NULL OR OLD.discord_server_id IS DISTINCT FROM NEW.discord_server_id) THEN
    
    -- Check if roles already exist for this class
    SELECT EXISTS (
      SELECT 1 FROM public.discord_roles 
      WHERE class_id = NEW.id
    ) INTO v_roles_exist;
    
    IF NOT v_roles_exist THEN
      -- Enqueue role creation
      PERFORM public.enqueue_discord_roles_creation(NEW.id, NEW.discord_server_id);
      
      -- Also enqueue invite creation for users who already have Discord linked
      PERFORM public.enqueue_discord_invites_for_existing_users(NEW.id, NEW.discord_server_id);
    END IF;
    
    -- Create #scheduling channel if it doesn't exist
    IF NOT EXISTS (
      SELECT 1 FROM public.discord_channels
      WHERE class_id = NEW.id AND channel_type = 'scheduling'
    ) THEN
      PERFORM public.enqueue_discord_channel_creation(
        NEW.id,
        'scheduling'::public.discord_channel_type,
        NULL,
        'scheduling',
        NEW.discord_server_id
      );
    END IF;
    
    -- Create #operations channel if it doesn't exist
    IF NOT EXISTS (
      SELECT 1 FROM public.discord_channels
      WHERE class_id = NEW.id AND channel_type = 'operations'
    ) THEN
      PERFORM public.enqueue_discord_channel_creation(
        NEW.id,
        'operations'::public.discord_channel_type,
        NULL,
        'operations',
        NEW.discord_server_id
      );
    END IF;
  END IF;
  
  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    -- Log error but don't fail the update
    RAISE WARNING 'Error in trigger_discord_create_roles_on_server_connect for class_id=%: %', NEW.id, SQLERRM;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_discord_help_request_feedback_notification()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- On INSERT or UPDATE: send feedback update message
  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    PERFORM public.enqueue_discord_help_request_message(NEW.help_request_id, 'feedback');
    RETURN NEW;
  END IF;

  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_discord_help_request_notification()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- On INSERT: send created message
  IF TG_OP = 'INSERT' THEN
    PERFORM public.enqueue_discord_help_request_message(NEW.id, 'created');
    RETURN NEW;
  END IF;

  -- On UPDATE: send updated message if status changed
  IF TG_OP = 'UPDATE' THEN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
      IF NEW.status = 'resolved' THEN
        PERFORM public.enqueue_discord_help_request_message(NEW.id, 'resolved');
      ELSE
        PERFORM public.enqueue_discord_help_request_message(NEW.id, 'updated');
      END IF;
    ELSIF OLD.assignee IS DISTINCT FROM NEW.assignee THEN
      -- Assignment changed
      PERFORM public.enqueue_discord_help_request_message(NEW.id, 'updated');
    END IF;
    RETURN NEW;
  END IF;

  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_discord_queue_assignment_notification()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- On INSERT: TA started working
  IF TG_OP = 'INSERT' THEN
    IF NEW.is_active THEN
      PERFORM public.enqueue_discord_queue_assignment_message(NEW.id, 'started');
    END IF;
    RETURN NEW;
  END IF;

  -- On UPDATE: check if TA started or stopped working
  IF TG_OP = 'UPDATE' THEN
    -- Started working: is_active changed from false to true, or was NULL and now true
    IF (OLD.is_active IS DISTINCT FROM NEW.is_active AND NEW.is_active = true) THEN
      PERFORM public.enqueue_discord_queue_assignment_message(NEW.id, 'started');
    -- Stopped working: is_active changed from true to false OR ended_at was set
    -- (mutually exclusive with started condition, ensures single notification)
    ELSIF (OLD.is_active IS DISTINCT FROM NEW.is_active AND NEW.is_active = false)
       OR (OLD.ended_at IS NULL AND NEW.ended_at IS NOT NULL) THEN
      PERFORM public.enqueue_discord_queue_assignment_message(NEW.id, 'stopped');
    END IF;
    RETURN NEW;
  END IF;

  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_discord_regrade_request_notification()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- On INSERT: only send if status is 'opened' (not 'draft')
  IF TG_OP = 'INSERT' THEN
    IF NEW.status = 'opened' THEN
      PERFORM public.enqueue_discord_regrade_request_message(NEW.id, 'created');
    END IF;
    RETURN NEW;
  END IF;

  -- On UPDATE: send notification on status changes
  IF TG_OP = 'UPDATE' THEN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
      IF NEW.status = 'escalated' THEN
        PERFORM public.enqueue_discord_regrade_request_message(NEW.id, 'escalated');
      ELSIF NEW.status = 'resolved' THEN
        PERFORM public.enqueue_discord_regrade_request_message(NEW.id, 'resolved');
      ELSIF NEW.status = 'closed' THEN
        PERFORM public.enqueue_discord_regrade_request_message(NEW.id, 'closed');
      ELSIF NEW.status = 'opened' AND OLD.status = 'draft' THEN
        PERFORM public.enqueue_discord_regrade_request_message(NEW.id, 'created');
      ELSE
        PERFORM public.enqueue_discord_regrade_request_message(NEW.id, 'updated');
      END IF;
    END IF;
    RETURN NEW;
  END IF;

  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_discord_role_sync()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- On INSERT: add role
  IF TG_OP = 'INSERT' THEN
    PERFORM public.enqueue_discord_role_sync(NEW.user_id, NEW.class_id, NEW.role, 'add');
    RETURN NEW;
  END IF;

  -- On UPDATE: if role changed, remove old role and add new role
  IF TG_OP = 'UPDATE' THEN
    IF OLD.role IS DISTINCT FROM NEW.role THEN
      PERFORM public.enqueue_discord_role_sync(OLD.user_id, OLD.class_id, OLD.role, 'remove');
      PERFORM public.enqueue_discord_role_sync(NEW.user_id, NEW.class_id, NEW.role, 'add');
    END IF;
    RETURN NEW;
  END IF;

  -- On DELETE: remove role
  IF TG_OP = 'DELETE' THEN
    PERFORM public.enqueue_discord_role_sync(OLD.user_id, OLD.class_id, OLD.role, 'remove');
    RETURN OLD;
  END IF;

  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_discord_role_sync_for_user(p_class_id bigint DEFAULT NULL::bigint)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id uuid;
  v_discord_id text;
  v_sync_count integer := 0;
  v_user_role RECORD;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('error', 'Not authenticated', 'synced_classes', 0);
  END IF;

  -- Check if user has Discord linked
  SELECT discord_id INTO v_discord_id
  FROM public.users
  WHERE user_id = v_user_id;

  IF v_discord_id IS NULL THEN
    RETURN jsonb_build_object('error', 'Discord account not linked', 'synced_classes', 0);
  END IF;

  -- Enqueue role sync for all matching classes
  FOR v_user_role IN
    SELECT ur.user_id, ur.class_id, ur.role, c.discord_server_id
    FROM public.user_roles ur
    INNER JOIN public.classes c ON c.id = ur.class_id
    WHERE ur.user_id = v_user_id
      AND ur.disabled = false
      AND c.discord_server_id IS NOT NULL
      AND (p_class_id IS NULL OR ur.class_id = p_class_id)
  LOOP
    -- Enqueue role sync for each role
    BEGIN
      PERFORM public.enqueue_discord_role_sync(
        v_user_role.user_id,
        v_user_role.class_id,
        v_user_role.role,
        'add'
      );
      v_sync_count := v_sync_count + 1;
    EXCEPTION
      WHEN OTHERS THEN
        -- Log but continue
        RAISE WARNING 'Error enqueueing role sync for class %: %', v_user_role.class_id, SQLERRM;
    END;
  END LOOP;

  -- Also mark any pending invites as used for the user
  -- (in case they've already joined the server)
  UPDATE public.discord_invites
  SET used = true
  WHERE user_id = v_user_id
    AND used = false
    AND (p_class_id IS NULL OR class_id = p_class_id);

  RETURN jsonb_build_object('synced_classes', v_sync_count);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_sync_existing_users_on_role_creation()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_role_count integer;
BEGIN
  -- Check if all three role types exist for this class
  SELECT COUNT(DISTINCT role_type) INTO v_role_count
  FROM public.discord_roles
  WHERE class_id = NEW.class_id
    AND role_type IN ('student', 'grader', 'instructor');
  
  -- If all three roles exist, sync existing users
  -- This fixes the race condition where users are already in the Discord server
  -- but roles were just created. The sync will enqueue role assignments for all
  -- existing users who have Discord linked.
  IF v_role_count = 3 THEN
    PERFORM public.sync_existing_users_after_roles_created(NEW.class_id);
  END IF;
  
  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    -- Log error but don't fail the insert
    RAISE WARNING 'Error in trigger_sync_existing_users_on_role_creation for class_id=%: %', NEW.class_id, SQLERRM;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_calendar_events_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_class_staff_settings_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_discord_profile()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_had_discord_id boolean;
BEGIN
    IF NEW.provider <> 'discord' THEN
      RETURN NEW;
    END IF;

    -- Check if user already had a Discord ID (to detect new linking vs update)
    SELECT (discord_id IS NOT NULL) INTO v_had_discord_id
    FROM public.users
    WHERE user_id = NEW.user_id;

    UPDATE public.users
    SET
      discord_username = NEW.identity_data->>'name',
      discord_id = NEW.provider_id
    WHERE user_id = NEW.user_id;

    -- If this is a new Discord link (didn't have discord_id before), check for role sync
    IF NOT v_had_discord_id THEN
      -- Call function to check and sync roles (will create invites if user not in servers)
      PERFORM public.check_discord_role_sync_after_link(NEW.user_id);
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_regrade_request_status(regrade_request_id bigint, new_status regrade_status, profile_id uuid, resolved_points integer DEFAULT NULL::integer, closed_points integer DEFAULT NULL::integer)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
    current_request record;
    param_resolved_points integer;
    param_closed_points integer;
begin
    param_resolved_points := resolved_points;
    param_closed_points := closed_points;
    
    -- Get the current regrade request
    select *
    into current_request
    from public.submission_regrade_requests
    where id = regrade_request_id;
    
    if not found then
        raise exception 'Regrade request not found';
    end if;
    
    -- Validate resolved_points parameter for resolved status
    if new_status = 'resolved' and resolved_points is null then
        raise exception 'resolved_points parameter is required when status is resolved';
    end if;
    
    -- Validate closed_points parameter for closed status
    if new_status = 'closed' and closed_points is null then
        raise exception 'closed_points parameter is required when status is closed';
    end if;
    
    -- Validate state transitions and permissions
    case new_status
        when 'opened' then
            -- Can only open from draft, and only by submission owner
            if current_request.status != 'draft' then
                raise exception 'Can only open regrade requests that are in draft status';
            end if;
            if not authorizeforprofile(profile_id) then
                raise exception 'Only submission owners can open regrade requests';
            end if;
            
            -- Update with opened timestamp
            update public.submission_regrade_requests
            set status = new_status,
                opened_at = now(),
                last_updated_at = now()
            where id = regrade_request_id;
            
            -- Notify the author of the comment that triggered this regrade request
            -- Check preferences for staff
            insert into public.notifications (class_id, subject, body, style, user_id)
            select 
                distinct on (ur.user_id)
                current_request.class_id,
                '{}'::jsonb as subject,
                jsonb_build_object(
                    'type', 'regrade_request',
                    'action', 'comment_challenged',
                    'regrade_request_id', regrade_request_id,
                    'submission_id', current_request.submission_id,
                    'assignment_id', current_request.assignment_id,
                    'opened_by', profile_id,
                    'opened_by_name', (select name from public.profiles where id = profile_id)
                ) as body,
                'info' as style,
                ur.user_id
            from public.user_roles ur
            left join public.notification_preferences np
              on np.user_id = ur.user_id and np.class_id = current_request.class_id
            left join public.users u
              on u.user_id = ur.user_id
            where ur.class_id = current_request.class_id
              and ur.private_profile_id = (
                -- Get comment author based on which type of comment this regrade request refers to
                case 
                    when current_request.submission_file_comment_id is not null then
                        (select author from public.submission_file_comments where id = current_request.submission_file_comment_id)
                    when current_request.submission_comment_id is not null then
                        (select author from public.submission_comments where id = current_request.submission_comment_id)
                    when current_request.submission_artifact_comment_id is not null then
                        (select author from public.submission_artifact_comments where id = current_request.submission_artifact_comment_id)
                end
              )
              -- For staff, check preferences - default to 'none' if Discord linked
              and (
                ur.role NOT IN ('instructor', 'grader')
                or coalesce(
                  np.regrade_request_notification::text,
                  CASE 
                    WHEN u.discord_id IS NOT NULL AND ur.role IN ('instructor', 'grader') THEN 'none'
                    ELSE 'all'
                  END
                ) <> 'none'
              );
            
        when 'resolved' then
            -- Can only resolve from opened, and only by class graders
            if current_request.status != 'opened' then
                raise exception 'Can only resolve regrade requests that are opened';
            end if;
            if not authorizeforprofile(profile_id) then
                raise exception 'Unauthorized to act as this profile';
            end if;
            if not authorizeforclassgrader(current_request.class_id) then
                raise exception 'Only graders can resolve regrade requests';
            end if;
            
            -- Update with resolved info
            update public.submission_regrade_requests
            set status = new_status,
                resolved_by = profile_id,
                resolved_at = now(),
                resolved_points = param_resolved_points,
                last_updated_at = now()
            where id = regrade_request_id;
            
            -- Update the original comment's points
            if current_request.submission_file_comment_id is not null then
                update public.submission_file_comments
                set points = param_resolved_points
                where id = current_request.submission_file_comment_id;
            elsif current_request.submission_comment_id is not null then
                update public.submission_comments
                set points = param_resolved_points
                where id = current_request.submission_comment_id;
            elsif current_request.submission_artifact_comment_id is not null then
                update public.submission_artifact_comments
                set points = param_resolved_points
                where id = current_request.submission_artifact_comment_id;
            end if;
            
        when 'escalated' then
            -- Can only escalate from resolved, and only by submission owner
            if current_request.status != 'resolved' then
                raise exception 'Can only escalate regrade requests that are resolved';
            end if;
            if not authorizeforprofile(profile_id) then
                raise exception 'Only submission owners can escalate regrade requests';
            end if;
            
            -- Update with escalated info
            update public.submission_regrade_requests
            set status = new_status,
                escalated_by = profile_id,
                escalated_at = now(),
                last_updated_at = now()
            where id = regrade_request_id;
            
        when 'closed' then
            -- Can close from resolved, escalated, or opened, but only by class instructors
            if current_request.status not in ('resolved', 'escalated', 'opened') then
                raise exception 'Can only close regrade requests that are resolved, escalated, or opened';
            end if;
            if not public.authorizeforprofile(profile_id) then
                raise exception 'Unauthorized to act as this profile';
            end if;
            if not public.authorizeforclassinstructor(current_request.class_id) then
                raise exception 'Only instructors can close regrade requests';
            end if;
            
            -- Update with closed info
            update public.submission_regrade_requests
            set status = new_status,
                closed_by = profile_id,
                closed_at = now(),
                closed_points = param_closed_points,
                last_updated_at = now()
            where id = regrade_request_id;
            
            -- Update the original comment's points
            if current_request.submission_file_comment_id is not null then
                update public.submission_file_comments
                set points = param_closed_points
                where id = current_request.submission_file_comment_id;
            elsif current_request.submission_comment_id is not null then
                update public.submission_comments
                set points = param_closed_points
                where id = current_request.submission_comment_id;
            elsif current_request.submission_artifact_comment_id is not null then
                update public.submission_artifact_comments
                set points = param_closed_points
                where id = current_request.submission_artifact_comment_id;
            end if;
            
        when 'draft' then
            raise exception 'Cannot transition back to draft status';
            
        else
            raise exception 'Invalid status: %', new_status;
    end case;
    
    -- Send notifications to all students connected to the submission
    -- Students always get notifications (they don't have Discord notifications)
    insert into public.notifications (class_id, subject, body, style, user_id)
    select 
        current_request.class_id,
        '{}'::jsonb as subject,
        jsonb_build_object(
            'type', 'regrade_request',
            'action', 'status_change',
            'regrade_request_id', regrade_request_id,
            'old_status', current_request.status,
            'new_status', new_status,
            'submission_id', current_request.submission_id,
            'assignment_id', current_request.assignment_id,
            'updated_by', profile_id,
            'updated_by_name', (select name from public.profiles where id = profile_id)
        ) as body,
        'info' as style,
        ur.user_id
    from public.user_roles ur
    where ur.class_id = current_request.class_id
      and ur.role = 'student'
      and ur.private_profile_id != profile_id
      and ur.private_profile_id in (
        -- Get submission owner profile
        select s.profile_id 
        from public.submissions s 
        where s.id = current_request.submission_id
        
        union
        
        -- Get all group members if submission belongs to a group
        select agm.profile_id
        from public.submissions s
        inner join public.assignment_groups_members agm 
            on agm.assignment_group_id = s.assignment_group_id
        where s.id = current_request.submission_id
          and s.assignment_group_id is not null
      );
    
    -- If status is escalated, also notify all instructors
    -- Check preferences for instructors - default to 'none' if Discord linked
    if new_status = 'escalated' then
        insert into public.notifications (class_id, subject, body, style, user_id)
        select 
            current_request.class_id,
            '{}'::jsonb as subject,
            jsonb_build_object(
                'type', 'regrade_request',
                'action', 'escalated',
                'regrade_request_id', regrade_request_id,
                'old_status', current_request.status,
                'new_status', new_status,
                'submission_id', current_request.submission_id,
                'assignment_id', current_request.assignment_id,
                'escalated_by', profile_id,
                'escalated_by_name', (select name from public.profiles where id = profile_id)
            ) as body,
            'warning' as style,
            ur.user_id
        from public.user_roles ur
        left join public.notification_preferences np
          on np.user_id = ur.user_id and np.class_id = current_request.class_id
        left join public.users u
          on u.user_id = ur.user_id
        where ur.class_id = current_request.class_id
          and ur.role = 'instructor'
          -- Check preferences - default to 'none' if Discord linked
          and coalesce(
            np.regrade_request_notification::text,
            CASE 
              WHEN u.discord_id IS NOT NULL AND ur.role IN ('instructor', 'grader') THEN 'none'
              ELSE 'all'
            END
          ) <> 'none';
    end if;
    
    return true;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.create_help_request_notification(p_class_id bigint, p_notification_type text, p_help_request_id bigint, p_help_queue_id bigint, p_help_queue_name text, p_creator_profile_id uuid, p_creator_name text, p_assignee_profile_id uuid DEFAULT NULL::uuid, p_assignee_name text DEFAULT NULL::text, p_status help_request_status DEFAULT NULL::help_request_status, p_request_preview text DEFAULT ''::text, p_is_private boolean DEFAULT false, p_action text DEFAULT 'created'::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  notification_body jsonb;
begin
  if p_notification_type = 'help_request' then
    notification_body := jsonb_build_object(
      'type', 'help_request',
      'action', p_action,
      'help_request_id', p_help_request_id,
      'help_queue_id', p_help_queue_id,
      'help_queue_name', p_help_queue_name,
      'creator_profile_id', p_creator_profile_id,
      'creator_name', p_creator_name,
      'assignee_profile_id', p_assignee_profile_id,
      'assignee_name', p_assignee_name,
      'status', p_status,
      'request_preview', p_request_preview,
      -- Enrich with subject/body for email templates and digests
      'request_subject', coalesce(
        (
          select hrt.name
          from public.help_request_templates hrt
          where hrt.id = (
            select hr.template_id from public.help_requests hr where hr.id = p_help_request_id
          )
        ),
        'General'
      ),
      'request_body', (
        select hr.request from public.help_requests hr where hr.id = p_help_request_id
      ),
      'is_private', p_is_private
    );
  elsif p_notification_type is null then
    raise exception 'create_help_request_notification: p_notification_type must not be null';
  else
    -- Future-proof: explicitly reject unsupported types
    raise exception 'create_help_request_notification: unsupported p_notification_type=%', p_notification_type;
  end if;

  -- On creation: notify instructors and graders only (do NOT blast the entire class)
  if p_action = 'created' then
    insert into public.notifications (user_id, class_id, subject, body)
    select distinct
      ur.user_id,
      p_class_id,
      jsonb_build_object('text', 'Help Request ' || p_action),
      notification_body
    from public.user_roles ur
    left join public.notification_preferences np
      on np.user_id = ur.user_id and np.class_id = p_class_id
    left join public.users u
      on u.user_id = ur.user_id
    where ur.class_id = p_class_id
      and ur.role in ('instructor', 'grader')
      -- Default to 'none' if Discord linked, otherwise 'all'
      and coalesce(
        np.help_request_creation_notification::text,
        CASE 
          WHEN u.discord_id IS NOT NULL AND ur.role IN ('instructor', 'grader') THEN 'none'
          ELSE 'all'
        END
      ) <> 'none'
      and (
        coalesce(
          np.help_request_creation_notification::text,
          CASE 
            WHEN u.discord_id IS NOT NULL AND ur.role IN ('instructor', 'grader') THEN 'none'
            ELSE 'all'
          END
        ) = 'all'
        or (
          coalesce(
            np.help_request_creation_notification::text,
            CASE 
              WHEN u.discord_id IS NOT NULL AND ur.role IN ('instructor', 'grader') THEN 'none'
              ELSE 'all'
            END
          ) = 'only_active_queue'
          and exists (
            select 1
            from public.help_queue_assignments hqa
            where hqa.class_id = p_class_id
              and hqa.help_queue_id = p_help_queue_id
              and hqa.ta_profile_id = ur.private_profile_id
              and hqa.is_active = true
              and hqa.ended_at is null
          )
        )
      );

    -- Ensure the creator is watching their own request
    insert into public.help_request_watchers (user_id, help_request_id, class_id, enabled)
    select ur.user_id, p_help_request_id, p_class_id, true
    from public.user_roles ur
    where ur.private_profile_id = p_creator_profile_id
      and ur.class_id = p_class_id
    on conflict (user_id, help_request_id) do nothing;

  else
    -- For assignment/status changes: notify watchers
    insert into public.notifications (user_id, class_id, subject, body)
    select 
      hrw.user_id,
      p_class_id,
      jsonb_build_object('text', 'Help Request ' || p_action),
      notification_body
    from public.help_request_watchers hrw
    join public.user_roles ur on ur.user_id = hrw.user_id and ur.class_id = p_class_id
    where hrw.help_request_id = p_help_request_id
      and hrw.enabled = true
      and (
        -- For private requests, only notify instructors, graders, creator, and assignee
        (p_is_private and ur.role in ('instructor', 'grader'))
        or (p_is_private and ur.private_profile_id = p_creator_profile_id)
        or (p_is_private and ur.private_profile_id = p_assignee_profile_id)
        -- For public requests, notify all watching users
        or not p_is_private
      );
  end if;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_regrade_request_participants()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
    regrade_request_record record;
begin
    -- Get the regrade request details
    select *
    into regrade_request_record
    from public.submission_regrade_requests
    where id = NEW.submission_regrade_request_id;
    
    -- If no regrade request found, exit early (shouldn't happen due to FK constraint)
    if not found then
        return NEW;
    end if;
    
    -- Notify all participants except the comment author
    -- Filter out staff with Discord linked who have defaulted to 'none'
    insert into public.notifications (class_id, subject, body, style, user_id)
    select distinct
        NEW.class_id,
        '{}'::jsonb as subject,
        jsonb_build_object(
            'type', 'regrade_request',
            'action', 'new_comment',
            'regrade_request_id', regrade_request_record.id,
            'submission_id', regrade_request_record.submission_id,
            'assignment_id', regrade_request_record.assignment_id,
            'comment_author', NEW.author,
            'comment_author_name', (select name from public.profiles where id = NEW.author),
            'comment_id', NEW.id
        ) as body,
        'info' as style,
        ur.user_id
    from public.user_roles ur
    left join public.notification_preferences np
      on np.user_id = ur.user_id and np.class_id = NEW.class_id
    left join public.users u
      on u.user_id = ur.user_id
    where ur.class_id = NEW.class_id
      and ur.private_profile_id in (
        -- Get assignee of the regrade request
        select regrade_request_record.assignee
        
        union
        
        -- Get submission owner profile
        select s.profile_id 
        from public.submissions s 
        where s.id = regrade_request_record.submission_id
        
        union
        
        -- Get all group members if submission belongs to a group
        select agm.profile_id
        from public.submissions s
        inner join public.assignment_groups_members agm 
            on agm.assignment_group_id = s.assignment_group_id
        where s.id = regrade_request_record.submission_id
          and s.assignment_group_id is not null
        
        union
        
        -- Get all previous comment authors from this regrade request
        select author from public.submission_regrade_request_comments 
        where submission_regrade_request_id = NEW.submission_regrade_request_id
      )
      and ur.private_profile_id != NEW.author -- Exclude the new comment author
      -- For staff (instructor/grader), check preferences - default to 'none' if Discord linked
      and (
        ur.role NOT IN ('instructor', 'grader')
        or coalesce(
          np.regrade_request_notification::text,
          CASE 
            WHEN u.discord_id IS NOT NULL AND ur.role IN ('instructor', 'grader') THEN 'none'
            ELSE 'all'
          END
        ) <> 'none'
      );
    
    return NEW;
end;
$function$
;

grant delete on table "public"."calendar_events" to "anon";

grant insert on table "public"."calendar_events" to "anon";

grant references on table "public"."calendar_events" to "anon";

grant select on table "public"."calendar_events" to "anon";

grant trigger on table "public"."calendar_events" to "anon";

grant truncate on table "public"."calendar_events" to "anon";

grant update on table "public"."calendar_events" to "anon";

grant delete on table "public"."calendar_events" to "authenticated";

grant insert on table "public"."calendar_events" to "authenticated";

grant references on table "public"."calendar_events" to "authenticated";

grant select on table "public"."calendar_events" to "authenticated";

grant trigger on table "public"."calendar_events" to "authenticated";

grant truncate on table "public"."calendar_events" to "authenticated";

grant update on table "public"."calendar_events" to "authenticated";

grant delete on table "public"."calendar_events" to "service_role";

grant insert on table "public"."calendar_events" to "service_role";

grant references on table "public"."calendar_events" to "service_role";

grant select on table "public"."calendar_events" to "service_role";

grant trigger on table "public"."calendar_events" to "service_role";

grant truncate on table "public"."calendar_events" to "service_role";

grant update on table "public"."calendar_events" to "service_role";

grant delete on table "public"."calendar_sync_state" to "anon";

grant insert on table "public"."calendar_sync_state" to "anon";

grant references on table "public"."calendar_sync_state" to "anon";

grant select on table "public"."calendar_sync_state" to "anon";

grant trigger on table "public"."calendar_sync_state" to "anon";

grant truncate on table "public"."calendar_sync_state" to "anon";

grant update on table "public"."calendar_sync_state" to "anon";

grant delete on table "public"."calendar_sync_state" to "authenticated";

grant insert on table "public"."calendar_sync_state" to "authenticated";

grant references on table "public"."calendar_sync_state" to "authenticated";

grant select on table "public"."calendar_sync_state" to "authenticated";

grant trigger on table "public"."calendar_sync_state" to "authenticated";

grant truncate on table "public"."calendar_sync_state" to "authenticated";

grant update on table "public"."calendar_sync_state" to "authenticated";

grant delete on table "public"."calendar_sync_state" to "service_role";

grant insert on table "public"."calendar_sync_state" to "service_role";

grant references on table "public"."calendar_sync_state" to "service_role";

grant select on table "public"."calendar_sync_state" to "service_role";

grant trigger on table "public"."calendar_sync_state" to "service_role";

grant truncate on table "public"."calendar_sync_state" to "service_role";

grant update on table "public"."calendar_sync_state" to "service_role";

grant delete on table "public"."class_staff_settings" to "anon";

grant insert on table "public"."class_staff_settings" to "anon";

grant references on table "public"."class_staff_settings" to "anon";

grant select on table "public"."class_staff_settings" to "anon";

grant trigger on table "public"."class_staff_settings" to "anon";

grant truncate on table "public"."class_staff_settings" to "anon";

grant update on table "public"."class_staff_settings" to "anon";

grant delete on table "public"."class_staff_settings" to "authenticated";

grant insert on table "public"."class_staff_settings" to "authenticated";

grant references on table "public"."class_staff_settings" to "authenticated";

grant select on table "public"."class_staff_settings" to "authenticated";

grant trigger on table "public"."class_staff_settings" to "authenticated";

grant truncate on table "public"."class_staff_settings" to "authenticated";

grant update on table "public"."class_staff_settings" to "authenticated";

grant delete on table "public"."class_staff_settings" to "service_role";

grant insert on table "public"."class_staff_settings" to "service_role";

grant references on table "public"."class_staff_settings" to "service_role";

grant select on table "public"."class_staff_settings" to "service_role";

grant trigger on table "public"."class_staff_settings" to "service_role";

grant truncate on table "public"."class_staff_settings" to "service_role";

grant update on table "public"."class_staff_settings" to "service_role";

grant delete on table "public"."discord_async_worker_dlq_messages" to "service_role";

grant insert on table "public"."discord_async_worker_dlq_messages" to "service_role";

grant references on table "public"."discord_async_worker_dlq_messages" to "service_role";

grant select on table "public"."discord_async_worker_dlq_messages" to "service_role";

grant trigger on table "public"."discord_async_worker_dlq_messages" to "service_role";

grant truncate on table "public"."discord_async_worker_dlq_messages" to "service_role";

grant update on table "public"."discord_async_worker_dlq_messages" to "service_role";

grant delete on table "public"."discord_channels" to "anon";

grant insert on table "public"."discord_channels" to "anon";

grant references on table "public"."discord_channels" to "anon";

grant select on table "public"."discord_channels" to "anon";

grant trigger on table "public"."discord_channels" to "anon";

grant truncate on table "public"."discord_channels" to "anon";

grant update on table "public"."discord_channels" to "anon";

grant delete on table "public"."discord_channels" to "authenticated";

grant insert on table "public"."discord_channels" to "authenticated";

grant references on table "public"."discord_channels" to "authenticated";

grant select on table "public"."discord_channels" to "authenticated";

grant trigger on table "public"."discord_channels" to "authenticated";

grant truncate on table "public"."discord_channels" to "authenticated";

grant update on table "public"."discord_channels" to "authenticated";

grant delete on table "public"."discord_channels" to "service_role";

grant insert on table "public"."discord_channels" to "service_role";

grant references on table "public"."discord_channels" to "service_role";

grant select on table "public"."discord_channels" to "service_role";

grant trigger on table "public"."discord_channels" to "service_role";

grant truncate on table "public"."discord_channels" to "service_role";

grant update on table "public"."discord_channels" to "service_role";

grant delete on table "public"."discord_invites" to "anon";

grant insert on table "public"."discord_invites" to "anon";

grant references on table "public"."discord_invites" to "anon";

grant select on table "public"."discord_invites" to "anon";

grant trigger on table "public"."discord_invites" to "anon";

grant truncate on table "public"."discord_invites" to "anon";

grant update on table "public"."discord_invites" to "anon";

grant delete on table "public"."discord_invites" to "authenticated";

grant insert on table "public"."discord_invites" to "authenticated";

grant references on table "public"."discord_invites" to "authenticated";

grant select on table "public"."discord_invites" to "authenticated";

grant trigger on table "public"."discord_invites" to "authenticated";

grant truncate on table "public"."discord_invites" to "authenticated";

grant update on table "public"."discord_invites" to "authenticated";

grant delete on table "public"."discord_invites" to "service_role";

grant insert on table "public"."discord_invites" to "service_role";

grant references on table "public"."discord_invites" to "service_role";

grant select on table "public"."discord_invites" to "service_role";

grant trigger on table "public"."discord_invites" to "service_role";

grant truncate on table "public"."discord_invites" to "service_role";

grant update on table "public"."discord_invites" to "service_role";

grant delete on table "public"."discord_messages" to "anon";

grant insert on table "public"."discord_messages" to "anon";

grant references on table "public"."discord_messages" to "anon";

grant select on table "public"."discord_messages" to "anon";

grant trigger on table "public"."discord_messages" to "anon";

grant truncate on table "public"."discord_messages" to "anon";

grant update on table "public"."discord_messages" to "anon";

grant delete on table "public"."discord_messages" to "authenticated";

grant insert on table "public"."discord_messages" to "authenticated";

grant references on table "public"."discord_messages" to "authenticated";

grant select on table "public"."discord_messages" to "authenticated";

grant trigger on table "public"."discord_messages" to "authenticated";

grant truncate on table "public"."discord_messages" to "authenticated";

grant update on table "public"."discord_messages" to "authenticated";

grant delete on table "public"."discord_messages" to "service_role";

grant insert on table "public"."discord_messages" to "service_role";

grant references on table "public"."discord_messages" to "service_role";

grant select on table "public"."discord_messages" to "service_role";

grant trigger on table "public"."discord_messages" to "service_role";

grant truncate on table "public"."discord_messages" to "service_role";

grant update on table "public"."discord_messages" to "service_role";

grant delete on table "public"."discord_roles" to "anon";

grant insert on table "public"."discord_roles" to "anon";

grant references on table "public"."discord_roles" to "anon";

grant select on table "public"."discord_roles" to "anon";

grant trigger on table "public"."discord_roles" to "anon";

grant truncate on table "public"."discord_roles" to "anon";

grant update on table "public"."discord_roles" to "anon";

grant delete on table "public"."discord_roles" to "authenticated";

grant insert on table "public"."discord_roles" to "authenticated";

grant references on table "public"."discord_roles" to "authenticated";

grant select on table "public"."discord_roles" to "authenticated";

grant trigger on table "public"."discord_roles" to "authenticated";

grant truncate on table "public"."discord_roles" to "authenticated";

grant update on table "public"."discord_roles" to "authenticated";

grant delete on table "public"."discord_roles" to "service_role";

grant insert on table "public"."discord_roles" to "service_role";

grant references on table "public"."discord_roles" to "service_role";

grant select on table "public"."discord_roles" to "service_role";

grant trigger on table "public"."discord_roles" to "service_role";

grant truncate on table "public"."discord_roles" to "service_role";

grant update on table "public"."discord_roles" to "service_role";

create policy "calendar_events_service_role_all"
on "public"."calendar_events"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "calendar_events_staff_select"
on "public"."calendar_events"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = calendar_events.class_id) AND (ur.user_id = auth.uid()) AND (ur.role = ANY (ARRAY['instructor'::app_role, 'grader'::app_role]))))));


create policy "calendar_events_student_select"
on "public"."calendar_events"
as permissive
for select
to authenticated
using (((calendar_type = 'office_hours'::text) AND (EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = calendar_events.class_id) AND (ur.user_id = auth.uid()) AND (ur.disabled = false))))));


create policy "calendar_sync_state_service_role_all"
on "public"."calendar_sync_state"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "calendar_sync_state_staff_select"
on "public"."calendar_sync_state"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = calendar_sync_state.class_id) AND (ur.user_id = auth.uid()) AND (ur.role = ANY (ARRAY['instructor'::app_role, 'grader'::app_role]))))));


create policy "class_staff_settings_instructor_all"
on "public"."class_staff_settings"
as permissive
for all
to authenticated
using ((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = class_staff_settings.class_id) AND (ur.user_id = auth.uid()) AND (ur.role = 'instructor'::app_role)))))
with check ((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = class_staff_settings.class_id) AND (ur.user_id = auth.uid()) AND (ur.role = 'instructor'::app_role)))));


create policy "class_staff_settings_service_role_all"
on "public"."class_staff_settings"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "class_staff_settings_staff_select"
on "public"."class_staff_settings"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = class_staff_settings.class_id) AND (ur.user_id = auth.uid()) AND (ur.role = ANY (ARRAY['instructor'::app_role, 'grader'::app_role]))))));


create policy "classes_instructor_update_calendar_or_discord_ids"
on "public"."classes"
as permissive
for update
to authenticated
using ((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = classes.id) AND (ur.user_id = auth.uid()) AND (ur.role = 'instructor'::app_role)))))
with check (((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = classes.id) AND (ur.user_id = auth.uid()) AND (ur.role = 'instructor'::app_role)))) AND only_calendar_or_discord_ids_changed(classes.*)));


create policy "discord_async_worker_dlq_messages_service_role_insert"
on "public"."discord_async_worker_dlq_messages"
as permissive
for insert
to service_role
with check (true);


create policy "discord_async_worker_dlq_messages_service_role_select"
on "public"."discord_async_worker_dlq_messages"
as permissive
for select
to service_role
using (true);


create policy "discord_channels_service_role_all"
on "public"."discord_channels"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "discord_channels_staff_select"
on "public"."discord_channels"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = discord_channels.class_id) AND (ur.user_id = auth.uid()) AND (ur.role = ANY (ARRAY['instructor'::app_role, 'grader'::app_role]))))));


create policy "discord_invites_service_role_all"
on "public"."discord_invites"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "discord_invites_staff_select"
on "public"."discord_invites"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = discord_invites.class_id) AND (ur.user_id = auth.uid()) AND (ur.role = ANY (ARRAY['instructor'::app_role, 'grader'::app_role]))))));


create policy "discord_invites_user_select"
on "public"."discord_invites"
as permissive
for select
to authenticated
using ((user_id = auth.uid()));


create policy "discord_messages_service_role_all"
on "public"."discord_messages"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "discord_messages_staff_select"
on "public"."discord_messages"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = discord_messages.class_id) AND (ur.user_id = auth.uid()) AND (ur.role = ANY (ARRAY['instructor'::app_role, 'grader'::app_role]))))));


create policy "discord_roles_service_role_all"
on "public"."discord_roles"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "discord_roles_staff_select"
on "public"."discord_roles"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.class_id = discord_roles.class_id) AND (ur.user_id = auth.uid()) AND (ur.role = ANY (ARRAY['instructor'::app_role, 'grader'::app_role]))))));


CREATE TRIGGER trg_discord_create_assignment_channel AFTER INSERT ON public.assignments FOR EACH ROW EXECUTE FUNCTION trigger_discord_channel_creation();

CREATE TRIGGER broadcast_calendar_events_realtime AFTER INSERT OR DELETE OR UPDATE ON public.calendar_events FOR EACH ROW EXECUTE FUNCTION broadcast_calendar_events_change();

CREATE TRIGGER update_calendar_events_updated_at BEFORE UPDATE ON public.calendar_events FOR EACH ROW EXECUTE FUNCTION update_calendar_events_updated_at();

CREATE TRIGGER update_class_staff_settings_updated_at BEFORE UPDATE ON public.class_staff_settings FOR EACH ROW EXECUTE FUNCTION update_class_staff_settings_updated_at();

CREATE TRIGGER trg_discord_create_roles_on_server_connect AFTER UPDATE OF discord_server_id ON public.classes FOR EACH ROW EXECUTE FUNCTION trigger_discord_create_roles_on_server_connect();

CREATE TRIGGER trg_broadcast_discord_channel_change AFTER INSERT OR DELETE OR UPDATE ON public.discord_channels FOR EACH ROW EXECUTE FUNCTION broadcast_discord_channel_change();

CREATE TRIGGER trg_broadcast_discord_message_change AFTER INSERT OR DELETE OR UPDATE ON public.discord_messages FOR EACH ROW EXECUTE FUNCTION broadcast_discord_message_change();

CREATE TRIGGER trg_sync_existing_users_on_role_creation AFTER INSERT ON public.discord_roles FOR EACH ROW EXECUTE FUNCTION trigger_sync_existing_users_on_role_creation();

CREATE TRIGGER trg_discord_queue_assignment_notification AFTER INSERT OR UPDATE ON public.help_queue_assignments FOR EACH ROW EXECUTE FUNCTION trigger_discord_queue_assignment_notification();

CREATE TRIGGER trg_discord_create_queue_channel AFTER INSERT ON public.help_queues FOR EACH ROW EXECUTE FUNCTION trigger_discord_channel_creation();

CREATE TRIGGER trg_discord_help_request_feedback_notification AFTER INSERT OR UPDATE ON public.help_request_feedback FOR EACH ROW EXECUTE FUNCTION trigger_discord_help_request_feedback_notification();

CREATE TRIGGER trg_discord_help_request_notification AFTER INSERT OR UPDATE ON public.help_requests FOR EACH ROW EXECUTE FUNCTION trigger_discord_help_request_notification();

CREATE TRIGGER trg_discord_create_lab_channel AFTER INSERT ON public.lab_sections FOR EACH ROW EXECUTE FUNCTION trigger_discord_channel_creation();

CREATE TRIGGER trg_discord_regrade_request_notification AFTER INSERT OR UPDATE ON public.submission_regrade_requests FOR EACH ROW EXECUTE FUNCTION trigger_discord_regrade_request_notification();

CREATE TRIGGER trg_discord_role_sync AFTER INSERT OR DELETE OR UPDATE ON public.user_roles FOR EACH ROW EXECUTE FUNCTION trigger_discord_role_sync();



