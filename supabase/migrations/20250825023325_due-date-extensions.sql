create table "public"."student_deadline_extensions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "student_id" uuid not null,
    "class_id" bigint not null,
    "hours" integer not null,
    "includes_lab" boolean not null default false,
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."student_deadline_extensions" enable row level security;

CREATE UNIQUE INDEX student_deadline_extensions_pkey ON public.student_deadline_extensions USING btree (id);

CREATE UNIQUE INDEX student_deadline_extensions_unique_student_class ON public.student_deadline_extensions USING btree (student_id, class_id);

alter table "public"."student_deadline_extensions"
  add constraint "student_deadline_extensions_hours_non_negative"
  check (hours >= 0);

alter table "public"."student_deadline_extensions" add constraint "student_deadline_extensions_pkey" PRIMARY KEY using index "student_deadline_extensions_pkey";

alter table "public"."student_deadline_extensions" add constraint "student_deadline_extensions_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."student_deadline_extensions" validate constraint "student_deadline_extensions_class_id_fkey";

alter table "public"."student_deadline_extensions" add constraint "student_deadline_extensions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."student_deadline_extensions" validate constraint "student_deadline_extensions_student_id_fkey";

alter table "public"."student_deadline_extensions" add constraint "student_deadline_extensions_unique_student_class" UNIQUE using index "student_deadline_extensions_unique_student_class";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.apply_extensions_to_new_assignment()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_creator_profile_id uuid;
BEGIN
    -- Get the profile_id for the current user in this class context
    -- Typically, we'd use the private_profile_id from user_roles
    SELECT private_profile_id INTO v_creator_profile_id
    FROM user_roles
    WHERE user_id = auth.uid()
      AND class_id = NEW.class_id
      AND disabled = false
    LIMIT 1;
    
    -- If no profile found (shouldn't happen in normal operation), 
    -- we could either skip or use a system profile
    IF v_creator_profile_id IS NULL THEN
        -- Option 1: Skip the insert
        RETURN NEW;
        -- Option 2: Raise an exception
        -- RAISE EXCEPTION 'No profile found for user % in class %', auth.uid(), NEW.class_id;
    END IF;
    
    -- Only proceed if this is a regular assignment or a lab assignment with extensions that include labs
    INSERT INTO assignment_due_date_exceptions (
        assignment_id,
        student_id,
        class_id,
        creator_id,
        hours,
        minutes,
        tokens_consumed,
        note
    )
    SELECT 
        NEW.id,
        sde.student_id,
        NEW.class_id,
        v_creator_profile_id,
        sde.hours,
        0,
        0,
        'Instructor-granted extension for all assignments in class'
    FROM student_deadline_extensions sde
    WHERE sde.class_id = NEW.class_id
      AND (sde.includes_lab = true OR NEW.minutes_due_after_lab IS NULL)
      AND NOT EXISTS (
        SELECT 1
        FROM assignment_due_date_exceptions ade
        WHERE ade.assignment_id = NEW.id
          AND ade.student_id = sde.student_id
      );
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_assignment_exceptions_from_extension()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_creator_profile_id uuid;
BEGIN
    -- Get the profile_id for the current user in this class context
    SELECT private_profile_id INTO v_creator_profile_id
    FROM user_roles
    WHERE user_id = auth.uid()
      AND class_id = NEW.class_id
      AND disabled = false
    LIMIT 1;
    
    -- If no profile found, try to handle gracefully
    IF v_creator_profile_id IS NULL THEN
        -- For system-triggered operations, you might want to use a default
        -- instructor profile or skip the operation
        -- For now, we'll try to get any instructor profile for the class
        SELECT private_profile_id INTO v_creator_profile_id
        FROM user_roles
        WHERE class_id = NEW.class_id
          AND role IN ('instructor', 'admin')
          AND disabled = false
        LIMIT 1;
        
        -- If still no profile, we have to bail out
        IF v_creator_profile_id IS NULL THEN
            RAISE WARNING 'No suitable profile found for creating extension exceptions in class %', NEW.class_id;
            RETURN NEW;
        END IF;
    END IF;
    
    -- Insert exceptions for all assignments in the class
    -- Skip lab assignments if includes_lab is false
    INSERT INTO assignment_due_date_exceptions (
        assignment_id,
        student_id,
        class_id,
        creator_id,
        hours,
        minutes,
        tokens_consumed,
        note
    )
    SELECT 
        a.id,
        NEW.student_id,
        NEW.class_id,
        v_creator_profile_id,
        NEW.hours,
        0, -- No additional minutes
        0, -- No tokens consumed for instructor-granted extensions
        'Instructor-granted extension for all assignments in class'
    FROM assignments a
    WHERE a.class_id = NEW.class_id
        AND a.archived_at IS NULL
        -- Skip lab assignments if includes_lab is false
        AND (NEW.includes_lab = true OR a.minutes_due_after_lab IS NULL)
        -- Don't create duplicate exceptions
        AND NOT EXISTS (
            SELECT 1 FROM assignment_due_date_exceptions ade
            WHERE ade.assignment_id = a.id
                AND ade.student_id = NEW.student_id
        );
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.gift_tokens_to_student(p_student_id uuid, p_class_id bigint, p_assignment_id bigint, p_tokens_to_gift integer, p_note text DEFAULT 'Tokens gifted by instructor'::text)
 RETURNS bigint
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_creator_profile_id uuid;
    v_assignment_class_id bigint;
    v_student_in_class boolean;
    v_new_exception_id bigint;
BEGIN
    -- Verify instructor authorization
    IF NOT authorizeforclassinstructor(p_class_id) THEN
        RAISE EXCEPTION 'Unauthorized: Only instructors can gift tokens';
    END IF;
    
    -- Get the profile_id for the current user (instructor) in this class
    SELECT private_profile_id INTO v_creator_profile_id
    FROM user_roles
    WHERE user_id = auth.uid()
      AND class_id = p_class_id
      AND disabled = false
    LIMIT 1;
    
    -- Validate we found a profile
    IF v_creator_profile_id IS NULL THEN
        RAISE EXCEPTION 'Could not find profile for current user in class %', p_class_id;
    END IF;

    -- Validate positive gift amount
    IF p_tokens_to_gift <= 0 THEN
        RAISE EXCEPTION 'p_tokens_to_gift must be > 0 for gifting';
    END IF;

    -- Ensure assignment belongs to the class
    SELECT class_id INTO v_assignment_class_id
    FROM assignments
    WHERE id = p_assignment_id;
    IF v_assignment_class_id IS NULL OR v_assignment_class_id <> p_class_id THEN
        RAISE EXCEPTION 'Assignment % does not belong to class %', p_assignment_id, p_class_id;
    END IF;

    -- Ensure the student is in the class (by private profile)
    SELECT EXISTS (
      SELECT 1 FROM user_roles
      WHERE class_id = p_class_id
        AND private_profile_id = p_student_id
        AND disabled = false
        AND role = 'student'
    ) INTO v_student_in_class;
    IF NOT v_student_in_class THEN
        RAISE EXCEPTION 'Student % is not enrolled in class %', p_student_id, p_class_id;
    END IF;    
    
    -- Create a negative token consumption entry
    INSERT INTO assignment_due_date_exceptions (
        assignment_id,
        student_id,
        class_id,
        creator_id,
        hours,
        minutes,
        tokens_consumed,
        note
    )
    VALUES (
        p_assignment_id,
        p_student_id,
        p_class_id,
        v_creator_profile_id,
        0,
        0,
        -p_tokens_to_gift, -- Negative value represents gifted tokens
        p_note
    )
    RETURNING id INTO v_new_exception_id;
    
    -- Return the ID of the newly created exception
    RETURN v_new_exception_id;
END;
$function$
;

alter function public.gift_tokens_to_student(uuid, bigint, bigint, integer, text)
  set search_path = public, pg_temp;


CREATE OR REPLACE FUNCTION "public"."broadcast_course_table_change_unified"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
    class_id_value bigint;
    row_id text;
    staff_payload jsonb;
    student_payload jsonb;
    affected_profile_ids uuid[];
    profile_id uuid;
    creator_user_id uuid;
    creator_profile_id uuid;
    is_visible boolean;
BEGIN
    -- Get the class_id and row_id from the record
    IF TG_OP = 'INSERT' THEN
        class_id_value := NEW.class_id;
        row_id := NEW.id;
    ELSIF TG_OP = 'UPDATE' THEN
        class_id_value := COALESCE(NEW.class_id, OLD.class_id);
        row_id := COALESCE(NEW.id, OLD.id);
    ELSIF TG_OP = 'DELETE' THEN
        class_id_value := OLD.class_id;
        row_id := OLD.id;
    END IF;

    -- Only broadcast if we have valid class_id
    IF class_id_value IS NOT NULL THEN
        -- Create payload with table-specific information (staff scoped)
        staff_payload := jsonb_build_object(
            'type', 'staff_data_change',
            'operation', TG_OP,
            'table', TG_TABLE_NAME,
            'row_id', row_id,
            'class_id', class_id_value,
            'data', CASE 
                WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD)
                ELSE to_jsonb(NEW)
            END,
            'timestamp', NOW()
        );

        -- For student-facing notifications, start with the same payload (can be minimized later)
        student_payload := staff_payload;

        -- Broadcast to staff channel
        PERFORM realtime.send(
            staff_payload,
            'broadcast',
            'class:' || class_id_value || ':staff',
            true
        );

        -- Student-facing broadcasts by table, mirroring office-hours pattern where safe
        IF TG_TABLE_NAME IN ('lab_sections', 'lab_section_meetings', 'profiles') THEN
            -- Broadcast to all students in the class
            SELECT ARRAY(
                SELECT ur.private_profile_id
                FROM public.user_roles ur
                WHERE ur.class_id = class_id_value AND ur.role = 'student'
            ) INTO affected_profile_ids;

            FOREACH profile_id IN ARRAY affected_profile_ids LOOP
                PERFORM realtime.send(
                    staff_payload,
                    'broadcast',
                    'class:' || class_id_value || ':user:' || profile_id,
                    true
                );
            END LOOP;
        ELSIF TG_TABLE_NAME = 'tags' THEN
            -- Tags visible to class → broadcast to all students; non-visible → only to creator
            IF TG_OP = 'DELETE' THEN
                is_visible := COALESCE(OLD.visible, false);
                creator_user_id := OLD.creator_id;
            ELSE
                is_visible := COALESCE(NEW.visible, false);
                creator_user_id := NEW.creator_id;
            END IF;

            -- Notify creator for any change (even when not visible)
            SELECT ur.private_profile_id INTO creator_profile_id
            FROM public.user_roles ur
            WHERE ur.user_id = creator_user_id AND ur.class_id = class_id_value
            LIMIT 1;

            IF creator_profile_id IS NOT NULL THEN
                PERFORM realtime.send(
                    staff_payload,
                    'broadcast',
                    'class:' || class_id_value || ':user:' || creator_profile_id,
                    true
                );
            END IF;

            -- If visible, also broadcast to all students in the class
            IF is_visible THEN
                SELECT ARRAY(
                    SELECT ur.private_profile_id
                    FROM public.user_roles ur
                    WHERE ur.class_id = class_id_value AND ur.role = 'student'
                ) INTO affected_profile_ids;

                FOREACH profile_id IN ARRAY affected_profile_ids LOOP
                    PERFORM realtime.send(
                        staff_payload,
                        'broadcast',
                        'class:' || class_id_value || ':user:' || profile_id,
                        true
                    );
                END LOOP;
            END IF;
        ELSIF TG_TABLE_NAME = 'user_roles' THEN
            -- OPTIMIZATION: user_roles changes now ONLY go to staff
            -- Removed individual user notification - staff visibility is sufficient
            -- This eliminates unnecessary broadcasts when users join/leave classes
            NULL; -- No additional broadcasts beyond staff channel
        ELSIF TG_TABLE_NAME IN ('assignment_due_date_exceptions', 'student_deadline_extensions') THEN
            -- These tables affect specific students or groups
            -- Staff always see all changes (already handled above)

            -- For assignment_due_date_exceptions: notify affected students/groups
            IF TG_TABLE_NAME = 'assignment_due_date_exceptions' THEN
                IF TG_OP = 'DELETE' THEN
                    -- Notify the affected student if individual exception
                    IF OLD.student_id IS NOT NULL THEN
                        PERFORM realtime.send(
                            staff_payload,
                            'broadcast',
                            'class:' || class_id_value || ':user:' || OLD.student_id,
                            true
                        );
                    END IF;
                    -- For group exceptions, notify all group members
                    IF OLD.assignment_group_id IS NOT NULL THEN
                        SELECT ARRAY(
                            SELECT agm.profile_id
                            FROM public.assignment_groups_members agm
                            WHERE agm.assignment_group_id = OLD.assignment_group_id
                        ) INTO affected_profile_ids;

                        FOREACH profile_id IN ARRAY affected_profile_ids LOOP
                            PERFORM realtime.send(
                                staff_payload,
                                'broadcast',
                                'class:' || class_id_value || ':user:' || profile_id,
                                true
                            );
                        END LOOP;
                    END IF;
                ELSE
                    -- For INSERT/UPDATE operations
                    IF NEW.student_id IS NOT NULL THEN
                        PERFORM realtime.send(
                            staff_payload,
                            'broadcast',
                            'class:' || class_id_value || ':user:' || NEW.student_id,
                            true
                        );
                    END IF;
                    IF NEW.assignment_group_id IS NOT NULL THEN
                        SELECT ARRAY(
                            SELECT agm.profile_id
                            FROM public.assignment_groups_members agm
                            WHERE agm.assignment_group_id = NEW.assignment_group_id
                        ) INTO affected_profile_ids;

                        FOREACH profile_id IN ARRAY affected_profile_ids LOOP
                            PERFORM realtime.send(
                                staff_payload,
                                'broadcast',
                                'class:' || class_id_value || ':user:' || profile_id,
                                true
                            );
                        END LOOP;
                    END IF;
                END IF;
            ELSIF TG_TABLE_NAME = 'student_deadline_extensions' THEN
                -- Notify the specific student about their extension
                IF TG_OP = 'DELETE' THEN
                    PERFORM realtime.send(
                        staff_payload,
                        'broadcast',
                        'class:' || class_id_value || ':user:' || OLD.student_id,
                        true
                    );
                ELSE
                    PERFORM realtime.send(
                        staff_payload,
                        'broadcast',
                        'class:' || class_id_value || ':user:' || NEW.student_id,
                        true
                    );
                END IF;
            END IF;
        END IF;
    END IF;

    -- Return the appropriate record
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$$;

grant delete on table "public"."student_deadline_extensions" to "anon";

grant insert on table "public"."student_deadline_extensions" to "anon";

grant references on table "public"."student_deadline_extensions" to "anon";

grant select on table "public"."student_deadline_extensions" to "anon";

grant trigger on table "public"."student_deadline_extensions" to "anon";

grant truncate on table "public"."student_deadline_extensions" to "anon";

grant update on table "public"."student_deadline_extensions" to "anon";

grant delete on table "public"."student_deadline_extensions" to "authenticated";

grant insert on table "public"."student_deadline_extensions" to "authenticated";

grant references on table "public"."student_deadline_extensions" to "authenticated";

grant select on table "public"."student_deadline_extensions" to "authenticated";

grant trigger on table "public"."student_deadline_extensions" to "authenticated";

grant truncate on table "public"."student_deadline_extensions" to "authenticated";

grant update on table "public"."student_deadline_extensions" to "authenticated";

grant delete on table "public"."student_deadline_extensions" to "service_role";

grant insert on table "public"."student_deadline_extensions" to "service_role";

grant references on table "public"."student_deadline_extensions" to "service_role";

grant select on table "public"."student_deadline_extensions" to "service_role";

grant trigger on table "public"."student_deadline_extensions" to "service_role";

grant truncate on table "public"."student_deadline_extensions" to "service_role";

grant update on table "public"."student_deadline_extensions" to "service_role";

create policy "Course staff can CRUD"
on "public"."student_deadline_extensions"
as permissive
for all
to authenticated
using (authorizeforclassgrader(class_id))
with check (authorizeforclassgrader(class_id));

create policy "Students can see their own"
on "public"."student_deadline_extensions"
as permissive
for select
to authenticated
using (authorizeforprofile(student_id));

CREATE TRIGGER on_assignment_created_apply_extensions AFTER INSERT ON public.assignments FOR EACH ROW EXECUTE FUNCTION apply_extensions_to_new_assignment();

CREATE TRIGGER broadcast_student_deadline_extensions_realtime AFTER INSERT OR DELETE OR UPDATE ON public.student_deadline_extensions FOR EACH ROW EXECUTE FUNCTION broadcast_course_table_change_unified();

CREATE TRIGGER on_student_deadline_extension_created AFTER INSERT ON public.student_deadline_extensions FOR EACH ROW EXECUTE FUNCTION create_assignment_exceptions_from_extension();

ALTER FUNCTION public.create_assignment_exceptions_from_extension()  
  SET search_path = public, pg_temp;

CREATE TRIGGER broadcast_assignment_due_date_exceptions_realtime 
AFTER INSERT OR DELETE OR UPDATE ON public.assignment_due_date_exceptions 
FOR EACH ROW EXECUTE FUNCTION broadcast_course_table_change_unified();


