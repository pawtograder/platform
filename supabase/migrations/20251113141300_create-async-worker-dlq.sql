-- Create dead letter queue for async worker
-- Messages that fail 5 or more times will be sent here for manual review

-- Create the dead letter queue
do $$
begin
  perform pgmq.create('async_calls_dlq');
exception when others then
  -- queue likely exists; ignore
  null;
end $$;

-- Create table to track DLQ messages with error context
create table if not exists public.async_worker_dlq_messages (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  original_msg_id bigint,
  method public.github_async_method not null,
  envelope jsonb not null,
  error_message text,
  error_type text,
  retry_count integer not null,
  last_error_context jsonb,
  class_id bigint references public.classes(id) on delete set null,
  debug_id text,
  log_id bigint
);

-- Add indexes for efficient querying
create index if not exists async_worker_dlq_messages_created_at_idx 
  on public.async_worker_dlq_messages(created_at desc);

create index if not exists async_worker_dlq_messages_class_id_idx 
  on public.async_worker_dlq_messages(class_id);

create index if not exists async_worker_dlq_messages_method_idx 
  on public.async_worker_dlq_messages(method);

-- Enable RLS
alter table public.async_worker_dlq_messages enable row level security;

-- Tighten grants; RLS will also apply
revoke all on table public.async_worker_dlq_messages from anon, authenticated;
grant insert, select on table public.async_worker_dlq_messages to service_role;

-- RLS policy for service_role only
drop policy if exists async_worker_dlq_messages_service_role_select on public.async_worker_dlq_messages;
create policy async_worker_dlq_messages_service_role_select
  on public.async_worker_dlq_messages
  for select
  to service_role
  using (true);

drop policy if exists async_worker_dlq_messages_service_role_insert on public.async_worker_dlq_messages;
create policy async_worker_dlq_messages_service_role_insert
  on public.async_worker_dlq_messages
  for insert
  to service_role
  with check (true);

-- Create RPC function to get async queue sizes and circuit breaker statuses for metrics endpoint

create or replace function public.get_async_queue_sizes()
returns table (
  async_queue_size bigint,
  dlq_queue_size bigint,
  gradebook_row_recalculate_queue_size bigint
)
language plpgsql
security definer
set search_path = public, pgmq
as $$
begin
  return query
  select 
    (select count(*)::bigint from pgmq.q_async_calls where vt <= now()) as async_queue_size,
    (select count(*)::bigint from pgmq.q_async_calls_dlq where vt <= now()) as dlq_queue_size,
    (select count(*)::bigint from pgmq.q_gradebook_row_recalculate where vt <= now()) as gradebook_row_recalculate_queue_size;
end;
$$;

-- Grant execute permission to service_role
revoke all on function public.get_async_queue_sizes() from public;
grant execute on function public.get_async_queue_sizes() to service_role;

-- Create RPC function to get circuit breaker statuses
create or replace function public.get_circuit_breaker_statuses()
returns table (
  scope text,
  key text,
  is_open boolean,
  state text,
  open_until timestamptz,
  trip_count integer
)
language plpgsql
security definer
set search_path = public
as $$
begin
  return query
  select 
    cb.scope,
    cb.key,
    (cb.state = 'open' AND (cb.open_until IS NULL OR cb.open_until >= now())) as is_open,
    cb.state,
    cb.open_until,
    cb.trip_count
  from public.github_circuit_breakers cb
  order by cb.scope, cb.key;
end;
$$;

-- Grant execute permission to service_role
revoke all on function public.get_circuit_breaker_statuses() from public;
grant execute on function public.get_circuit_breaker_statuses() to service_role;

