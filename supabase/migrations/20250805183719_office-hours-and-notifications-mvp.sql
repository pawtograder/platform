create type "public"."email_digest_frequency" as enum ('daily', 'weekly', 'disabled');

create type "public"."help_queue_type" as enum ('text', 'video', 'in_person');

create type "public"."help_request_status" as enum ('open', 'in_progress', 'resolved', 'closed');

create type "public"."location_type" as enum ('remote', 'in_person', 'hybrid');

create type "public"."moderation_action_type" as enum ('warning', 'temporary_ban', 'permanent_ban');

create type "public"."notification_type" as enum ('immediate', 'digest', 'disabled');

create type "public"."student_help_activity_type" as enum ('request_created', 'request_updated', 'message_sent', 'request_resolved', 'video_joined', 'video_left');

drop policy "instructors and graders view all, students view own" on "public"."help_request_messages";

drop policy "insert for own class" on "public"."help_requests";

drop policy "students can set resolved" on "public"."help_requests";

drop policy "students view own, instructors and graders view all" on "public"."help_requests";

drop policy "graders and instructors can view class tags" on "public"."tags";

drop policy "graders and instructors can delete class tags" on "public"."tags";

drop policy "graders and instructors can insert to class tags" on "public"."tags";

drop policy "graders and instructors can update class tags" on "public"."tags";

alter table "public"."help_requests" drop constraint "help_requests_creator_fkey";

drop function if exists "public"."is_instructor_for_class"(_person_id uuid, _class_id integer);

create table "public"."help_queue_assignments" (
    "id" bigint generated by default as identity not null,
    "started_at" timestamp with time zone not null default now(),
    "help_queue_id" bigint not null,
    "class_id" bigint not null,
    "ended_at" timestamp with time zone,
    "is_active" boolean not null default true,
    "max_concurrent_students" integer not null default 3,
    "ta_profile_id" uuid not null
);


alter table "public"."help_queue_assignments" enable row level security;

create table "public"."help_request_feedback" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "thumbs_up" boolean not null,
    "comment" text,
    "class_id" bigint not null,
    "help_request_id" bigint not null,
    "student_profile_id" uuid not null
);


alter table "public"."help_request_feedback" enable row level security;

create table "public"."help_request_file_references" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "help_request_id" bigint not null,
    "class_id" bigint not null,
    "submission_file_id" bigint,
    "submission_id" bigint,
    "line_number" bigint,
    "assignment_id" bigint not null
);


alter table "public"."help_request_file_references" enable row level security;

create table "public"."help_request_message_read_receipts" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "message_id" bigint not null,
    "viewer_id" uuid not null,
    "class_id" bigint not null,
    "help_request_id" bigint
);


alter table "public"."help_request_message_read_receipts" enable row level security;

create table "public"."help_request_moderation" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "help_request_id" bigint not null,
    "message_id" bigint,
    "student_profile_id" uuid not null,
    "moderator_profile_id" uuid not null,
    "class_id" bigint not null,
    "action_type" moderation_action_type not null,
    "reason" text,
    "duration_minutes" bigint,
    "is_permanent" boolean not null default false,
    "expires_at" timestamp with time zone
);


alter table "public"."help_request_moderation" enable row level security;

create table "public"."help_request_students" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "help_request_id" bigint not null,
    "profile_id" uuid not null,
    "class_id" bigint not null
);


alter table "public"."help_request_students" enable row level security;

create table "public"."help_request_templates" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "class_id" bigint not null,
    "name" text not null,
    "description" text,
    "template_content" text not null,
    "category" text not null,
    "is_active" boolean not null default true,
    "usage_count" bigint not null default '0'::bigint,
    "created_by_id" uuid not null
);


alter table "public"."help_request_templates" enable row level security;

create table "public"."help_request_watchers" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "help_request_id" bigint not null,
    "class_id" bigint not null,
    "enabled" boolean not null
);


alter table "public"."help_request_watchers" enable row level security;

create table "public"."notification_preferences" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "class_id" bigint not null,
    "help_request_notifications" notification_type not null default 'digest'::notification_type,
    "help_request_message_notifications" notification_type not null default 'immediate'::notification_type,
    "email_digest_frequency" email_digest_frequency not null default 'daily'::email_digest_frequency,
    "updated_at" timestamp with time zone
);


alter table "public"."notification_preferences" enable row level security;

create table "public"."student_help_activity" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "student_profile_id" uuid not null,
    "class_id" bigint not null,
    "help_request_id" bigint not null,
    "activity_type" student_help_activity_type not null,
    "activity_description" text
);


alter table "public"."student_help_activity" enable row level security;

create table "public"."student_karma_notes" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "student_profile_id" uuid not null,
    "class_id" bigint not null,
    "karma_score" bigint not null default '0'::bigint,
    "internal_notes" text default ''::text,
    "created_by_id" uuid not null,
    "updated_at" timestamp with time zone not null default now(),
    "last_activity_at" timestamp with time zone
);


alter table "public"."student_karma_notes" enable row level security;

alter table "public"."help_queues" add column "is_active" boolean not null default true;

alter table "public"."help_queues" add column "max_concurrent_requests" integer;

alter table "public"."help_queues" add column "queue_type" help_queue_type not null default 'text'::help_queue_type;

alter table "public"."help_request_messages" drop column "requestor";

alter table "public"."help_request_messages" add column "reply_to_message_id" bigint;

alter table "public"."help_requests" drop column "creator";

alter table "public"."help_requests" add column "created_by" uuid;

alter table "public"."help_requests" add column "is_private" boolean not null default false;

alter table "public"."help_requests" add column "location_type" location_type not null default 'remote'::location_type;

alter table "public"."help_requests" add column "referenced_submission_id" bigint;

alter table "public"."help_requests" add column "status" help_request_status not null default 'open'::help_request_status;

alter table "public"."help_requests" add column "template_id" bigint;

CREATE UNIQUE INDEX help_queue_assignments_pkey ON public.help_queue_assignments USING btree (id);

CREATE UNIQUE INDEX help_request_feedback_pkey ON public.help_request_feedback USING btree (id);

CREATE UNIQUE INDEX help_request_file_references_pkey ON public.help_request_file_references USING btree (id);

CREATE UNIQUE INDEX help_request_message_read_receipts_pkey ON public.help_request_message_read_receipts USING btree (id);

CREATE UNIQUE INDEX help_request_moderation_pkey ON public.help_request_moderation USING btree (id);

CREATE UNIQUE INDEX help_request_students_pkey ON public.help_request_students USING btree (id);

CREATE UNIQUE INDEX help_request_templates_pkey ON public.help_request_templates USING btree (id);

CREATE INDEX help_request_watchers_class_id_idx ON public.help_request_watchers USING btree (class_id);

CREATE INDEX help_request_watchers_help_request_id_idx ON public.help_request_watchers USING btree (help_request_id);

CREATE UNIQUE INDEX help_request_watchers_pkey ON public.help_request_watchers USING btree (id);

CREATE UNIQUE INDEX help_request_watchers_user_help_request_unique ON public.help_request_watchers USING btree (user_id, help_request_id);

CREATE INDEX help_request_watchers_user_id_idx ON public.help_request_watchers USING btree (user_id);

CREATE UNIQUE INDEX notification_preferences_pkey ON public.notification_preferences USING btree (id);

CREATE UNIQUE INDEX student_help_activity_pkey ON public.student_help_activity USING btree (id);

CREATE UNIQUE INDEX student_karma_notes_pkey ON public.student_karma_notes USING btree (id);

alter table "public"."help_queue_assignments" add constraint "help_queue_assignments_pkey" PRIMARY KEY using index "help_queue_assignments_pkey";

alter table "public"."help_request_feedback" add constraint "help_request_feedback_pkey" PRIMARY KEY using index "help_request_feedback_pkey";

alter table "public"."help_request_file_references" add constraint "help_request_file_references_pkey" PRIMARY KEY using index "help_request_file_references_pkey";

alter table "public"."help_request_message_read_receipts" add constraint "help_request_message_read_receipts_pkey" PRIMARY KEY using index "help_request_message_read_receipts_pkey";

alter table "public"."help_request_moderation" add constraint "help_request_moderation_pkey" PRIMARY KEY using index "help_request_moderation_pkey";

alter table "public"."help_request_students" add constraint "help_request_students_pkey" PRIMARY KEY using index "help_request_students_pkey";

alter table "public"."help_request_templates" add constraint "help_request_templates_pkey" PRIMARY KEY using index "help_request_templates_pkey";

alter table "public"."help_request_watchers" add constraint "help_request_watchers_pkey" PRIMARY KEY using index "help_request_watchers_pkey";

alter table "public"."notification_preferences" add constraint "notification_preferences_pkey" PRIMARY KEY using index "notification_preferences_pkey";

alter table "public"."student_help_activity" add constraint "student_help_activity_pkey" PRIMARY KEY using index "student_help_activity_pkey";

alter table "public"."student_karma_notes" add constraint "student_karma_notes_pkey" PRIMARY KEY using index "student_karma_notes_pkey";

alter table "public"."help_queue_assignments" add constraint "help_queue_assignments_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_queue_assignments" validate constraint "help_queue_assignments_class_id_fkey";

alter table "public"."help_queue_assignments" add constraint "help_queue_assignments_help_queue_id_fkey" FOREIGN KEY (help_queue_id) REFERENCES help_queues(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_queue_assignments" validate constraint "help_queue_assignments_help_queue_id_fkey";

alter table "public"."help_queue_assignments" add constraint "help_queue_assignments_ta_profile_id_fkey" FOREIGN KEY (ta_profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_queue_assignments" validate constraint "help_queue_assignments_ta_profile_id_fkey";

alter table "public"."help_request_feedback" add constraint "help_request_feedback_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_feedback" validate constraint "help_request_feedback_class_id_fkey";

alter table "public"."help_request_feedback" add constraint "help_request_feedback_help_request_id_fkey" FOREIGN KEY (help_request_id) REFERENCES help_requests(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_feedback" validate constraint "help_request_feedback_help_request_id_fkey";

alter table "public"."help_request_feedback" add constraint "help_request_feedback_student_profile_id_fkey" FOREIGN KEY (student_profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_feedback" validate constraint "help_request_feedback_student_profile_id_fkey";

alter table "public"."help_request_file_references" add constraint "help_request_file_references_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES assignments(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_file_references" validate constraint "help_request_file_references_assignment_id_fkey";

alter table "public"."help_request_file_references" add constraint "help_request_file_references_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_file_references" validate constraint "help_request_file_references_class_id_fkey";

alter table "public"."help_request_file_references" add constraint "help_request_file_references_help_request_id_fkey" FOREIGN KEY (help_request_id) REFERENCES help_requests(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_file_references" validate constraint "help_request_file_references_help_request_id_fkey";

alter table "public"."help_request_file_references" add constraint "help_request_file_references_submission_file_id_fkey" FOREIGN KEY (submission_file_id) REFERENCES submission_files(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."help_request_file_references" validate constraint "help_request_file_references_submission_file_id_fkey";

alter table "public"."help_request_file_references" add constraint "help_request_file_references_submission_id_fkey" FOREIGN KEY (submission_id) REFERENCES submissions(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."help_request_file_references" validate constraint "help_request_file_references_submission_id_fkey";

alter table "public"."help_request_message_read_receipts" add constraint "help_request_message_read_receipts_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_message_read_receipts" validate constraint "help_request_message_read_receipts_class_id_fkey";

alter table "public"."help_request_message_read_receipts" add constraint "help_request_message_read_receipts_help_request_id_fkey" FOREIGN KEY (help_request_id) REFERENCES help_requests(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_message_read_receipts" validate constraint "help_request_message_read_receipts_help_request_id_fkey";

alter table "public"."help_request_message_read_receipts" add constraint "help_request_message_read_receipts_message_id_fkey" FOREIGN KEY (message_id) REFERENCES help_request_messages(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_message_read_receipts" validate constraint "help_request_message_read_receipts_message_id_fkey";

alter table "public"."help_request_message_read_receipts" add constraint "help_request_message_read_receipts_viewer_id_fkey" FOREIGN KEY (viewer_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_message_read_receipts" validate constraint "help_request_message_read_receipts_viewer_id_fkey";

alter table "public"."help_request_messages" add constraint "help_request_messages_reply_to_message_id_fkey" FOREIGN KEY (reply_to_message_id) REFERENCES help_request_messages(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."help_request_messages" validate constraint "help_request_messages_reply_to_message_id_fkey";

alter table "public"."help_request_moderation" add constraint "help_request_moderation_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_moderation" validate constraint "help_request_moderation_class_id_fkey";

alter table "public"."help_request_moderation" add constraint "help_request_moderation_help_request_id_fkey" FOREIGN KEY (help_request_id) REFERENCES help_requests(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_moderation" validate constraint "help_request_moderation_help_request_id_fkey";

alter table "public"."help_request_moderation" add constraint "help_request_moderation_message_id_fkey" FOREIGN KEY (message_id) REFERENCES help_request_messages(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."help_request_moderation" validate constraint "help_request_moderation_message_id_fkey";

alter table "public"."help_request_moderation" add constraint "help_request_moderation_moderator_profile_id_fkey" FOREIGN KEY (moderator_profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_moderation" validate constraint "help_request_moderation_moderator_profile_id_fkey";

alter table "public"."help_request_moderation" add constraint "help_request_moderation_student_profile_id_fkey" FOREIGN KEY (student_profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_moderation" validate constraint "help_request_moderation_student_profile_id_fkey";

alter table "public"."help_request_students" add constraint "help_request_students_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_students" validate constraint "help_request_students_class_id_fkey";

alter table "public"."help_request_students" add constraint "help_request_students_help_request_id_fkey" FOREIGN KEY (help_request_id) REFERENCES help_requests(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_students" validate constraint "help_request_students_help_request_id_fkey";

alter table "public"."help_request_students" add constraint "help_request_students_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_students" validate constraint "help_request_students_profile_id_fkey";

alter table "public"."help_request_templates" add constraint "help_request_templates_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_templates" validate constraint "help_request_templates_class_id_fkey";

alter table "public"."help_request_templates" add constraint "help_request_templates_created_by_id_fkey" FOREIGN KEY (created_by_id) REFERENCES users(user_id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."help_request_templates" validate constraint "help_request_templates_created_by_id_fkey";

alter table "public"."help_request_watchers" add constraint "help_request_watchers_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_watchers" validate constraint "help_request_watchers_class_id_fkey";

alter table "public"."help_request_watchers" add constraint "help_request_watchers_help_request_id_fkey" FOREIGN KEY (help_request_id) REFERENCES help_requests(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_watchers" validate constraint "help_request_watchers_help_request_id_fkey";

alter table "public"."help_request_watchers" add constraint "help_request_watchers_user_help_request_unique" UNIQUE using index "help_request_watchers_user_help_request_unique";

alter table "public"."help_request_watchers" add constraint "help_request_watchers_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."help_request_watchers" validate constraint "help_request_watchers_user_id_fkey";

alter table "public"."help_requests" add constraint "help_requests_created_by_fkey" FOREIGN KEY (created_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."help_requests" validate constraint "help_requests_created_by_fkey";

alter table "public"."help_requests" add constraint "help_requests_referenced_submission_id_fkey" FOREIGN KEY (referenced_submission_id) REFERENCES submissions(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."help_requests" validate constraint "help_requests_referenced_submission_id_fkey";

alter table "public"."help_requests" add constraint "help_requests_template_id_fkey" FOREIGN KEY (template_id) REFERENCES help_request_templates(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."help_requests" validate constraint "help_requests_template_id_fkey";

alter table "public"."notification_preferences" add constraint "notification_preferences_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."notification_preferences" validate constraint "notification_preferences_class_id_fkey";

alter table "public"."notification_preferences" add constraint "notification_preferences_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."notification_preferences" validate constraint "notification_preferences_user_id_fkey";

alter table "public"."student_help_activity" add constraint "student_help_activity_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."student_help_activity" validate constraint "student_help_activity_class_id_fkey";

alter table "public"."student_help_activity" add constraint "student_help_activity_help_request_id_fkey" FOREIGN KEY (help_request_id) REFERENCES help_requests(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."student_help_activity" validate constraint "student_help_activity_help_request_id_fkey";

alter table "public"."student_help_activity" add constraint "student_help_activity_student_profile_id_fkey" FOREIGN KEY (student_profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."student_help_activity" validate constraint "student_help_activity_student_profile_id_fkey";

alter table "public"."student_karma_notes" add constraint "student_karma_notes_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."student_karma_notes" validate constraint "student_karma_notes_class_id_fkey";

alter table "public"."student_karma_notes" add constraint "student_karma_notes_created_by_id_fkey" FOREIGN KEY (created_by_id) REFERENCES users(user_id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."student_karma_notes" validate constraint "student_karma_notes_created_by_id_fkey";

alter table "public"."student_karma_notes" add constraint "student_karma_notes_student_profile_id_fkey" FOREIGN KEY (student_profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."student_karma_notes" validate constraint "student_karma_notes_student_profile_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.broadcast_help_queue_data_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    help_queue_id BIGINT;
    class_id BIGINT;
    row_id BIGINT;
    queue_payload JSONB;
BEGIN
    -- Get help_queue_id and class_id based on the table
    IF TG_TABLE_NAME = 'help_queues' THEN
        IF TG_OP = 'INSERT' THEN
            help_queue_id := NEW.id;
            class_id := NEW.class_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'UPDATE' THEN
            help_queue_id := NEW.id;
            class_id := NEW.class_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'DELETE' THEN
            help_queue_id := OLD.id;
            class_id := OLD.class_id;
            row_id := OLD.id;
        END IF;
    ELSIF TG_TABLE_NAME = 'help_queue_assignments' THEN
        IF TG_OP = 'INSERT' THEN
            help_queue_id := NEW.help_queue_id;
            class_id := NEW.class_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'UPDATE' THEN
            help_queue_id := NEW.help_queue_id;
            class_id := NEW.class_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'DELETE' THEN
            help_queue_id := OLD.help_queue_id;
            class_id := OLD.class_id;
            row_id := OLD.id;
        END IF;
    ELSIF TG_TABLE_NAME = 'help_requests' THEN
        -- For help requests, we also need to update the help queue status
        IF TG_OP = 'INSERT' THEN
            help_queue_id := NEW.help_queue;
            class_id := NEW.class_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'UPDATE' THEN
            help_queue_id := COALESCE(NEW.help_queue, OLD.help_queue);
            class_id := COALESCE(NEW.class_id, OLD.class_id);
            row_id := NEW.id;
        ELSIF TG_OP = 'DELETE' THEN
            help_queue_id := OLD.help_queue;
            class_id := OLD.class_id;
            row_id := OLD.id;
        END IF;
    END IF;

    -- Only broadcast if we have valid help_queue_id and class_id
    IF help_queue_id IS NOT NULL AND class_id IS NOT NULL THEN
        -- Create payload with help queue specific information
        queue_payload := jsonb_build_object(
            'type', 'queue_change',
            'operation', TG_OP,
            'table', TG_TABLE_NAME,
            'row_id', row_id,
            'help_queue_id', help_queue_id,
            'class_id', class_id,
            'data', CASE 
                WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD)
                ELSE to_jsonb(NEW)
            END,
            'timestamp', NOW()
        );

        -- Broadcast to individual help queue channel
        PERFORM realtime.send(
            queue_payload,
            'broadcast',
            'help_queue:' || help_queue_id,
            true
        );

        -- Also broadcast to global help queues channel
        PERFORM realtime.send(
            queue_payload,
            'broadcast',
            'help_queues',
            true
        );
    END IF;

    -- Return the appropriate record
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.broadcast_help_request_data_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    help_request_id BIGINT;
    class_id BIGINT;
    row_id BIGINT;
    main_payload JSONB;
BEGIN
    -- Get the help_request_id and class_id based on the table
    IF TG_TABLE_NAME = 'help_requests' THEN
        IF TG_OP = 'INSERT' THEN
            help_request_id := NEW.id;
            class_id := NEW.class_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'UPDATE' THEN
            help_request_id := NEW.id;
            class_id := NEW.class_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'DELETE' THEN
            help_request_id := OLD.id;
            class_id := OLD.class_id;
            row_id := OLD.id;
        END IF;
    ELSE
        -- For related tables, get help_request_id from the appropriate column
        IF TG_TABLE_NAME = 'help_request_message_read_receipts' THEN
            -- For read receipts, use direct help_request_id if available, otherwise lookup via message_id
            IF TG_OP = 'INSERT' THEN
                help_request_id := COALESCE(NEW.help_request_id, (
                    SELECT hrm.help_request_id
                    FROM public.help_request_messages hrm
                    WHERE hrm.id = NEW.message_id
                ));
                class_id := NEW.class_id;
                row_id := NEW.id;
            ELSIF TG_OP = 'UPDATE' THEN
                help_request_id := COALESCE(NEW.help_request_id, (
                    SELECT hrm.help_request_id
                    FROM public.help_request_messages hrm
                    WHERE hrm.id = NEW.message_id
                ));
                class_id := NEW.class_id;
                row_id := NEW.id;
            ELSIF TG_OP = 'DELETE' THEN
                help_request_id := COALESCE(OLD.help_request_id, (
                    SELECT hrm.help_request_id
                    FROM public.help_request_messages hrm
                    WHERE hrm.id = OLD.message_id
                ));
                class_id := OLD.class_id;
                row_id := OLD.id;
            END IF;
        ELSE
            -- For other related tables, get help_request_id from the direct column
            IF TG_OP = 'INSERT' THEN
                help_request_id := NEW.help_request_id;
                class_id := NEW.class_id;
                row_id := NEW.id;
            ELSIF TG_OP = 'UPDATE' THEN
                help_request_id := COALESCE(NEW.help_request_id, OLD.help_request_id);
                class_id := COALESCE(NEW.class_id, OLD.class_id);
                row_id := NEW.id;
            ELSIF TG_OP = 'DELETE' THEN
                help_request_id := OLD.help_request_id;
                class_id := OLD.class_id;
                row_id := OLD.id;
            END IF;
        END IF;
    END IF;

    -- Only broadcast if we have valid help_request_id and class_id
    IF help_request_id IS NOT NULL AND class_id IS NOT NULL THEN
        -- Create payload with help request specific information
        main_payload := jsonb_build_object(
            'type', 'table_change',
            'operation', TG_OP,
            'table', TG_TABLE_NAME,
            'row_id', row_id,
            'help_request_id', help_request_id,
            'class_id', class_id,
            'data', CASE 
                WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD)
                ELSE to_jsonb(NEW)
            END,
            'timestamp', NOW()
        );

        -- Broadcast to main help request channel
        PERFORM realtime.send(
            main_payload,
            'broadcast',
            'help_request:' || help_request_id,
            true
        );
    END IF;

    -- Return the appropriate record
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.broadcast_help_request_staff_data_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    help_request_id BIGINT;
    class_id BIGINT;
    student_profile_id UUID;
    row_id BIGINT;
    staff_payload JSONB;
BEGIN
    -- Get relevant IDs based on table
    IF TG_TABLE_NAME = 'help_request_moderation' THEN
        IF TG_OP = 'INSERT' THEN
            help_request_id := NEW.help_request_id;
            class_id := NEW.class_id;
            student_profile_id := NEW.student_profile_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'UPDATE' THEN
            help_request_id := NEW.help_request_id;
            class_id := NEW.class_id;
            student_profile_id := NEW.student_profile_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'DELETE' THEN
            help_request_id := OLD.help_request_id;
            class_id := OLD.class_id;
            student_profile_id := OLD.student_profile_id;
            row_id := OLD.id;
        END IF;
    ELSIF TG_TABLE_NAME = 'student_karma_notes' THEN
        -- For karma data, we'll broadcast to all relevant help request staff channels
        -- This is more complex as karma isn't directly tied to a help request
        -- For now, we'll just broadcast to class-level staff channels
        IF TG_OP = 'INSERT' THEN
            class_id := NEW.class_id;
            student_profile_id := NEW.student_profile_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'UPDATE' THEN
            class_id := NEW.class_id;
            student_profile_id := NEW.student_profile_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'DELETE' THEN
            class_id := OLD.class_id;
            student_profile_id := OLD.student_profile_id;
            row_id := OLD.id;
        END IF;
    ELSIF TG_TABLE_NAME = 'help_request_templates' THEN
        -- For template data, broadcast to class-level channels since templates are class-wide resources
        IF TG_OP = 'INSERT' THEN
            class_id := NEW.class_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'UPDATE' THEN
            class_id := NEW.class_id;
            row_id := NEW.id;
        ELSIF TG_OP = 'DELETE' THEN
            class_id := OLD.class_id;
            row_id := OLD.id;
        END IF;
    END IF;

    -- Only broadcast if we have valid class_id
    IF class_id IS NOT NULL THEN
        -- Create payload with staff-specific information
        staff_payload := jsonb_build_object(
            'type', 'staff_data_change',
            'operation', TG_OP,
            'table', TG_TABLE_NAME,
            'row_id', row_id,
            'class_id', class_id,
            'student_profile_id', student_profile_id,
            'help_request_id', help_request_id,
            'data', CASE 
                WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD)
                ELSE to_jsonb(NEW)
            END,
            'timestamp', NOW()
        );

        -- If tied to a specific help request, broadcast to that help request's staff channel
        IF help_request_id IS NOT NULL THEN
            PERFORM realtime.send(
                staff_payload,
                'broadcast',
                'help_request:' || help_request_id || ':staff',
                true
            );
        END IF;

        -- For karma data and templates, also broadcast to class-level channels
        IF TG_TABLE_NAME = 'student_karma_notes' THEN
            PERFORM realtime.send(
                staff_payload,
                'broadcast',
                'class:' || class_id || ':staff',
                true
            );
        ELSIF TG_TABLE_NAME = 'help_request_templates' THEN
            -- Broadcast template changes to both staff and general class channels
            PERFORM realtime.send(
                staff_payload,
                'broadcast',
                'class:' || class_id || ':staff',
                true
            );
            PERFORM realtime.send(
                staff_payload,
                'broadcast',
                'class:' || class_id,
                true
            );
        END IF;
    END IF;

    -- Return the appropriate record
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_access_help_request(help_request_id bigint)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
  select
    case 
      when hr.is_private = false then
        -- Public help requests: user must be authorized for the class
        public.authorizeforclass(hr.class_id)
      when hr.is_private = true then
        -- Private help requests: user must be assignee, class grader, or student member
        (auth.uid() = hr.assignee) 
        or public.authorizeforclassgrader(hr.class_id)
        or public.user_is_in_help_request(hr.id)
      else
        -- Default deny
        false
    end
  from public.help_requests hr
  where hr.id = help_request_id;
$function$
;

CREATE OR REPLACE FUNCTION public.create_help_queue_channels()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Pre-create the individual help queue channel
    PERFORM realtime.send(
        jsonb_build_object(
            'type', 'channel_created',
            'help_queue_id', NEW.id,
            'class_id', NEW.class_id,
            'created_at', NOW()
        ),
        'system',
        'help_queue:' || NEW.id,
        true
    );

    -- Also broadcast to the global help_queues channel
    PERFORM realtime.send(
        jsonb_build_object(
            'type', 'help_queue_created',
            'help_queue_id', NEW.id,
            'class_id', NEW.class_id,
            'created_at', NOW()
        ),
        'system',
        'help_queues',
        true
    );

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_help_request_channels()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    affected_profile_ids UUID[];
    profile_id UUID;
BEGIN
    -- Pre-create the main help request channel by sending an initial message
    PERFORM realtime.send(
        jsonb_build_object(
            'type', 'channel_created',
            'help_request_id', NEW.id,
            'class_id', NEW.class_id,
            'created_at', NOW()
        ),
        'system',
        'help_request:' || NEW.id,
        true
    );

    -- Pre-create the staff channel for moderation and karma data
    PERFORM realtime.send(
        jsonb_build_object(
            'type', 'channel_created',
            'help_request_id', NEW.id,
            'class_id', NEW.class_id,
            'created_at', NOW()
        ),
        'system',
        'help_request:' || NEW.id || ':staff',
        true
    );

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_help_request_message_notification(p_class_id bigint, p_help_request_id bigint, p_help_queue_id bigint, p_help_queue_name text, p_message_id bigint, p_author_profile_id uuid, p_author_name text, p_message_preview text, p_help_request_creator_profile_id uuid, p_help_request_creator_name text, p_is_private boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  notification_body jsonb;
  target_user_id uuid;
  user_role text;
begin
  -- Build notification body
  notification_body := jsonb_build_object(
    'type', 'help_request_message',
    'help_request_id', p_help_request_id,
    'help_queue_id', p_help_queue_id,
    'help_queue_name', p_help_queue_name,
    'message_id', p_message_id,
    'author_profile_id', p_author_profile_id,
    'author_name', p_author_name,
    'message_preview', p_message_preview,
    'help_request_creator_profile_id', p_help_request_creator_profile_id,
    'help_request_creator_name', p_help_request_creator_name,
    'is_private', p_is_private
  );

  -- Send notifications only to users who are watching this help request
  insert into public.notifications (user_id, class_id, subject, body)
  select 
    hrw.user_id,
    p_class_id,
    jsonb_build_object('text', 'New message in help request'),
    notification_body
  from public.help_request_watchers hrw
  join public.user_roles ur on ur.user_id = hrw.user_id and ur.class_id = p_class_id
  left join public.help_queue_assignments hqa on hqa.ta_profile_id = ur.private_profile_id 
    and hqa.help_queue_id = p_help_queue_id 
    and hqa.is_active = true
  where hrw.help_request_id = p_help_request_id
    and hrw.enabled = true
    and hrw.user_id != p_author_profile_id -- Don't notify the message author
    and (
      -- Always notify instructors and graders who are watching
      ur.role in ('instructor', 'grader')
      -- Always notify the help request creator if they're watching
      or ur.private_profile_id = p_help_request_creator_profile_id
      -- For public requests, notify students who are watching (unless private)
      or (not p_is_private and ur.role = 'student')
      -- Notify TAs who are actively working this queue and watching
      or hqa.id is not null
    );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.create_help_request_notification(p_class_id bigint, p_notification_type text, p_help_request_id bigint, p_help_queue_id bigint, p_help_queue_name text, p_creator_profile_id uuid, p_creator_name text, p_assignee_profile_id uuid DEFAULT NULL::uuid, p_assignee_name text DEFAULT NULL::text, p_status help_request_status DEFAULT NULL::help_request_status, p_request_preview text DEFAULT ''::text, p_is_private boolean DEFAULT false, p_action text DEFAULT 'created'::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  notification_body jsonb;
  target_user_id uuid;
  user_role text;
begin
  -- Build notification body based on type
  if p_notification_type = 'help_request' then
    notification_body := jsonb_build_object(
      'type', 'help_request',
      'action', p_action,
      'help_request_id', p_help_request_id,
      'help_queue_id', p_help_queue_id,
      'help_queue_name', p_help_queue_name,
      'creator_profile_id', p_creator_profile_id,
      'creator_name', p_creator_name,
      'assignee_profile_id', p_assignee_profile_id,
      'assignee_name', p_assignee_name,
      'status', p_status,
      'request_preview', p_request_preview,
      'is_private', p_is_private
    );
  end if;

  -- For 'created' action, notify all eligible users and auto-create watchers
  if p_action = 'created' then
    -- Send notifications to eligible users (not restricted to watchers for creation)
    for target_user_id, user_role in
      select distinct ur.user_id, ur.role
      from public.user_roles ur
      where ur.class_id = p_class_id
        and (
          -- For private requests, only notify instructors, graders, creator, and assignee
          (p_is_private and ur.role in ('instructor', 'grader'))
          or (p_is_private and ur.private_profile_id = p_creator_profile_id)
          or (p_is_private and ur.private_profile_id = p_assignee_profile_id)
          -- For public requests, notify everyone except the creator
          or (not p_is_private and ur.private_profile_id != p_creator_profile_id)
        )
    loop
      insert into public.notifications (user_id, class_id, subject, body)
      values (
        target_user_id,
        p_class_id,
        jsonb_build_object('text', 'Help Request ' || p_action),
        notification_body
      );
    end loop;

    -- Auto-create watcher for the creator (enabled by default)
    insert into public.help_request_watchers (user_id, help_request_id, class_id, enabled)
    select ur.user_id, p_help_request_id, p_class_id, true
    from public.user_roles ur
    where ur.private_profile_id = p_creator_profile_id 
      and ur.class_id = p_class_id
    on conflict (user_id, help_request_id) do nothing;

  else
    -- For other actions (assigned, status_changed), only notify watchers
    insert into public.notifications (user_id, class_id, subject, body)
    select 
      hrw.user_id,
      p_class_id,
      jsonb_build_object('text', 'Help Request ' || p_action),
      notification_body
    from public.help_request_watchers hrw
    join public.user_roles ur on ur.user_id = hrw.user_id and ur.class_id = p_class_id
    where hrw.help_request_id = p_help_request_id
      and hrw.enabled = true
      and (
        -- For private requests, only notify instructors, graders, creator, and assignee
        (p_is_private and ur.role in ('instructor', 'grader'))
        or (p_is_private and ur.private_profile_id = p_creator_profile_id)
        or (p_is_private and ur.private_profile_id = p_assignee_profile_id)
        -- For public requests, notify all watching users
        or not p_is_private
      );
  end if;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.help_request_is_private(p_help_request_id bigint)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
  select hr.is_private
  from public.help_requests hr
  where hr.id = p_help_request_id;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_help_request_message_created()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  help_request_row public.help_requests%ROWTYPE;
  queue_name text;
  author_name text;
  creator_profile_id uuid;
  creator_name text;
  message_preview text;
BEGIN
  -- Get help request details
  SELECT * INTO help_request_row FROM public.help_requests WHERE id = NEW.help_request_id;
  
  -- Get one student from the group to represent the "creator" for the notification
  SELECT profile_id INTO creator_profile_id FROM public.help_request_students WHERE help_request_id = NEW.help_request_id LIMIT 1;
  
  -- Get related data
  SELECT name INTO queue_name FROM public.help_queues WHERE id = help_request_row.help_queue;
  SELECT name INTO author_name FROM public.profiles WHERE id = NEW.author;
  SELECT name INTO creator_name FROM public.profiles WHERE id = creator_profile_id;
  
  -- Create message preview
  message_preview := LEFT(NEW.message, 100);
  IF LENGTH(NEW.message) > 100 THEN
    message_preview := message_preview || '...';
  END IF;
  
  -- Create notification
  PERFORM public.create_help_request_message_notification(
    NEW.class_id,
    NEW.help_request_id,
    help_request_row.help_queue,
    COALESCE(queue_name, 'Unknown Queue'),
    NEW.id,
    NEW.author,
    COALESCE(author_name, 'Unknown User'),
    message_preview,
    creator_profile_id,
    COALESCE(creator_name, 'Unknown User'),
    help_request_row.is_private
  );
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_help_request_student_added()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  student_count int;
  queue_name text;
  creator_name text;
  request_preview text;
  help_request public.help_requests%ROWTYPE;
BEGIN
  -- Check if this is the first student being added to this help request
  SELECT count(*) INTO student_count FROM public.help_request_students WHERE help_request_id = NEW.help_request_id;
  
  IF student_count = 1 THEN
    -- This is the "creation" event from a notification perspective
    SELECT * INTO help_request FROM public.help_requests WHERE id = NEW.help_request_id;
    
    SELECT name INTO queue_name FROM public.help_queues WHERE id = help_request.help_queue;
    SELECT name INTO creator_name FROM public.profiles WHERE id = NEW.profile_id;
    
    request_preview := LEFT(help_request.request, 100);
    IF LENGTH(help_request.request) > 100 THEN
      request_preview := request_preview || '...';
    END IF;
    
    PERFORM public.create_help_request_notification(
      help_request.class_id,
      'help_request',
      help_request.id,
      help_request.help_queue,
      COALESCE(queue_name, 'Unknown Queue'),
      NEW.profile_id, -- The first student is the "creator"
      COALESCE(creator_name, 'Unknown User'),
      NULL,
      NULL,
      help_request.status,
      request_preview,
      help_request.is_private,
      'created'
    );
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_help_request_updated()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  queue_name text;
  creator_profile_id uuid;
  creator_name text;
  assignee_name text;
  request_preview text;
BEGIN
  -- Only proceed if status or assignee changed
  IF OLD.status IS NOT DISTINCT FROM NEW.status AND OLD.assignee IS NOT DISTINCT FROM NEW.assignee THEN
    RETURN NEW;
  END IF;
  
  SELECT name INTO queue_name FROM public.help_queues WHERE id = NEW.help_queue;
  
  -- Get one student from the group to represent the "creator" for the notification
  SELECT profile_id INTO creator_profile_id FROM public.help_request_students WHERE help_request_id = NEW.id LIMIT 1;
  SELECT name INTO creator_name FROM public.profiles WHERE id = creator_profile_id;
  
  request_preview := LEFT(NEW.request, 100);
  IF LENGTH(NEW.request) > 100 THEN
    request_preview := request_preview || '...';
  END IF;
  
  -- Handle assignment changes
  IF OLD.assignee IS DISTINCT FROM NEW.assignee AND NEW.assignee IS NOT NULL THEN
    SELECT name INTO assignee_name FROM public.profiles WHERE id = NEW.assignee;
    
    PERFORM public.create_help_request_notification(
      NEW.class_id, 'help_request', NEW.id, NEW.help_queue,
      COALESCE(queue_name, 'Unknown Queue'), creator_profile_id,
      COALESCE(creator_name, 'Unknown User'), NEW.assignee,
      COALESCE(assignee_name, 'Unknown User'), NEW.status, request_preview,
      NEW.is_private, 'assigned'
    );
  END IF;
  
  -- Handle status changes  
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    IF NEW.assignee IS NOT NULL THEN
      SELECT name INTO assignee_name FROM public.profiles WHERE id = NEW.assignee;
    END IF;
    
    PERFORM public.create_help_request_notification(
      NEW.class_id, 'help_request', NEW.id, NEW.help_queue,
      COALESCE(queue_name, 'Unknown Queue'), creator_profile_id,
      COALESCE(creator_name, 'Unknown User'), NEW.assignee,
      assignee_name, NEW.status, request_preview,
      NEW.is_private, 'status_changed'
    );
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_is_in_help_request(p_help_request_id bigint, p_user_id uuid DEFAULT auth.uid())
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
  select exists (
    select 1
    from public.help_request_students hrs
    where hrs.help_request_id = p_help_request_id
    and hrs.profile_id in (
      select ur.private_profile_id
      from public.user_roles ur
      where ur.user_id = p_user_id
    )
  ) OR exists (
    select 1
    from public.help_requests hr
    join public.user_roles ur on ur.private_profile_id = hr.created_by
    where hr.id = p_help_request_id
    and ur.user_id = p_user_id
  );
$function$
;

CREATE OR REPLACE FUNCTION public.assignment_before_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
   CASE TG_OP
   WHEN 'UPDATE' THEN
      IF OLD.template_repo is not null and OLD.template_repo != NEW.template_repo then
         UPDATE autograder_regression_test SET repository = NEW.template_repo WHERE repository = OLD.template_repo AND autograder_id = NEW.id;
      elseif OLD.template_repo is null AND NEW.template_repo is not null then
         INSERT INTO autograder_regression_test (repository, autograder_id) VALUES (NEW.template_repo, NEW.id);
      elseif OLD.template_repo is not null and NEW.template_repo is null then
         DELETE FROM autograder_regression_test WHERE repository = NEW.template_repo and autograder_id = NEW.id;
      end if;
      RETURN NEW;
   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
END
$function$
;

CREATE OR REPLACE FUNCTION public.authorizeforclass(class__id bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  bind_permissions int;
  jwtRoles public.user_roles;
begin

  -- Fetch user role once and store it to reduce number of calls
  select count(*)
  into bind_permissions
  from public.user_roles as r
  where class_id=class__id and user_id=auth.uid();

  return bind_permissions > 0;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorizeforclassinstructor(class__id bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  bind_permissions int;
  jwtRoles public.user_roles;
begin

  -- Fetch user role once and store it to reduce number of calls
  select count(*)
  into bind_permissions
  from public.user_roles as r
  where class_id=class__id and user_id=auth.uid() and role='instructor';

  return bind_permissions > 0;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorizeforinstructorofstudent(_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  bind_permissions int;
  jwtRoles public.user_roles;
begin

  -- Fetch user role once and store it to reduce number of calls
  select count(*)
  into bind_permissions
  from public.user_roles as ourRole
  inner join public.user_roles as studentRole on ourRole.class_id=studentRole.class_id and studentRole.user_id=_user_id
  where ourRole.user_id=auth.uid() and ourRole.role='instructor';

  return bind_permissions > 0;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorizeforpoll(poll__id bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  poll record;
  roles record;
  jwtRoles public.user_roles;
  release__date timestamp;
begin
  select released_at, class_id into poll FROM public.polls where id=poll__id;

    SELECT COUNT(CASE WHEN role = 'student' THEN 1 END) as is_student, COUNT(CASE WHEN role = 'instructor' THEN 1 END) as is_instructor
    INTO roles
    FROM 
      public.user_roles
    WHERE 
      user_id = auth.uid() AND class_id = poll.class_id;

  if roles.is_instructor then
    return true;
  end if;

  if roles.is_student then
    return poll.released_at is null or poll.released_at <= NOW();
  end if;

  return false;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorizeforpoll(poll__id bigint, class__id bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  roles record;
  jwtRoles public.user_roles;
  release__date timestamp;
begin

    SELECT COUNT(CASE WHEN role = 'student' THEN 1 END) as is_student, COUNT(CASE WHEN role = 'instructor' THEN 1 END) as is_instructor
    INTO roles
    FROM 
      user_roles
    WHERE 
      user_id = auth.uid() AND class_id = class__id;

  if is_instructor then
    return true;
  end if;

  if is_student then
    select release_date into release__date from polls where id=poll__id;
    return release__date is null or release__date <= NOW();
  end if;

  return false;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorizeforprofile(profile_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  bind_permissions int;
  jwtRoles public.user_roles;
begin

  -- Fetch user role once and store it to reduce number of calls
  select count(*)
  into bind_permissions
  from public.user_roles as r
  where (r.public_profile_id=profile_id OR r.private_profile_id=profile_id) and user_id=auth.uid();

  return bind_permissions > 0;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.check_unified_realtime_authorization(topic_text text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
    topic_parts text[];
    topic_type text;
    class_id_text text;
    submission_id_text text;
    profile_id_text text;
    help_request_id_text text;
    help_queue_id_text text;
    class_id_bigint bigint;
    submission_id_bigint bigint;
    profile_id_uuid uuid;
    help_request_id_bigint bigint;
    help_queue_id_bigint bigint;
    is_class_grader boolean;
    is_submission_authorized boolean;
    is_profile_owner boolean;
    channel_type text;
BEGIN
    -- Handle special case for help_queues (global channel)
    IF topic_text = 'help_queues' THEN
        -- Allow authenticated users to subscribe to global help queues channel
        -- Individual queue access will be checked by RLS policies
        RETURN auth.role() = 'authenticated';
    END IF;
    
    -- Handle help_request_ channels (legacy format: help_request_123)
    IF topic_text ~ '^help_request_[0-9]+$' THEN
        -- Extract help request ID from topic (format: help_request_123)
        help_request_id_text := substring(topic_text from '^help_request_([0-9]+)$');
        
        -- Convert to bigint
        BEGIN
            help_request_id_bigint := help_request_id_text::bigint;
        EXCEPTION WHEN OTHERS THEN
            RETURN false;
        END;
        
        -- Use existing help request access function
        RETURN public.can_access_help_request(help_request_id_bigint);
    END IF;

    -- Parse topic to get the first part
    topic_parts := string_to_array(topic_text, ':');
    
    IF array_length(topic_parts, 1) < 1 THEN
        RETURN false;
    END IF;
    
    topic_type := topic_parts[1];
    
    -- Handle gradebook channels
    IF topic_type = 'gradebook' THEN
        RETURN public.check_gradebook_realtime_authorization(topic_text);
    END IF;
    
    -- Handle help_request channels (format: help_request:123 or help_request:123:staff)
    IF topic_type = 'help_request' THEN
        -- Must have at least 2 parts
        IF array_length(topic_parts, 1) < 2 THEN
            RETURN false;
        END IF;
        
        help_request_id_text := topic_parts[2];
        
        -- Convert help_request_id to bigint
        BEGIN
            help_request_id_bigint := help_request_id_text::bigint;
        EXCEPTION WHEN OTHERS THEN
            RETURN false;
        END;
        
        -- Check if this is the staff channel
        IF array_length(topic_parts, 1) = 3 AND topic_parts[3] = 'staff' THEN
            -- Staff channel: check if user is staff or can access help request
            SELECT hr.class_id INTO class_id_bigint
            FROM public.help_requests hr
            WHERE hr.id = help_request_id_bigint;
            
            IF class_id_bigint IS NULL THEN
                RETURN false;
            END IF;
            
            -- Staff can see all moderation data, students can see their own
            RETURN public.authorizeforclassgrader(class_id_bigint) 
                   OR public.can_access_help_request(help_request_id_bigint);
        ELSE
            -- Main help request channel
            RETURN public.can_access_help_request(help_request_id_bigint);
        END IF;
    END IF;
    
    -- Handle help_queue channels (format: help_queue:123)
    IF topic_type = 'help_queue' THEN
        -- Must have at least 2 parts
        IF array_length(topic_parts, 1) < 2 THEN
            RETURN false;
        END IF;
        
        help_queue_id_text := topic_parts[2];
        
        -- Convert help_queue_id to bigint
        BEGIN
            help_queue_id_bigint := help_queue_id_text::bigint;
        EXCEPTION WHEN OTHERS THEN
            RETURN false;
        END;
        
        -- Check access to help queue by checking class access
        SELECT hq.class_id INTO class_id_bigint
        FROM public.help_queues hq
        WHERE hq.id = help_queue_id_bigint;
        
        IF class_id_bigint IS NOT NULL THEN
            RETURN public.authorizeforclass(class_id_bigint);
        ELSE
            RETURN false;
        END IF;
    END IF;
    
    -- Fall back to original authorization logic for class and submission channels
    -- Must have at least 3 parts for these channel types
    IF array_length(topic_parts, 1) < 3 THEN
        RETURN false;
    END IF;
    
    -- Handle class-level channels (for review_assignments, etc.)
    IF topic_type = 'class' THEN
        class_id_text := topic_parts[2];
        channel_type := topic_parts[3];
        
        -- Convert class_id to bigint
        BEGIN
            class_id_bigint := class_id_text::bigint;
        EXCEPTION WHEN OTHERS THEN
            RETURN false;
        END;
        
        -- Handle staff channel
        IF channel_type = 'staff' THEN
            RETURN public.authorizeforclassgrader(class_id_bigint);
        
        -- Handle user channel
        ELSIF channel_type = 'user' THEN
            -- Must have 4 parts for user channel
            IF array_length(topic_parts, 1) != 4 THEN
                RETURN false;
            END IF;
            
            profile_id_text := topic_parts[4];
            
            -- Convert profile_id to uuid
            BEGIN
                profile_id_uuid := profile_id_text::uuid;
            EXCEPTION WHEN OTHERS THEN
                RETURN false;
            END;
            
            -- Check if user is grader/instructor OR is the profile owner
            is_class_grader := public.authorizeforclassgrader(class_id_bigint);
            is_profile_owner := public.authorizeforprofile(profile_id_uuid);
            
            RETURN is_class_grader OR is_profile_owner;
        
        ELSE
            RETURN false;
        END IF;
    
    -- Handle submission-level channels (for submission comments, etc.)
    ELSIF topic_type = 'submission' THEN
        submission_id_text := topic_parts[2];
        channel_type := topic_parts[3];
        
        -- Convert submission_id to bigint
        BEGIN
            submission_id_bigint := submission_id_text::bigint;
        EXCEPTION WHEN OTHERS THEN
            RETURN false;
        END;
        
        -- Handle graders channel
        IF channel_type = 'graders' THEN
            -- Get class_id from submission to check grader authorization
            SELECT s.class_id INTO class_id_bigint
            FROM public.submissions s
            WHERE s.id = submission_id_bigint;
            
            IF class_id_bigint IS NULL THEN
                RETURN false;
            END IF;
            
            RETURN public.authorizeforclassgrader(class_id_bigint);
        
        -- Handle profile_id channel
        ELSIF channel_type = 'profile_id' THEN
            -- Must have 4 parts for profile_id channel
            IF array_length(topic_parts, 1) != 4 THEN
                RETURN false;
            END IF;
            
            profile_id_text := topic_parts[4];
            
            -- Convert profile_id to uuid
            BEGIN
                profile_id_uuid := profile_id_text::uuid;
            EXCEPTION WHEN OTHERS THEN
                RETURN false;
            END;
            
            -- Check if user has access to the submission OR is the profile owner
            is_submission_authorized := public.authorize_for_submission(submission_id_bigint);
            is_profile_owner := public.authorizeforprofile(profile_id_uuid);
            
            -- Also check if user is a grader for the class (for extra access)
            SELECT s.class_id INTO class_id_bigint
            FROM public.submissions s
            WHERE s.id = submission_id_bigint;
            
            IF class_id_bigint IS NOT NULL THEN
                is_class_grader := public.authorizeforclassgrader(class_id_bigint);
            ELSE
                is_class_grader := false;
            END IF;
            
            RETURN is_class_grader OR is_submission_authorized OR is_profile_owner;
        
        ELSE
            RETURN false;
        END IF;
    
    ELSE
        RETURN false;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
 RETURNS jsonb
 LANGUAGE plv8
 STABLE
AS $function$var user_roles;

  // Fetch the current user's user_role from the public user_roles table.
  var result = plv8.execute("select role, class_id,public_profile_id,private_profile_id from public.user_roles where user_id = $1", [event.user_id]);
  // Check if 'claims' exists in the event object; if not, initialize it
  if (!event.claims) {
    event.claims = {};
  }

  //Find ther user's github identity, if one exists
  var ghResult = plv8.execute("select identity_data from identities where provider='github' and user_id=$1",[event.user_id]);
  event.claims.github = ghResult;
  // Update the level in the claims
  event.claims.user_roles = result;
  return event;$function$
;

CREATE OR REPLACE FUNCTION public.discussion_thread_root_patch()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
   CASE TG_OP
   WHEN 'INSERT' THEN
      if NEW.root is null then
         update discussion_threads set root = id where id = NEW.id;
      END if;
      RETURN NULL;
   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
END
$function$
;

CREATE OR REPLACE FUNCTION public.discussion_thread_set_ordinal()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
   CASE TG_OP
   WHEN 'INSERT' THEN
      NEW.ordinal = (select COUNT(*)+1 from discussion_threads where class_id = NEW.class_id);
      RETURN NEW;
   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
END
$function$
;

CREATE OR REPLACE FUNCTION public.generate_anon_name()
 RETURNS text
 LANGUAGE plpgsql
AS $function$declare
adj text;
noun text;
begin

select into noun word from public.name_generation_words where is_noun order by random() limit 1;
select into adj word from public.name_generation_words where is_adjective order by random() limit 1;

return adj || '-' || noun || '-' || (floor(random() * 9999));
end;$function$
;

CREATE OR REPLACE FUNCTION public.get_user_id_by_email(email text)
 RETURNS TABLE(id uuid)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY SELECT au.id FROM auth.users au WHERE au.email = $1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.intval(character varying)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$

SELECT
CASE
    WHEN length(btrim(regexp_replace($1, '[^0-9]', '','g')))>0 THEN btrim(regexp_replace($1, '[^0-9]', '','g'))::integer
    ELSE 0
END AS intval;

$function$
;

CREATE OR REPLACE FUNCTION public.is_allowed_grader_key(graderkey text, class bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
Begin
  RETURN (SELECT EXISTS (SELECT 1
  FROM grader_keys
  WHERE key=graderKey
  AND class_id=class));
End;  
$function$
;

CREATE OR REPLACE FUNCTION public.is_in_class(userid uuid, classid bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
Begin
  RETURN (SELECT EXISTS (SELECT 1
  FROM user_roles
  WHERE user_id=userid
  AND class_id=classid));
End;  
$function$
;

CREATE OR REPLACE FUNCTION public.is_instructor_for_class(_person_id uuid, _class_id integer)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
SELECT EXISTS (
  SELECT 1
  FROM user_roles ur
  WHERE (ur.class_id = _class_id or ur.role='admin')
  AND ur.user_id = _person_id
  AND (ur.role='instructor' or ur.role='grader'));
$function$
;

CREATE OR REPLACE FUNCTION public.is_instructor_for_class(_person_id uuid, classid bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$DECLARE
ret int4;
BEGIN
  SELECT 1
  INTO ret
  FROM user_roles ur
  WHERE (ur.class_id = classid or ur.role='admin')
  AND ur.user_id = _person_id
  AND (ur.role='instructor' or ur.role='grader');
  RETURN ret;
  END;$function$
;

CREATE OR REPLACE FUNCTION public.is_instructor_for_student(_person_id uuid, _student_id uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
SELECT EXISTS (
  SELECT 1
  FROM user_roles instr, user_roles stud
  WHERE (stud.class_id=instr.class_id or instr.role='admin')
  AND stud.user_id= _student_id
  AND instr.user_id = _person_id
  AND (instr.role='instructor' or instr.role='grader'));
$function$
;

CREATE OR REPLACE FUNCTION public.poll_question_answer_ins_del()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
   CASE TG_OP
   WHEN 'INSERT' THEN
      INSERT INTO poll_question_results (poll_question,poll_question_answer,poll) values (NEW.poll_question,NEW.id,NEW.poll);
      RETURN NEW;
   WHEN 'DELETE' THEN
      DELETE FROM poll_question_results where poll_question_answer=OLD.id;
      RETURN OLD; -- must be non-null, NEW is null!
   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
   RETURN NEW;
END
$function$
;

CREATE OR REPLACE FUNCTION public.poll_response_answers_ins_del_upd()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
   CASE TG_OP
   WHEN 'INSERT' THEN
      UPDATE poll_question_results AS r
      SET    count = r.count + 1
      WHERE  r.poll_question_answer = NEW.poll_question_answer;
      RETURN NEW;
   WHEN 'DELETE' THEN
      UPDATE poll_question_results AS r
      SET    count = r.count - 1
      WHERE  r.poll_question_answer = NEW.poll_question_answer;
      RETURN OLD; -- must be non-null, NEW is null!
  WHEN 'UPDATE' then
      UPDATE poll_question_results AS r
      SET    count = r.count + 1
      WHERE  r.poll_question_answer = NEW.poll_question_answer;
      UPDATE poll_question_results AS r
      SET    count = r.count - 1
      WHERE  r.poll_question_answer = OLD.poll_question_answer;
      RETURN NEW;
   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
   RETURN NEW;
END
$function$
;

CREATE OR REPLACE FUNCTION public.remove_github_profile()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$ BEGIN UPDATE public.users set
github_username=null
where user_id=OLD.user_id AND OLD.provider='github';
RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_children_count()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
   CASE TG_OP
   WHEN 'INSERT' THEN
      UPDATE discussion_threads AS t
      SET    children_count = t.children_count + 1
      WHERE  t.id = NEW.root AND NEW.draft = false;
      UPDATE discussion_threads AS t
      SET    children_count = t.children_count + 1
      WHERE  t.id = NEW.parent AND t.id != NEW.root AND NEW.draft=false;
   WHEN 'DELETE' THEN
      UPDATE discussion_threads AS t
      SET    children_count = t.children_count - 1
      WHERE  t.id = OLD.root AND OLD.draft = false AND t.id != OLD.id;
      UPDATE discussion_threads AS t
      SET    children_count = t.children_count - 1
      WHERE  t.id = OLD.parent AND t.id != OLD.root AND OLD.draft=false AND t.id != OLD.id;
      RETURN OLD; -- must be non-null, NEW is null!
  WHEN 'UPDATE' then
       if new.draft = false and old.draft = true then
             UPDATE discussion_threads AS t
            SET    children_count = t.children_count + 1
            WHERE  t.id = NEW.root;
            UPDATE discussion_threads AS t
            SET    children_count = t.children_count + 1
            WHERE  t.id = NEW.parent AND t.id != NEW.root;
       end if;
   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
   RETURN NEW;
END
$function$
;

CREATE OR REPLACE FUNCTION public.update_github_profile()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$ BEGIN UPDATE public.users set
github_username=json_extract_path_text(to_json(NEW.identity_data),'user_name')
where user_id=NEW.user_id;
RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_thread_likes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
   CASE TG_OP
   WHEN 'INSERT' THEN
      UPDATE discussion_threads AS t
      SET    likes_count = t.likes_count + 1
      WHERE  t.id = NEW.discussion_thread;
      RETURN NEW;
   WHEN 'DELETE' THEN
      UPDATE discussion_threads AS t
      SET    likes_count = t.likes_count - 1
      WHERE  t.id = OLD.discussion_thread;
      RETURN OLD;
   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
END
$function$
;

grant delete on table "public"."help_queue_assignments" to "anon";

grant insert on table "public"."help_queue_assignments" to "anon";

grant references on table "public"."help_queue_assignments" to "anon";

grant select on table "public"."help_queue_assignments" to "anon";

grant trigger on table "public"."help_queue_assignments" to "anon";

grant truncate on table "public"."help_queue_assignments" to "anon";

grant update on table "public"."help_queue_assignments" to "anon";

grant delete on table "public"."help_queue_assignments" to "authenticated";

grant insert on table "public"."help_queue_assignments" to "authenticated";

grant references on table "public"."help_queue_assignments" to "authenticated";

grant select on table "public"."help_queue_assignments" to "authenticated";

grant trigger on table "public"."help_queue_assignments" to "authenticated";

grant truncate on table "public"."help_queue_assignments" to "authenticated";

grant update on table "public"."help_queue_assignments" to "authenticated";

grant delete on table "public"."help_queue_assignments" to "service_role";

grant insert on table "public"."help_queue_assignments" to "service_role";

grant references on table "public"."help_queue_assignments" to "service_role";

grant select on table "public"."help_queue_assignments" to "service_role";

grant trigger on table "public"."help_queue_assignments" to "service_role";

grant truncate on table "public"."help_queue_assignments" to "service_role";

grant update on table "public"."help_queue_assignments" to "service_role";

grant delete on table "public"."help_request_feedback" to "anon";

grant insert on table "public"."help_request_feedback" to "anon";

grant references on table "public"."help_request_feedback" to "anon";

grant select on table "public"."help_request_feedback" to "anon";

grant trigger on table "public"."help_request_feedback" to "anon";

grant truncate on table "public"."help_request_feedback" to "anon";

grant update on table "public"."help_request_feedback" to "anon";

grant delete on table "public"."help_request_feedback" to "authenticated";

grant insert on table "public"."help_request_feedback" to "authenticated";

grant references on table "public"."help_request_feedback" to "authenticated";

grant select on table "public"."help_request_feedback" to "authenticated";

grant trigger on table "public"."help_request_feedback" to "authenticated";

grant truncate on table "public"."help_request_feedback" to "authenticated";

grant update on table "public"."help_request_feedback" to "authenticated";

grant delete on table "public"."help_request_feedback" to "service_role";

grant insert on table "public"."help_request_feedback" to "service_role";

grant references on table "public"."help_request_feedback" to "service_role";

grant select on table "public"."help_request_feedback" to "service_role";

grant trigger on table "public"."help_request_feedback" to "service_role";

grant truncate on table "public"."help_request_feedback" to "service_role";

grant update on table "public"."help_request_feedback" to "service_role";

grant delete on table "public"."help_request_file_references" to "anon";

grant insert on table "public"."help_request_file_references" to "anon";

grant references on table "public"."help_request_file_references" to "anon";

grant select on table "public"."help_request_file_references" to "anon";

grant trigger on table "public"."help_request_file_references" to "anon";

grant truncate on table "public"."help_request_file_references" to "anon";

grant update on table "public"."help_request_file_references" to "anon";

grant delete on table "public"."help_request_file_references" to "authenticated";

grant insert on table "public"."help_request_file_references" to "authenticated";

grant references on table "public"."help_request_file_references" to "authenticated";

grant select on table "public"."help_request_file_references" to "authenticated";

grant trigger on table "public"."help_request_file_references" to "authenticated";

grant truncate on table "public"."help_request_file_references" to "authenticated";

grant update on table "public"."help_request_file_references" to "authenticated";

grant delete on table "public"."help_request_file_references" to "service_role";

grant insert on table "public"."help_request_file_references" to "service_role";

grant references on table "public"."help_request_file_references" to "service_role";

grant select on table "public"."help_request_file_references" to "service_role";

grant trigger on table "public"."help_request_file_references" to "service_role";

grant truncate on table "public"."help_request_file_references" to "service_role";

grant update on table "public"."help_request_file_references" to "service_role";

grant delete on table "public"."help_request_message_read_receipts" to "anon";

grant insert on table "public"."help_request_message_read_receipts" to "anon";

grant references on table "public"."help_request_message_read_receipts" to "anon";

grant select on table "public"."help_request_message_read_receipts" to "anon";

grant trigger on table "public"."help_request_message_read_receipts" to "anon";

grant truncate on table "public"."help_request_message_read_receipts" to "anon";

grant update on table "public"."help_request_message_read_receipts" to "anon";

grant delete on table "public"."help_request_message_read_receipts" to "authenticated";

grant insert on table "public"."help_request_message_read_receipts" to "authenticated";

grant references on table "public"."help_request_message_read_receipts" to "authenticated";

grant select on table "public"."help_request_message_read_receipts" to "authenticated";

grant trigger on table "public"."help_request_message_read_receipts" to "authenticated";

grant truncate on table "public"."help_request_message_read_receipts" to "authenticated";

grant update on table "public"."help_request_message_read_receipts" to "authenticated";

grant delete on table "public"."help_request_message_read_receipts" to "service_role";

grant insert on table "public"."help_request_message_read_receipts" to "service_role";

grant references on table "public"."help_request_message_read_receipts" to "service_role";

grant select on table "public"."help_request_message_read_receipts" to "service_role";

grant trigger on table "public"."help_request_message_read_receipts" to "service_role";

grant truncate on table "public"."help_request_message_read_receipts" to "service_role";

grant update on table "public"."help_request_message_read_receipts" to "service_role";

grant delete on table "public"."help_request_moderation" to "anon";

grant insert on table "public"."help_request_moderation" to "anon";

grant references on table "public"."help_request_moderation" to "anon";

grant select on table "public"."help_request_moderation" to "anon";

grant trigger on table "public"."help_request_moderation" to "anon";

grant truncate on table "public"."help_request_moderation" to "anon";

grant update on table "public"."help_request_moderation" to "anon";

grant delete on table "public"."help_request_moderation" to "authenticated";

grant insert on table "public"."help_request_moderation" to "authenticated";

grant references on table "public"."help_request_moderation" to "authenticated";

grant select on table "public"."help_request_moderation" to "authenticated";

grant trigger on table "public"."help_request_moderation" to "authenticated";

grant truncate on table "public"."help_request_moderation" to "authenticated";

grant update on table "public"."help_request_moderation" to "authenticated";

grant delete on table "public"."help_request_moderation" to "service_role";

grant insert on table "public"."help_request_moderation" to "service_role";

grant references on table "public"."help_request_moderation" to "service_role";

grant select on table "public"."help_request_moderation" to "service_role";

grant trigger on table "public"."help_request_moderation" to "service_role";

grant truncate on table "public"."help_request_moderation" to "service_role";

grant update on table "public"."help_request_moderation" to "service_role";

grant delete on table "public"."help_request_students" to "anon";

grant insert on table "public"."help_request_students" to "anon";

grant references on table "public"."help_request_students" to "anon";

grant select on table "public"."help_request_students" to "anon";

grant trigger on table "public"."help_request_students" to "anon";

grant truncate on table "public"."help_request_students" to "anon";

grant update on table "public"."help_request_students" to "anon";

grant delete on table "public"."help_request_students" to "authenticated";

grant insert on table "public"."help_request_students" to "authenticated";

grant references on table "public"."help_request_students" to "authenticated";

grant select on table "public"."help_request_students" to "authenticated";

grant trigger on table "public"."help_request_students" to "authenticated";

grant truncate on table "public"."help_request_students" to "authenticated";

grant update on table "public"."help_request_students" to "authenticated";

grant delete on table "public"."help_request_students" to "service_role";

grant insert on table "public"."help_request_students" to "service_role";

grant references on table "public"."help_request_students" to "service_role";

grant select on table "public"."help_request_students" to "service_role";

grant trigger on table "public"."help_request_students" to "service_role";

grant truncate on table "public"."help_request_students" to "service_role";

grant update on table "public"."help_request_students" to "service_role";

grant delete on table "public"."help_request_templates" to "anon";

grant insert on table "public"."help_request_templates" to "anon";

grant references on table "public"."help_request_templates" to "anon";

grant select on table "public"."help_request_templates" to "anon";

grant trigger on table "public"."help_request_templates" to "anon";

grant truncate on table "public"."help_request_templates" to "anon";

grant update on table "public"."help_request_templates" to "anon";

grant delete on table "public"."help_request_templates" to "authenticated";

grant insert on table "public"."help_request_templates" to "authenticated";

grant references on table "public"."help_request_templates" to "authenticated";

grant select on table "public"."help_request_templates" to "authenticated";

grant trigger on table "public"."help_request_templates" to "authenticated";

grant truncate on table "public"."help_request_templates" to "authenticated";

grant update on table "public"."help_request_templates" to "authenticated";

grant delete on table "public"."help_request_templates" to "service_role";

grant insert on table "public"."help_request_templates" to "service_role";

grant references on table "public"."help_request_templates" to "service_role";

grant select on table "public"."help_request_templates" to "service_role";

grant trigger on table "public"."help_request_templates" to "service_role";

grant truncate on table "public"."help_request_templates" to "service_role";

grant update on table "public"."help_request_templates" to "service_role";

grant delete on table "public"."help_request_watchers" to "anon";

grant insert on table "public"."help_request_watchers" to "anon";

grant references on table "public"."help_request_watchers" to "anon";

grant select on table "public"."help_request_watchers" to "anon";

grant trigger on table "public"."help_request_watchers" to "anon";

grant truncate on table "public"."help_request_watchers" to "anon";

grant update on table "public"."help_request_watchers" to "anon";

grant delete on table "public"."help_request_watchers" to "authenticated";

grant insert on table "public"."help_request_watchers" to "authenticated";

grant references on table "public"."help_request_watchers" to "authenticated";

grant select on table "public"."help_request_watchers" to "authenticated";

grant trigger on table "public"."help_request_watchers" to "authenticated";

grant truncate on table "public"."help_request_watchers" to "authenticated";

grant update on table "public"."help_request_watchers" to "authenticated";

grant delete on table "public"."help_request_watchers" to "service_role";

grant insert on table "public"."help_request_watchers" to "service_role";

grant references on table "public"."help_request_watchers" to "service_role";

grant select on table "public"."help_request_watchers" to "service_role";

grant trigger on table "public"."help_request_watchers" to "service_role";

grant truncate on table "public"."help_request_watchers" to "service_role";

grant update on table "public"."help_request_watchers" to "service_role";

grant delete on table "public"."notification_preferences" to "anon";

grant insert on table "public"."notification_preferences" to "anon";

grant references on table "public"."notification_preferences" to "anon";

grant select on table "public"."notification_preferences" to "anon";

grant trigger on table "public"."notification_preferences" to "anon";

grant truncate on table "public"."notification_preferences" to "anon";

grant update on table "public"."notification_preferences" to "anon";

grant delete on table "public"."notification_preferences" to "authenticated";

grant insert on table "public"."notification_preferences" to "authenticated";

grant references on table "public"."notification_preferences" to "authenticated";

grant select on table "public"."notification_preferences" to "authenticated";

grant trigger on table "public"."notification_preferences" to "authenticated";

grant truncate on table "public"."notification_preferences" to "authenticated";

grant update on table "public"."notification_preferences" to "authenticated";

grant delete on table "public"."notification_preferences" to "service_role";

grant insert on table "public"."notification_preferences" to "service_role";

grant references on table "public"."notification_preferences" to "service_role";

grant select on table "public"."notification_preferences" to "service_role";

grant trigger on table "public"."notification_preferences" to "service_role";

grant truncate on table "public"."notification_preferences" to "service_role";

grant update on table "public"."notification_preferences" to "service_role";

grant delete on table "public"."student_help_activity" to "anon";

grant insert on table "public"."student_help_activity" to "anon";

grant references on table "public"."student_help_activity" to "anon";

grant select on table "public"."student_help_activity" to "anon";

grant trigger on table "public"."student_help_activity" to "anon";

grant truncate on table "public"."student_help_activity" to "anon";

grant update on table "public"."student_help_activity" to "anon";

grant delete on table "public"."student_help_activity" to "authenticated";

grant insert on table "public"."student_help_activity" to "authenticated";

grant references on table "public"."student_help_activity" to "authenticated";

grant select on table "public"."student_help_activity" to "authenticated";

grant trigger on table "public"."student_help_activity" to "authenticated";

grant truncate on table "public"."student_help_activity" to "authenticated";

grant update on table "public"."student_help_activity" to "authenticated";

grant delete on table "public"."student_help_activity" to "service_role";

grant insert on table "public"."student_help_activity" to "service_role";

grant references on table "public"."student_help_activity" to "service_role";

grant select on table "public"."student_help_activity" to "service_role";

grant trigger on table "public"."student_help_activity" to "service_role";

grant truncate on table "public"."student_help_activity" to "service_role";

grant update on table "public"."student_help_activity" to "service_role";

grant delete on table "public"."student_karma_notes" to "anon";

grant insert on table "public"."student_karma_notes" to "anon";

grant references on table "public"."student_karma_notes" to "anon";

grant select on table "public"."student_karma_notes" to "anon";

grant trigger on table "public"."student_karma_notes" to "anon";

grant truncate on table "public"."student_karma_notes" to "anon";

grant update on table "public"."student_karma_notes" to "anon";

grant delete on table "public"."student_karma_notes" to "authenticated";

grant insert on table "public"."student_karma_notes" to "authenticated";

grant references on table "public"."student_karma_notes" to "authenticated";

grant select on table "public"."student_karma_notes" to "authenticated";

grant trigger on table "public"."student_karma_notes" to "authenticated";

grant truncate on table "public"."student_karma_notes" to "authenticated";

grant update on table "public"."student_karma_notes" to "authenticated";

grant delete on table "public"."student_karma_notes" to "service_role";

grant insert on table "public"."student_karma_notes" to "service_role";

grant references on table "public"."student_karma_notes" to "service_role";

grant select on table "public"."student_karma_notes" to "service_role";

grant trigger on table "public"."student_karma_notes" to "service_role";

grant truncate on table "public"."student_karma_notes" to "service_role";

grant update on table "public"."student_karma_notes" to "service_role";

create policy "Instructors and graders can CRUD help queue assignments"
on "public"."help_queue_assignments"
as permissive
for all
to authenticated
using (authorizeforclassgrader(class_id))
with check (authorizeforclassgrader(class_id));


create policy "Users can view queue assignments for their classes"
on "public"."help_queue_assignments"
as permissive
for select
to authenticated
using (authorizeforclass(class_id));


create policy "Instructors can view"
on "public"."help_request_feedback"
as permissive
for select
to authenticated
using (authorizeforclassinstructor(class_id));


create policy "Students associated with the help request can create"
on "public"."help_request_feedback"
as permissive
for insert
to authenticated
with check (user_is_in_help_request(help_request_id));


create policy "students can view the feedback they submitted"
on "public"."help_request_feedback"
as permissive
for select
to authenticated
using (authorizeforprofile(student_profile_id));


create policy "Users can CRUD file references in their classes"
on "public"."help_request_file_references"
as permissive
for all
to authenticated
using (authorizeforclass(class_id))
with check (authorizeforclass(class_id));


create policy "Users can create read receipts for accessible help requests via"
on "public"."help_request_message_read_receipts"
as permissive
for insert
to authenticated
with check (can_access_help_request(help_request_id));


create policy "Users can view read receipts for accessible help requests via h"
on "public"."help_request_message_read_receipts"
as permissive
for select
to authenticated
using (can_access_help_request(help_request_id));


create policy "Users can view messages in help requests they can access"
on "public"."help_request_messages"
as permissive
for select
to authenticated
using (can_access_help_request(help_request_id));


create policy "Graders can create moderation records"
on "public"."help_request_moderation"
as permissive
for insert
to authenticated
with check ((authorizeforclassgrader(class_id) AND (( SELECT auth.uid() AS uid) = moderator_profile_id)));


create policy "Graders can view moderation records and students can view their"
on "public"."help_request_moderation"
as permissive
for select
to authenticated
using ((authorizeforclassgrader(class_id) OR (student_profile_id IN ( SELECT user_roles.private_profile_id
   FROM user_roles
  WHERE (user_roles.user_id = auth.uid())))));


create policy "Instructors can CRUD moderation records"
on "public"."help_request_moderation"
as permissive
for all
to authenticated
using (authorizeforclassinstructor(class_id))
with check (authorizeforclassinstructor(class_id));


create policy "Instructors can delete moderation records"
on "public"."help_request_moderation"
as permissive
for delete
to authenticated
using (authorizeforclassinstructor(class_id));


create policy "Staff can update help request memberships"
on "public"."help_request_students"
as permissive
for update
to authenticated
using (authorizeforclassgrader(class_id))
with check (authorizeforclassgrader(class_id));


create policy "Students can add students to help requests they have access to"
on "public"."help_request_students"
as permissive
for insert
to authenticated
with check ((authorizeforclassgrader(class_id) OR ( SELECT authorizeforprofile(hr.created_by) AS authorizeforprofile
   FROM help_requests hr
  WHERE (hr.id = help_request_students.help_request_id)) OR (EXISTS ( SELECT 1
   FROM (help_request_students existing_hrs
     JOIN user_roles ur ON ((ur.private_profile_id = existing_hrs.profile_id)))
  WHERE ((existing_hrs.help_request_id = help_request_students.help_request_id) AND (ur.user_id = auth.uid()) AND authorizeforprofile(existing_hrs.profile_id))))));


create policy "Students can remove students from help requests they're part of"
on "public"."help_request_students"
as permissive
for delete
to authenticated
using ((authorizeforclassgrader(class_id) OR authorizeforprofile(profile_id) OR (authorizeforclass(class_id) AND (EXISTS ( SELECT 1
   FROM (help_request_students existing_association
     JOIN user_roles ur ON ((ur.private_profile_id = existing_association.profile_id)))
  WHERE ((existing_association.help_request_id = help_request_students.help_request_id) AND (ur.user_id = auth.uid()) AND (ur.class_id = help_request_students.class_id)))))));


create policy "Students can view help request members"
on "public"."help_request_students"
as permissive
for select
to authenticated
using ((authorizeforclassgrader(class_id) OR ((NOT help_request_is_private(help_request_id)) AND authorizeforclass(class_id)) OR (help_request_is_private(help_request_id) AND user_is_in_help_request(help_request_id))));


create policy "Instructors can CRUD templates"
on "public"."help_request_templates"
as permissive
for all
to authenticated
using (authorizeforclassinstructor(class_id))
with check (authorizeforclassinstructor(class_id));


create policy "Users can view templates for their classes"
on "public"."help_request_templates"
as permissive
for select
to authenticated
using (authorizeforclass(class_id));


create policy "Users can delete their own help request watchers"
on "public"."help_request_watchers"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can insert their own help request watchers"
on "public"."help_request_watchers"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can select their own help request watchers"
on "public"."help_request_watchers"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can update their own help request watchers"
on "public"."help_request_watchers"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Staff can delete help requests in their class"
on "public"."help_requests"
as permissive
for delete
to authenticated
using (authorizeforclassgrader(class_id));


create policy "Students can create help requests in their class"
on "public"."help_requests"
as permissive
for insert
to authenticated
with check ((authorizeforclass(class_id) AND (assignee IS NULL)));


create policy "Students can update their own help requests"
on "public"."help_requests"
as permissive
for update
to authenticated
using ((authorizeforclassgrader(class_id) OR user_is_in_help_request(id)))
with check ((authorizeforclassgrader(class_id) OR user_is_in_help_request(id)));


create policy "Students can view help requests in their class with creator acc"
on "public"."help_requests"
as permissive
for select
to authenticated
using ((authorizeforclassgrader(class_id) OR ((NOT is_private) AND authorizeforclass(class_id)) OR (is_private AND authorizeforprofile(assignee)) OR (is_private AND user_is_in_help_request(id)) OR (is_private AND authorizeforprofile(created_by))));


create policy "Users can manage their own preferences"
on "public"."notification_preferences"
as permissive
for all
to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "Instructors can CRUD activity records"
on "public"."student_help_activity"
as permissive
for all
to authenticated
using (authorizeforclassinstructor(class_id))
with check (authorizeforclassinstructor(class_id));


create policy "System can create activity records"
on "public"."student_help_activity"
as permissive
for insert
to authenticated
with check (authorizeforclass(class_id));


create policy "Users can view activity for their classes and own activity"
on "public"."student_help_activity"
as permissive
for select
to authenticated
using ((authorizeforclass(class_id) OR (( SELECT auth.uid() AS uid) = student_profile_id)));


create policy "Instructors and graders can CRUD karma notes"
on "public"."student_karma_notes"
as permissive
for all
to authenticated
using (authorizeforclassgrader(class_id))
with check (authorizeforclassgrader(class_id));


create policy "Everyone in the class can view class tags"
on "public"."tags"
as permissive
for select
to authenticated
using ((authorizeforclass(class_id) AND (visible OR (auth.uid() = creator_id))));


create policy "graders and instructors can delete class tags"
on "public"."tags"
as permissive
for delete
to authenticated
using (((authorizeforclassgrader(class_id) OR authorizeforclassinstructor(class_id)) AND (visible OR (auth.uid() = creator_id))));


create policy "graders and instructors can insert to class tags"
on "public"."tags"
as permissive
for insert
to authenticated
with check (((authorizeforclassgrader(class_id) OR authorizeforclassinstructor(class_id)) AND (visible OR (auth.uid() = creator_id))));


create policy "graders and instructors can update class tags"
on "public"."tags"
as permissive
for update
to authenticated
using (((authorizeforclassgrader(class_id) OR authorizeforclassinstructor(class_id)) AND (visible OR (auth.uid() = creator_id))));


CREATE TRIGGER broadcast_help_queue_assignments_change AFTER INSERT OR DELETE OR UPDATE ON public.help_queue_assignments FOR EACH ROW EXECUTE FUNCTION broadcast_help_queue_data_change();

CREATE TRIGGER broadcast_help_queues_change AFTER INSERT OR DELETE OR UPDATE ON public.help_queues FOR EACH ROW EXECUTE FUNCTION broadcast_help_queue_data_change();

CREATE TRIGGER create_help_queue_channels_trigger AFTER INSERT ON public.help_queues FOR EACH ROW EXECUTE FUNCTION create_help_queue_channels();

CREATE TRIGGER broadcast_help_request_feedback_change AFTER INSERT OR DELETE OR UPDATE ON public.help_request_feedback FOR EACH ROW EXECUTE FUNCTION broadcast_help_request_data_change();

CREATE TRIGGER broadcast_help_request_file_references_change AFTER INSERT OR DELETE OR UPDATE ON public.help_request_file_references FOR EACH ROW EXECUTE FUNCTION broadcast_help_request_data_change();

CREATE TRIGGER broadcast_help_request_message_read_receipts_change AFTER INSERT OR DELETE OR UPDATE ON public.help_request_message_read_receipts FOR EACH ROW EXECUTE FUNCTION broadcast_help_request_data_change();

CREATE TRIGGER broadcast_help_request_messages_change AFTER INSERT OR DELETE OR UPDATE ON public.help_request_messages FOR EACH ROW EXECUTE FUNCTION broadcast_help_request_data_change();

CREATE TRIGGER help_request_message_created_trigger AFTER INSERT ON public.help_request_messages FOR EACH ROW EXECUTE FUNCTION trigger_help_request_message_created();

CREATE TRIGGER broadcast_help_request_moderation_change AFTER INSERT OR DELETE OR UPDATE ON public.help_request_moderation FOR EACH ROW EXECUTE FUNCTION broadcast_help_request_staff_data_change();

CREATE TRIGGER broadcast_help_request_students_change AFTER INSERT OR DELETE OR UPDATE ON public.help_request_students FOR EACH ROW EXECUTE FUNCTION broadcast_help_request_data_change();

CREATE TRIGGER help_request_student_added_trigger AFTER INSERT ON public.help_request_students FOR EACH ROW EXECUTE FUNCTION trigger_help_request_student_added();

CREATE TRIGGER broadcast_help_request_templates_change AFTER INSERT OR DELETE OR UPDATE ON public.help_request_templates FOR EACH ROW EXECUTE FUNCTION broadcast_help_request_staff_data_change();

CREATE TRIGGER broadcast_help_requests_change AFTER INSERT OR DELETE OR UPDATE ON public.help_requests FOR EACH ROW EXECUTE FUNCTION broadcast_help_request_data_change();

CREATE TRIGGER broadcast_help_requests_to_queue_change AFTER INSERT OR DELETE OR UPDATE ON public.help_requests FOR EACH ROW EXECUTE FUNCTION broadcast_help_queue_data_change();

CREATE TRIGGER create_help_request_channels_trigger AFTER INSERT ON public.help_requests FOR EACH ROW EXECUTE FUNCTION create_help_request_channels();

CREATE TRIGGER help_request_updated_trigger AFTER UPDATE ON public.help_requests FOR EACH ROW EXECUTE FUNCTION trigger_help_request_updated();

CREATE TRIGGER broadcast_student_help_activity_change AFTER INSERT OR DELETE OR UPDATE ON public.student_help_activity FOR EACH ROW EXECUTE FUNCTION broadcast_help_request_data_change();

CREATE TRIGGER broadcast_student_karma_notes_change AFTER INSERT OR DELETE OR UPDATE ON public.student_karma_notes FOR EACH ROW EXECUTE FUNCTION broadcast_help_request_staff_data_change();


