CREATE TABLE IF NOT EXISTS "public"."emails" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "subject" text not null,
    "body" text not null,
    "class_id" bigint not null
);

CREATE TABLE IF NOT EXISTS "public"."email_recipients" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "email_id" bigint not null,
    "class_id" bigint not null
);

ALTER TABLE "public"."emails" 
    ADD CONSTRAINT "emails_pkey" PRIMARY KEY ("id");

ALTER TABLE "public"."email_recipients" 
    ADD CONSTRAINT "email_recipients_item_pkey" PRIMARY KEY ("id");

ALTER TABLE "public"."emails" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."email_recipients" ENABLE ROW LEVEL SECURITY;

create policy "Instructors can view emails"
on "public"."emails"
as permissive
for select
to authenticated
using( authorizeforclassinstructor(class_id));

create policy "Instructors can create emails"
on "public"."emails"
as permissive
for insert
to authenticated
with check (authorizeforclassinstructor(class_id));

create policy "Instructors can update emails"
on "public"."emails"
as permissive
for update
to authenticated
using( authorizeforclassinstructor(class_id));

create policy "Instructors can delete emails"
on "public"."emails"
as permissive
for delete
to authenticated
using (authorizeforclassinstructor(class_id));

create policy "Instructors can view email_recipients"
on "public"."email_recipients"
as permissive
for select
to authenticated
using( authorizeforclassinstructor(class_id));

create policy "Instructors can create email_recipients"
on "public"."email_recipients"
as permissive
for insert
to authenticated
with check (authorizeforclassinstructor(class_id));

create policy "Instructors can update email_recipients"
on "public"."email_recipients"
as permissive
for update
to authenticated
using( authorizeforclassinstructor(class_id));

create policy "Instructors can delete email_recipients"
on "public"."email_recipients"
as permissive
for delete
to authenticated
using (authorizeforclassinstructor(class_id));

CREATE OR REPLACE FUNCTION "public"."email_notifications"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
   email public.emails%ROWTYPE;
   body_jsonb jsonb;
   subject_jsonb jsonb;
BEGIN
   CASE TG_OP
   WHEN 'INSERT' THEN
      SELECT * FROM public.emails WHERE id = NEW.email_id INTO email;

      -- Safe conversion to JSONB
      BEGIN
         -- If email.body is already valid JSON, convert it
         body_jsonb := email.body::jsonb;
         subject_jsonb := email.subject::jsonb;
      EXCEPTION
         WHEN OTHERS THEN
            -- If not valid JSON, wrap it as a simple JSON string
            body_jsonb := to_jsonb(email.body);
            subject_jsonb := to_jsonb(email.subject);
      END;

      INSERT INTO notifications (class_id, subject, body, style, user_id) VALUES 
        (email.class_id, subject_jsonb, body_jsonb, 'email', NEW.user_id);

   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
   RETURN NEW;
END
$$;

ALTER FUNCTION "public"."email_notifications"() OWNER TO "postgres";

CREATE OR REPLACE TRIGGER "email_notifications" AFTER INSERT ON "public"."email_recipients" FOR EACH ROW EXECUTE FUNCTION "public"."email_notifications"();
