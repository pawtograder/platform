SELECT pgmq.create('gradebook_column_recalculate');

grant insert on table "pgmq"."a_gradebook_column_recalculate" to "service_role";
grant select on table "pgmq"."a_gradebook_column_recalculate" to "service_role";
grant delete on table "pgmq"."q_gradebook_column_recalculate" to "service_role";
grant insert on table "pgmq"."q_gradebook_column_recalculate" to "service_role";
grant select on table "pgmq"."q_gradebook_column_recalculate" to "service_role";
grant update on table "pgmq"."q_gradebook_column_recalculate" to "service_role";
grant delete on table "pgmq"."a_gradebook_column_recalculate" to "service_role";
grant references on table "pgmq"."a_gradebook_column_recalculate" to "service_role";
grant trigger on table "pgmq"."a_gradebook_column_recalculate" to "service_role";
grant truncate on table "pgmq"."a_gradebook_column_recalculate" to "service_role";
grant update on table "pgmq"."a_gradebook_column_recalculate" to "service_role";
grant delete on table "pgmq"."meta" to "service_role";
grant insert on table "pgmq"."meta" to "service_role";
grant references on table "pgmq"."meta" to "service_role";
grant select on table "pgmq"."meta" to "service_role";
grant trigger on table "pgmq"."meta" to "service_role";
grant truncate on table "pgmq"."meta" to "service_role";
grant update on table "pgmq"."meta" to "service_role";
grant references on table "pgmq"."q_gradebook_column_recalculate" to "service_role";
grant trigger on table "pgmq"."q_gradebook_column_recalculate" to "service_role";
grant truncate on table "pgmq"."q_gradebook_column_recalculate" to "service_role";
alter table "pgmq"."a_gradebook_column_recalculate" enable row level security;
alter table "pgmq"."q_gradebook_column_recalculate" enable row level security;

grant usage, select, update
on all sequences in schema pgmq
to anon, authenticated, service_role;

alter default privileges in schema pgmq
grant usage, select, update
on sequences
to anon, authenticated, service_role;

grant all on function pgmq.pop(text) to "service_role";
grant all on function pgmq.send(text, jsonb, integer) to "service_role";
grant all on function pgmq.send_batch(text, jsonb[], integer) to "service_role";


grant all on function pgmq_public.pop(text) to "service_role";
grant all on function pgmq_public.read(text, integer, integer) to "service_role";
grant all on function pgmq_public.send(text, jsonb, integer) to "service_role";
grant all on function pgmq_public.send_batch(text, jsonb[], integer) to "service_role";

grant all on function pgmq.pop(text) to "service_role";
grant all on function pgmq.send(text, jsonb, integer) to "service_role";
grant all on function pgmq.send_batch(text, jsonb[], integer) to "service_role";


grant all on function pgmq_public.pop(text) to "service_role";
grant all on function pgmq_public.read(text, integer, integer) to "service_role";
grant all on function pgmq_public.send(text, jsonb, integer) to "service_role";
grant all on function pgmq_public.send_batch(text, jsonb[], integer) to "service_role";

-- For the service role, we want full access
-- Grant permissions on existing tables
grant all privileges on all tables in schema pgmq to postgres, service_role;

-- Ensure service_role has permissions on future tables
alter default privileges in schema pgmq grant all privileges on tables to postgres, service_role;

grant usage on schema pgmq to postgres, anon, authenticated, service_role;

-- For the service role, we want full access
-- Grant permissions on existing tables
grant all privileges on all tables in schema pgmq_public to postgres, service_role;

-- Ensure service_role has permissions on future tables
alter default privileges in schema pgmq_public grant all privileges on tables to postgres, service_role;

grant usage on schema pgmq_public to postgres, service_role;


-- Test with:
-- SELECT public.call_edge_function_internal('/functions/v1/gradebook-column-recalculate', 'POST')
create table "public"."gradebook_column_students" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "class_id" bigint not null,
    "gradebook_column_id" bigint not null,
    "gradebook_id" bigint not null,
    "is_droppable" boolean not null default true,
    "is_excused" boolean not null default false,
    "is_missing" boolean not null default true,
    "released" boolean not null default false,
    "score" numeric,
    "score_override" numeric,
    "score_override_note" text,
    "student_id" uuid not null default gen_random_uuid()
);

alter publication "supabase_realtime" add table "public"."gradebook_column_students";


alter table "public"."gradebook_column_students" enable row level security;

create table "public"."gradebook_columns" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "class_id" bigint not null,
    "name" text not null,
    "description" text,
    "dependencies" jsonb,
    "gradebook_id" bigint not null,
    "max_score" numeric,
    "released" boolean not null default false,
    "render_expression" text,
    "score_expression" text,
    "show_max_score" boolean not null default true,
    "slug" text not null,
    "sort_order" integer 
);

-- Function to handle auto-calculation of sort_order when null
CREATE OR REPLACE FUNCTION public.handle_gradebook_column_sort_order()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    max_sort_order integer;
BEGIN
    -- If sort_order is null, place it at the end
    IF NEW.sort_order IS NULL THEN
        SELECT COALESCE(MAX(sort_order), -1) + 1
        INTO max_sort_order
        FROM public.gradebook_columns
        WHERE gradebook_id = NEW.gradebook_id;
        
        NEW.sort_order := max_sort_order;
    ELSE
        -- If sort_order is provided, shift existing columns right
        UPDATE public.gradebook_columns
        SET sort_order = sort_order + 1
        WHERE gradebook_id = NEW.gradebook_id
        AND sort_order >= NEW.sort_order
        AND id != NEW.id;
    END IF;
    
    RETURN NEW;
END;
$function$;

-- Create trigger for handling sort_order
CREATE TRIGGER trigger_handle_gradebook_column_sort_order
BEFORE INSERT OR UPDATE OF sort_order ON public.gradebook_columns
FOR EACH ROW
EXECUTE FUNCTION public.handle_gradebook_column_sort_order();


alter table "public"."gradebook_columns" enable row level security;
alter publication "supabase_realtime" add table "public"."gradebook_columns";

create table "public"."gradebooks" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "class_id" bigint not null,
    "name" text not null,
    "description" text,
    "final_grade_column" bigint
);


alter table "public"."gradebooks" enable row level security;

alter table "public"."classes" add column "gradebook_id" bigint;

CREATE UNIQUE INDEX gradebook_column_students_pkey ON public.gradebook_column_students USING btree (id);

CREATE UNIQUE INDEX gradebook_columns_pkey ON public.gradebook_columns USING btree (id);

CREATE UNIQUE INDEX gradebooks_pkey ON public.gradebooks USING btree (id);

alter table "public"."gradebook_column_students" add constraint "gradebook_column_students_pkey" PRIMARY KEY using index "gradebook_column_students_pkey";

alter table "public"."gradebook_columns" add constraint "gradebook_columns_pkey" PRIMARY KEY using index "gradebook_columns_pkey";

alter table "public"."gradebooks" add constraint "gradebooks_pkey" PRIMARY KEY using index "gradebooks_pkey";

alter table "public"."classes" add constraint "classes_gradebook_id_fkey" FOREIGN KEY (gradebook_id) REFERENCES gradebooks(id) not valid;

alter table "public"."classes" validate constraint "classes_gradebook_id_fkey";

alter table "public"."gradebook_column_students" add constraint "gradebook_column_students_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) not valid;

alter table "public"."gradebook_column_students" validate constraint "gradebook_column_students_class_id_fkey";

alter table "public"."gradebook_column_students" add constraint "gradebook_column_students_gradebook_column_id_fkey" FOREIGN KEY (gradebook_column_id) REFERENCES gradebook_columns(id) not valid;

alter table "public"."gradebook_column_students" validate constraint "gradebook_column_students_gradebook_column_id_fkey";

alter table "public"."gradebook_column_students" add constraint "gradebook_column_students_student_id_fkey" FOREIGN KEY (student_id) REFERENCES profiles(id) not valid;

alter table "public"."gradebook_column_students" validate constraint "gradebook_column_students_student_id_fkey";

alter table "public"."gradebook_column_students" add constraint "gradebook_column_students_student_id_fkey1" FOREIGN KEY (student_id) REFERENCES user_roles(private_profile_id) not valid;

alter table "public"."gradebook_column_students" validate constraint "gradebook_column_students_student_id_fkey1";

alter table "public"."gradebook_columns" add constraint "gradebook_columns_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) not valid;

alter table "public"."gradebook_columns" validate constraint "gradebook_columns_class_id_fkey";

alter table "public"."gradebook_columns" add constraint "gradebook_columns_gradebook_id_fkey" FOREIGN KEY (gradebook_id) REFERENCES gradebooks(id) not valid;

alter table "public"."gradebook_columns" validate constraint "gradebook_columns_gradebook_id_fkey";

alter table "public"."gradebooks" add constraint "gradebooks_class_id_fkey" FOREIGN KEY (class_id) REFERENCES classes(id) not valid;

alter table "public"."gradebooks" validate constraint "gradebooks_class_id_fkey";

alter table "public"."gradebooks" add constraint "gradebooks_final_grade_column_fkey" FOREIGN KEY (final_grade_column) REFERENCES gradebook_columns(id) not valid;

alter table "public"."gradebooks" validate constraint "gradebooks_final_grade_column_fkey";

set check_function_bodies = off;

-- Set up edge function hooks
-- https://stackoverflow.com/questions/78900191/manage-edge-functions-in-a-multi-environment-development-setup-using-webhooks-on/78900192#78900192
DO $$
BEGIN
  PERFORM vault.create_secret(
    'http://host.docker.internal:54321', 
    'supabase_project_url', 
    'URL to be used for calling edge functions, this is set here because we want to develop edge functions with webhohks from database triggers in multiple environments');
EXCEPTION
  WHEN unique_violation THEN
    RAISE WARNING 'Secret "supabase_project_url" already exists, skipping creation';
END $$;

DO $$
BEGIN
  PERFORM vault.create_secret(
    'some-secret-value',
    'edge-function-secret', 
    'Secret value for calling edge functions, this is set here because we want to develop edge functions with webhohks from database triggers in multiple environments');
EXCEPTION
  WHEN unique_violation THEN
    RAISE WARNING 'Secret "edge-function-secret" already exists, skipping creation';
END $$;

CREATE OR REPLACE FUNCTION public.call_edge_function_internal(
  url_path text,
  method text,
  headers jsonb DEFAULT '{}'::jsonb,
  params jsonb DEFAULT '{}'::jsonb,
  timeout_ms integer DEFAULT 1000,
  old_record jsonb DEFAULT NULL,
  new_record jsonb DEFAULT NULL,
  op text DEFAULT NULL,
  table_name text DEFAULT NULL,
  schema_name text DEFAULT NULL
) RETURNS void
LANGUAGE plpgsql
SECURITY INVOKER
AS $function$
  DECLARE
    request_id bigint;
    payload jsonb;
    supabase_project_url text;
    full_url text;
    edge_function_secret text;
    merged_headers jsonb;
  BEGIN
    IF url_path IS NULL OR url_path = 'null' THEN
      RAISE EXCEPTION 'url_path argument is missing';
    END IF;

    -- Retrieve the base URL from the Vault
    SELECT decrypted_secret INTO supabase_project_url 
    FROM vault.decrypted_secrets 
    WHERE name = 'supabase_project_url';

    IF supabase_project_url IS NULL OR supabase_project_url = 'null' THEN
      RAISE EXCEPTION 'supabase_project_url secret is missing or invalid';
    END IF;

    full_url := supabase_project_url || url_path;

    IF method IS NULL OR method = 'null' THEN
      RAISE EXCEPTION 'method argument is missing';
    END IF;

    -- Retrieve the edge function secret from the Vault
    SELECT decrypted_secret INTO edge_function_secret
    FROM vault.decrypted_secrets
    WHERE name = 'edge-function-secret';

    IF edge_function_secret IS NULL OR edge_function_secret = 'null' THEN
      RAISE EXCEPTION 'edge-function-secret is missing or invalid';
    END IF;

    -- Merge the secret into the headers
    merged_headers := headers || jsonb_build_object('x-edge-function-secret', edge_function_secret);

    IF method = 'GET' THEN
      SELECT http_get INTO request_id FROM net.http_get(
        full_url,
        params,
        merged_headers,
        timeout_ms
      );
    ELSIF method = 'POST' THEN
      payload = jsonb_build_object(
        'old_record', old_record,
        'record', new_record,
        'type', op,
        'table', table_name,
        'schema', schema_name
      );
      SELECT http_post INTO request_id FROM net.http_post(
        full_url,
        payload,
        params,
        merged_headers,
        timeout_ms
      );
    ELSE
      RAISE EXCEPTION 'method argument % is invalid', method;
    END IF;
  END;
$function$;

CREATE OR REPLACE FUNCTION public.gradebook_column_student_recalculate_dependents()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    messages jsonb[];
BEGIN

    -- Build an array of messages for all dependent columns
    SELECT array_agg(
        jsonb_build_object(
            'gradebook_column_id', id,
            'student_id', NEW.student_id
        )
    )
    INTO messages
    FROM public.gradebook_columns
    WHERE dependencies->'gradebook_columns' @> to_jsonb(ARRAY[NEW.gradebook_column_id]::bigint[]);

    -- Send all messages in a single batch if there are any
    IF messages IS NOT NULL THEN
        PERFORM pgmq_public.send_batch(
            queue_name := 'gradebook_column_recalculate',
            messages := messages
        );
        PERFORM public.call_edge_function_internal(
        '/functions/v1/gradebook-column-recalculate', 
        'POST', 
        '{"Content-type":"application/json","x-supabase-webhook-source":"gradebook_column_recalculate"}', 
        '{}', 
        5000,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_gradebook_column_students_for_new_column()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.gradebook_column_students (
    class_id,
    gradebook_id,
    gradebook_column_id,
    student_id,
    is_droppable,
    is_excused,
    is_missing,
    released
  )
  SELECT
    NEW.class_id,
    NEW.gradebook_id,
    NEW.id,
    ur.private_profile_id,           
    FALSE,          
    FALSE,
    FALSE,
    FALSE
  FROM public.user_roles ur
  WHERE ur.class_id = NEW.class_id AND ur.role = 'student';
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_gradebook_column_students_for_new_student()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Only act if the role is 'student'
  IF (NEW.role = 'student') THEN
    -- Only insert if this is a new student (not already present in gradebook_column_students for this class)
    INSERT INTO public.gradebook_column_students (
      class_id,
      gradebook_id,
      gradebook_column_id,
      student_id,
      is_droppable,
      is_excused,
      is_missing,
      released
    )
    SELECT
      gc.class_id,
      gc.gradebook_id,
      gc.id,
      NEW.private_profile_id,
      FALSE, FALSE, FALSE, FALSE
    FROM public.gradebook_columns gc
    WHERE gc.class_id = NEW.class_id
      AND NOT EXISTS (
        SELECT 1 FROM public.gradebook_column_students gcs
        WHERE gcs.gradebook_column_id = gc.id
          AND gcs.student_id = NEW.private_profile_id
      );
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.submission_review_recalculate_dependent_columns()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    assignment_id bigint;
    dependent_column RECORD;
    student_id uuid;
    group_id bigint;
    messages jsonb[];
BEGIN

    IF TG_OP = 'UPDATE' AND NEW.total_score = OLD.total_score AND NEW.released = OLD.released THEN
        RETURN NEW;
    END IF;

    -- 1. Find the assignment, profile, and group for this submission review
    SELECT submissions.assignment_id, submissions.profile_id, submissions.assignment_group_id
      INTO assignment_id, student_id, group_id
      FROM public.submissions
     WHERE id = NEW.submission_id;

    -- 2. For each gradebook_column that depends on this assignment
    FOR dependent_column IN
        SELECT id
        FROM public.gradebook_columns
        WHERE dependencies->'assignments' @> to_jsonb(ARRAY[assignment_id]::bigint[])
    LOOP
        IF student_id IS NOT NULL THEN
            -- Individual submission: add one message
            messages := array_append(
                messages,
                jsonb_build_object(
                    'gradebook_column_id', dependent_column.id,
                    'student_id', student_id
                )
            );
        ELSIF group_id IS NOT NULL THEN
            -- Group submission: add a message for each student in the group
            messages := messages || (
                SELECT array_agg(
                    jsonb_build_object(
                        'gradebook_column_id', dependent_column.id,
                        'student_id', agm.profile_id
                    )
                )
                FROM public.assignment_groups_members agm
                WHERE agm.assignment_group_id = group_id
            );
        END IF;
    END LOOP;

    -- 3. Send all messages in a single batch if there are any
    IF messages IS NOT NULL THEN
        PERFORM pgmq_public.send_batch(
            queue_name := 'gradebook_column_recalculate',
            messages := messages
        );
        PERFORM public.call_edge_function_internal(
                '/functions/v1/gradebook-column-recalculate', 
                'POST', 
                '{"Content-type":"application/json","x-supabase-webhook-source":"gradebook_column_recalculate"}', 
                '{}', 
                5000,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
            );
    END IF;

    RETURN NEW;
END;
$function$
;

grant delete on table "public"."gradebook_column_students" to "anon";

grant insert on table "public"."gradebook_column_students" to "anon";

grant references on table "public"."gradebook_column_students" to "anon";

grant select on table "public"."gradebook_column_students" to "anon";

grant trigger on table "public"."gradebook_column_students" to "anon";

grant truncate on table "public"."gradebook_column_students" to "anon";

grant update on table "public"."gradebook_column_students" to "anon";

grant delete on table "public"."gradebook_column_students" to "authenticated";

grant insert on table "public"."gradebook_column_students" to "authenticated";

grant references on table "public"."gradebook_column_students" to "authenticated";

grant select on table "public"."gradebook_column_students" to "authenticated";

grant trigger on table "public"."gradebook_column_students" to "authenticated";

grant truncate on table "public"."gradebook_column_students" to "authenticated";

grant update on table "public"."gradebook_column_students" to "authenticated";

grant delete on table "public"."gradebook_column_students" to "service_role";

grant insert on table "public"."gradebook_column_students" to "service_role";

grant references on table "public"."gradebook_column_students" to "service_role";

grant select on table "public"."gradebook_column_students" to "service_role";

grant trigger on table "public"."gradebook_column_students" to "service_role";

grant truncate on table "public"."gradebook_column_students" to "service_role";

grant update on table "public"."gradebook_column_students" to "service_role";

grant delete on table "public"."gradebook_columns" to "anon";

grant insert on table "public"."gradebook_columns" to "anon";

grant references on table "public"."gradebook_columns" to "anon";

grant select on table "public"."gradebook_columns" to "anon";

grant trigger on table "public"."gradebook_columns" to "anon";

grant truncate on table "public"."gradebook_columns" to "anon";

grant update on table "public"."gradebook_columns" to "anon";

grant delete on table "public"."gradebook_columns" to "authenticated";

grant insert on table "public"."gradebook_columns" to "authenticated";

grant references on table "public"."gradebook_columns" to "authenticated";

grant select on table "public"."gradebook_columns" to "authenticated";

grant trigger on table "public"."gradebook_columns" to "authenticated";

grant truncate on table "public"."gradebook_columns" to "authenticated";

grant update on table "public"."gradebook_columns" to "authenticated";

grant delete on table "public"."gradebook_columns" to "service_role";

grant insert on table "public"."gradebook_columns" to "service_role";

grant references on table "public"."gradebook_columns" to "service_role";

grant select on table "public"."gradebook_columns" to "service_role";

grant trigger on table "public"."gradebook_columns" to "service_role";

grant truncate on table "public"."gradebook_columns" to "service_role";

grant update on table "public"."gradebook_columns" to "service_role";

grant delete on table "public"."gradebooks" to "anon";

grant insert on table "public"."gradebooks" to "anon";

grant references on table "public"."gradebooks" to "anon";

grant select on table "public"."gradebooks" to "anon";

grant trigger on table "public"."gradebooks" to "anon";

grant truncate on table "public"."gradebooks" to "anon";

grant update on table "public"."gradebooks" to "anon";

grant delete on table "public"."gradebooks" to "authenticated";

grant insert on table "public"."gradebooks" to "authenticated";

grant references on table "public"."gradebooks" to "authenticated";

grant select on table "public"."gradebooks" to "authenticated";

grant trigger on table "public"."gradebooks" to "authenticated";

grant truncate on table "public"."gradebooks" to "authenticated";

grant update on table "public"."gradebooks" to "authenticated";

grant delete on table "public"."gradebooks" to "service_role";

grant insert on table "public"."gradebooks" to "service_role";

grant references on table "public"."gradebooks" to "service_role";

grant select on table "public"."gradebooks" to "service_role";

grant trigger on table "public"."gradebooks" to "service_role";

grant truncate on table "public"."gradebooks" to "service_role";

grant update on table "public"."gradebooks" to "service_role";

create policy "graders and the student views (if released)"
on "public"."gradebook_column_students"
as permissive
for select
to public
using ((authorizeforclassgrader(class_id) OR (authorizeforprofile(student_id) AND released)));


create policy "instructors and graders edit"
on "public"."gradebook_column_students"
as permissive
for update
to public
using (authorizeforclassgrader(class_id));


create policy "instructors CRUD"
on "public"."gradebook_columns"
as permissive
for all
to public
using (authorizeforclassinstructor(class_id));


create policy "everyone in class can view"
on "public"."gradebook_columns"
as permissive
for select
to public
using (authorizeforclass(class_id));


create policy "class views"
on "public"."gradebooks"
as permissive
for select
to public
using (authorizeforclass(class_id));


CREATE TRIGGER trigger_recalculate_dependent_columns AFTER INSERT OR UPDATE ON public.gradebook_column_students FOR EACH ROW EXECUTE FUNCTION gradebook_column_student_recalculate_dependents();

CREATE TRIGGER trg_insert_gradebook_column_students AFTER INSERT ON public.gradebook_columns FOR EACH ROW EXECUTE FUNCTION insert_gradebook_column_students_for_new_column();

CREATE TRIGGER trigger_recalculate_dependent_columns_on_review AFTER INSERT OR UPDATE ON public.submission_reviews FOR EACH ROW EXECUTE FUNCTION submission_review_recalculate_dependent_columns();

CREATE TRIGGER trg_insert_gradebook_column_students_for_new_student AFTER INSERT OR UPDATE ON public.user_roles FOR EACH ROW EXECUTE FUNCTION insert_gradebook_column_students_for_new_student();

-- Trigger to recalculate all student cells for a column when its score_expression changes
CREATE OR REPLACE FUNCTION public.recalculate_gradebook_column_for_all_students()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    messages jsonb[];
BEGIN
    -- Only act if the score_expression has changed
    IF NEW.score_expression IS DISTINCT FROM OLD.score_expression THEN
        -- Gather all students for this column
        SELECT array_agg(
            jsonb_build_object(
                'gradebook_column_id', NEW.id,
                'student_id', gcs.student_id,
                'gradebook_column_student_id', gcs.id
            )
        )
        INTO messages
        FROM gradebook_column_students gcs
        WHERE gcs.gradebook_column_id = NEW.id;

        -- Send all messages in a single batch if there are any
        IF messages IS NOT NULL THEN
            PERFORM pgmq_public.send_batch(
                queue_name := 'gradebook_column_recalculate',
                messages := messages
            );
            PERFORM public.call_edge_function_internal(
                '/functions/v1/gradebook-column-recalculate', 
                'POST', 
                '{"Content-type":"application/json","x-supabase-webhook-source":"gradebook_column_recalculate"}', 
                '{}', 
                5000,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
            );
        END IF;
    END IF;
    RETURN NEW;
END;
$function$;

CREATE TRIGGER trigger_recalculate_column_on_score_expression_change
AFTER UPDATE OF score_expression ON public.gradebook_columns
FOR EACH ROW
EXECUTE FUNCTION public.recalculate_gradebook_column_for_all_students();

DROP VIEW IF EXISTS public.submissions_with_grades_for_assignment;

create or replace view "public"."submissions_with_grades_for_assignment" 
WITH ("security_invoker"='true') 
as  SELECT activesubmissionsbystudent.id,
    activesubmissionsbystudent.class_id,
    activesubmissionsbystudent.assignment_id,
    p.id as student_private_profile_id,
    p.name,
    p.sortable_name,
    s.id AS activesubmissionid,
    s.created_at,
    s.released,
    s.repository,
    s.sha,
    rev.total_autograde_score AS autograder_score,
    rev.grader,
    rev.meta_grader,
    rev.total_score,
    rev.tweak,
    rev.completed_by,
    rev.completed_at,
    rev.checked_at,
    rev.checked_by,
    graderprofile.name AS assignedgradername,
    metagraderprofile.name AS assignedmetagradername,
    completerprofile.name AS gradername,
    checkgraderprofile.name AS checkername,
    ag.name AS groupname,
    activesubmissionsbystudent.tokens_consumed,
    activesubmissionsbystudent.hours,
    activesubmissionsbystudent.due_date,
    (activesubmissionsbystudent.due_date + ('01:00:00'::interval * (activesubmissionsbystudent.hours)::double precision)) AS late_due_date,
    ar.grader_sha,
    ar.grader_action_sha,
    activesubmissionsbystudent.private_profile_id AS student_id,
    activesubmissionsbystudent.slug AS assignment_slug,
    activesubmissionsbystudent.total_points AS assignment_total_points
   FROM (((((((((( SELECT r.id,
                CASE
                    WHEN (isub.id IS NULL) THEN gsub.id
                    ELSE isub.id
                END AS sub_id,
            r.private_profile_id,
            r.class_id,
            a.id AS assignment_id,
            agm.assignment_group_id AS assignmentgroupid,
            lt.tokens_consumed,
            lt.hours,
            a.due_date, a.slug, a.total_points
           FROM (((((user_roles r
             JOIN assignments a ON ((a.class_id = r.class_id)))
             LEFT JOIN submissions isub ON (((isub.profile_id = r.private_profile_id) AND (isub.is_active = true) AND (isub.assignment_id = a.id))))
             LEFT JOIN assignment_groups_members agm ON (((agm.profile_id = r.private_profile_id) AND (agm.assignment_id = a.id))))
             LEFT JOIN ( SELECT sum(assignment_due_date_exceptions.tokens_consumed) AS tokens_consumed,
                    sum(assignment_due_date_exceptions.hours) AS hours,
                    assignment_due_date_exceptions.student_id,
                    assignment_due_date_exceptions.assignment_group_id
                   FROM assignment_due_date_exceptions
                  GROUP BY assignment_due_date_exceptions.student_id, assignment_due_date_exceptions.assignment_group_id) lt ON ((((agm.assignment_group_id IS NULL) AND (lt.student_id = r.private_profile_id)) OR ((agm.assignment_group_id IS NOT NULL) AND (lt.assignment_group_id = agm.assignment_group_id)))))
             LEFT JOIN submissions gsub ON (((gsub.assignment_group_id = agm.id) AND (gsub.is_active = true) AND (gsub.assignment_id = a.id))))
          WHERE (r.role = 'student'::app_role)) activesubmissionsbystudent
     JOIN profiles p ON ((p.id = activesubmissionsbystudent.private_profile_id)))
     LEFT JOIN submissions s ON ((s.id = activesubmissionsbystudent.sub_id)))
     LEFT JOIN submission_reviews rev ON ((rev.id = s.grading_review_id)))
     LEFT JOIN grader_results ar ON ((ar.submission_id = s.id)))
     LEFT JOIN assignment_groups ag ON ((ag.id = activesubmissionsbystudent.assignmentgroupid)))
     LEFT JOIN profiles completerprofile ON ((completerprofile.id = rev.completed_by)))
     LEFT JOIN profiles graderprofile ON ((graderprofile.id = rev.grader)))
     LEFT JOIN profiles metagraderprofile ON ((metagraderprofile.id = rev.meta_grader)))
     LEFT JOIN profiles checkgraderprofile ON ((checkgraderprofile.id = rev.checked_by)));

alter table "public"."gradebook_columns" add constraint "gradebook_columns_class_id_slug_key" unique (class_id, slug);

-- Trigger function to update released status for all students when a column's released status changes
CREATE OR REPLACE FUNCTION public.update_gradebook_column_students_released()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
BEGIN
    -- Only act if the released field has changed
    IF NEW.released IS DISTINCT FROM OLD.released THEN
        UPDATE public.gradebook_column_students
        SET released = NEW.released
        WHERE gradebook_column_id = NEW.id;
    END IF;
    RETURN NEW;
END;
$function$;

CREATE TRIGGER trigger_update_column_students_released
AFTER UPDATE OF released ON public.gradebook_columns
FOR EACH ROW
EXECUTE FUNCTION public.update_gradebook_column_students_released();

CREATE TRIGGER audit_gradebook_columns_insert_update_delete AFTER INSERT OR DELETE OR UPDATE ON public.gradebook_columns FOR EACH ROW EXECUTE FUNCTION audit_insert_and_update_and_delete();
CREATE TRIGGER audit_gradebook_column_students_insert_update_delete AFTER INSERT OR DELETE OR UPDATE ON public.gradebook_column_students FOR EACH ROW EXECUTE FUNCTION audit_insert_and_update_and_delete();

-- Create a gradebook for every class
INSERT into public.gradebooks (name, class_id) select 'Gradebook' as name, id as root_class_id from classes;
UPDATE public.classes set gradebook_id=gradebooks.id from public.gradebooks where classes.id=gradebooks.class_id;

CREATE OR REPLACE FUNCTION public.classes_populate_default_structures()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
    insert into discussion_topics (class_id, topic,color, description, ordinal)
       VALUES (NEW.id, 'Assignments', 'red', 'Questions and notes about assignments.', 1),
       (NEW.id, 'Logistics', 'orange', 'Anything else about the class', 2),
       (NEW.id, 'Readings', 'blue', 'Follow-ups and discussion of assigned and optional readings', 3),
       (NEW.id, 'Memes', 'purple', '#random', 4);
    insert into help_queues (name, description, class_id, available, depth)
       VALUES ('office-hours','This queue is staffed by TAs', NEW.id, TRUE, 0);   
    insert into gradebooks (name, class_id)
       VALUES ('Gradebook', NEW.id);
  UPDATE public.classes set gradebook_id=gradebooks.id from public.gradebooks where classes.id=gradebooks.class_id;
   RETURN NEW;
end$function$
;

-- Create a gradebook column for every assignment
INSERT into public.gradebook_columns (slug, max_score, name, gradebook_id, class_id, score_expression, released, dependencies)

select 'assignment-'||assignments.slug as slug, assignments.total_points as max_score, assignments.title as name, classes.gradebook_id, class_id, 'assignments("'||assignments.slug||'")' as score_expression,false as released, jsonb_build_object('assignments', jsonb_build_array(assignments.id)) from assignments
join classes on assignments.class_id=classes.id;

-- Function to create a gradebook column for a new assignment
CREATE OR REPLACE FUNCTION public.create_gradebook_column_for_assignment()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    gradebook_id bigint;
BEGIN
    -- Get the gradebook_id for this class
    SELECT g.id INTO gradebook_id
    FROM public.gradebooks g
    WHERE g.class_id = NEW.class_id;

    -- Create the gradebook column
    INSERT INTO public.gradebook_columns (
        name,
        max_score,
        slug,
        class_id,
        gradebook_id,
        score_expression,
        released,
        dependencies
    ) VALUES (
        NEW.title,
        NEW.total_points,
        'assignment-' || NEW.slug,
        NEW.class_id,
        gradebook_id,
        'assignments("' || NEW.slug || '")',
        false,
        jsonb_build_object('assignments', jsonb_build_array(NEW.id))
    );

    RETURN NEW;
END;
$function$;

-- Create trigger for new assignments
CREATE TRIGGER trigger_create_gradebook_column_for_assignment
AFTER INSERT ON public.assignments
FOR EACH ROW
EXECUTE FUNCTION public.create_gradebook_column_for_assignment();

CREATE OR REPLACE FUNCTION public.audit_insert_and_update_and_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
    declare
      remote_ip text;
BEGIN
SELECT split_part(
  current_setting('request.headers', true)::json->>'x-forwarded-for',
  ',', 1) into remote_ip;
   CASE TG_OP
   WHEN 'UPDATE' THEN
      INSERT INTO public.audit (class_id,user_id,"table",old,new, ip_addr) values
      (NEW.class_id,
      auth.uid(),
      TG_TABLE_NAME,
      row_to_json(OLD.*),
      row_to_json(NEW.*),
      remote_ip
      );
      RETURN NULL;
   WHEN 'INSERT' THEN
      INSERT INTO public.audit (class_id,user_id,"table",old,new, ip_addr) values
      (NEW.class_id,
      auth.uid(),
      TG_TABLE_NAME,
      NULL,
      row_to_json(NEW.*),
      remote_ip
      );
      RETURN NULL;
   WHEN 'DELETE' THEN
      INSERT INTO public.audit (class_id,user_id,"table",old,new, ip_addr) values
      (OLD.class_id,
      auth.uid(),
      TG_TABLE_NAME,
      row_to_json(OLD.*),
      NULL,
      remote_ip
      );
      RETURN NULL;
   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
END;
$function$
;

CREATE OR REPLACE FUNCTION public.audit_insert_and_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
    declare
      remote_ip text;
BEGIN
SELECT split_part(
  current_setting('request.headers', true)::json->>'x-forwarded-for',
  ',', 1) into remote_ip;
   CASE TG_OP
   WHEN 'UPDATE' THEN
      INSERT INTO public.audit (class_id,user_id,"table",old,new, ip_addr) values
      (NEW.class_id,
      auth.uid(),
      TG_TABLE_NAME,
      row_to_json(OLD.*),
      row_to_json(NEW.*),
      remote_ip
      );
      RETURN NULL;
   WHEN 'INSERT' THEN
      INSERT INTO public.audit (class_id,user_id,"table",old,new, ip_addr) values
      (NEW.class_id,
      auth.uid(),
      TG_TABLE_NAME,
      NULL,
      row_to_json(NEW.*),
      remote_ip
      );
      RETURN NULL;
   ELSE
      RAISE EXCEPTION 'Unexpected TG_OP: "%". Should not occur!', TG_OP;
   END CASE;
   
END;
$function$
;

alter table "public"."assignments" add column "gradebook_column_id" bigint;

-- Function to create a gradebook column for a new assignment
CREATE OR REPLACE FUNCTION public.create_gradebook_column_for_assignment()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    gradebook_id bigint;
    new_col_id bigint;
BEGIN
    -- Get the gradebook_id for this class
    SELECT g.id INTO gradebook_id
    FROM public.gradebooks g
    WHERE g.class_id = NEW.class_id;

    -- Create the gradebook column
    INSERT INTO public.gradebook_columns (
        name,
        max_score,
        slug,
        class_id,
        gradebook_id,
        score_expression,
        released,
        dependencies
    ) VALUES (
        NEW.title,
        NEW.total_points,
        'assignment-' || NEW.slug,
        NEW.class_id,
        gradebook_id,
        'assignments("' || NEW.slug || '")',
        false,
        jsonb_build_object('assignments', jsonb_build_array(NEW.id))
    ) RETURNING id into new_col_id;

    UPDATE public.assignments set gradebook_column_id = new_col_id;

    RETURN NEW;
END;
$function$;

-- Function to update gradebook column max_score when assignment total_points changes
CREATE OR REPLACE FUNCTION public.update_gradebook_column_max_score()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
BEGIN
    -- Only update if total_points changed and there's an associated gradebook column
    IF OLD.total_points IS DISTINCT FROM NEW.total_points AND NEW.gradebook_column_id IS NOT NULL THEN
        UPDATE public.gradebook_columns 
        SET max_score = NEW.total_points
        WHERE id = NEW.gradebook_column_id;
    END IF;

    RETURN NEW;
END;
$function$;

-- Create trigger to update gradebook column max_score on assignment update
CREATE TRIGGER update_gradebook_column_max_score_trigger
    AFTER UPDATE ON public.assignments
    FOR EACH ROW
    EXECUTE FUNCTION public.update_gradebook_column_max_score();